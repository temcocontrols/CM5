C51 COMPILER V9.00   GUDPBC                                                                05/08/2013 16:47:35 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE GUDPBC
OBJECT MODULE PLACED IN .\Build\gudpbc.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE management\gudpbc.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..
                    -\SRC\FreeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\
                    -SRC\UART\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\
                    -;..\SRC\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\managemen
                    -t\;..\SRC\dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule;..\SRC\program;..\SRC\S
                    -can) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\gudpbc.lst) OBJECT(.\Build\gudpbc.obj)

line level    source

   1          /*
   2           ******************************************************************************
   3           *     Copyright (c) 2006       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           ******************************************************************************
  10           */
  11           /*============================================================================
  12           * Module Name: gudpbc.c
  13           * Purpose:
  14           * Author:
  15           * Date:
  16           * Notes:
  17           * $Log: gudpbc.c,v $
  18           *
  19           *=============================================================================
  20           */
  21          
  22          /* INCLUDE FILE DECLARATIONS */
  23          #include "reg80390.h"
  24          #include "adapter.h"
  25          #include "gudpbc.h"
  26          #include "tcpip.h"
  27          #include "mstimer.h"
  28          #include "stoe.h"
  29          #include "uart.h"
  30          #include "gconfig.h"
  31          #include "ax11000.h"
  32          #include "mac.h"
  33          #include "flash.h"
  34          #include "i2c.h"
  35          #include "i2capi.h"
  36          //#include "printd.h"
  37          #include "main.h"
  38          #include <string.h>
  39          #include "lcd.h"
  40          //#include "8563.h"
  41          //#include "ch375_RNDIS.h"
  42          
  43          /* NAMING CONSTANT DECLARATIONS */
  44          #define GS2E_ENABLE_STATE_MACHINE       0
  45          #define GUDPBC_EEPROM_CONFIG            (GCONFIG_EEPROM_CONFIG)
  46          #define GUDPBC_ENABLE_DEBUG_MSG         0 // 1: enable 0:disable
  47          
  48          #define GUDPBC_MAX_CONNS                        4
  49          #define GUDPBC_NO_NEW_CONN                      0xFF
  50          
C51 COMPILER V9.00   GUDPBC                                                                05/08/2013 16:47:35 PAGE 2   

  51          #define GUDPBC_STATE_FREE                       0
  52          #define GUDPBC_STATE_WAIT                       1
  53          #define GUDPBC_STATE_CONNECTED          2
  54          
  55          
  56          /* GLOBAL VARIABLES DECLARATIONS */
  57          
  58          /* LOCAL VARIABLES DECLARATIONS */
  59          static GUDPBC_CONN gudpbc_Conns[GUDPBC_MAX_CONNS];
  60           U8_T gudpbc_InterAppId;
  61          static GCONFIG_CFG_PKT gudpbc_ConfigTxPkt;
  62          static GCONFIG_CFG_PKT gudpbc_ConfigRxPkt;
  63          
  64          /* LOCAL SUBPROGRAM DECLARATIONS */
  65          void gudpbc_HandleSearchReq(U8_T XDATA* pData, U8_T id);
  66          void gudpbc_HandleSetReq(U8_T XDATA* pData, U16_T length, U8_T id);
  67          void gudpbc_HandleUpgradeReq(U8_T XDATA* pData, U16_T length, U8_T id);
  68          void gudpbc_HandleResetReq(U8_T XDATA* pData, U16_T length, U8_T id);
  69          void gudpbc_HandleRebootReq(U8_T XDATA* pData, U16_T length, U8_T id);
  70          #if GUDPBC_EEPROM_CONFIG
              void gudpbc_HandleEepromReadReq(U8_T XDATA* pData, U16_T length, U8_T id);
              void gudpbc_HandleEepromWriteReq(U8_T XDATA* pData, U16_T length, U8_T id);
              #endif
  74          
  75          
  76          /* add for private application */
  77          U8_T    FlagIsp=0;
  78          U16_T   UdpPort=1234;
  79          /* NC information structure */
  80          U8_T    InformationStr[40];
  81          
  82          U8_T    state=1;
  83          U8_T    scanstart=0;
  84          
  85          void UdpData(void)
  86           {
  87   1              // header 2 bytes
  88   1              InformationStr[0] = 0x65;
  89   1              InformationStr[1] = 0x00;
  90   1              InformationStr[2] = 0x0b;
  91   1              InformationStr[3] = 0x00;
  92   1              //serialnumber 4 bytes
  93   1              InformationStr[4] =  serialNum[0];
  94   1              InformationStr[5] = 0;
  95   1              InformationStr[6] =  serialNum[1];
  96   1              InformationStr[7] = 0;
  97   1              InformationStr[8] =  serialNum[2];
  98   1              InformationStr[9] = 0;
  99   1              InformationStr[10] =  serialNum[3];
 100   1              InformationStr[11] = 0;
 101   1              //nc 
 102   1              InformationStr[12] = PRODUCT_CM5;
 103   1              InformationStr[13] = 0;
 104   1              //modbus address
 105   1              InformationStr[14] =  Modbus_address;
 106   1              InformationStr[15] = 0;
 107   1              //Ip
 108   1              InformationStr[16] =    IP_Addr[0];
 109   1              InformationStr[17] = 0;
 110   1              InformationStr[18] =    IP_Addr[1];
 111   1              InformationStr[19] = 0;
 112   1              InformationStr[20] =    IP_Addr[2];
C51 COMPILER V9.00   GUDPBC                                                                05/08/2013 16:47:35 PAGE 3   

 113   1              InformationStr[21] = 0;
 114   1              InformationStr[22] =    IP_Addr[3];
 115   1              InformationStr[23] = 0;
 116   1              //port
 117   1              InformationStr[24]=(U8_T)(HTTP_SERVER_PORT);
 118   1              InformationStr[25]=(U8_T)(HTTP_SERVER_PORT>>8);
 119   1      
 120   1              // software rev
 121   1              InformationStr[26]=(U8_T)(SW_REV);
 122   1              InformationStr[27]=(U8_T)(SW_REV>>8);
 123   1              // hardware rev
 124   1      
 125   1              InformationStr[28]=(U8_T)(HW_REV);
 126   1              InformationStr[29]=(U8_T)(HW_REV>>8);
 127   1       }
 128           
 129          
 130          #if 0  //LHN ADD for time server
              
              #define Bace_s           3439756800   //from 2009.1.1 
              #define Bace_Week        3            //2009.1.1 Tuesday
              #define Bace_year        2009  
              #define Bace_Time_Zone   43200        //Zone -12        
              #define Day_s            86400
              #define Hour_s           3600
              #define Min_s            60
              #define year_Day         365
              
              
              void TimeServer_Deal(U32_T time,U8_T time_zone)
              {
                      U32_T time_s=0;
                      U32_T time_year=0;
                      U32_T time_day=0;
                      U32_T time_h=0;
              
                      time_s = time - Bace_s + ((U32_T)time_zone) * Hour_s - Bace_Time_Zone;
              
                      if(time_s)
                      {
                              time_day = time_s / Day_s ;
                              time_h = time_s % Day_s;
              
                              Time.UN.Setime[3] = (U8_T)(time_day % 7 + Bace_Week) % 7 + 1;  //Week
              
                              if( (time_day % year_Day)  >= ((time_day / year_Day ) / 4) )
                              {
                                      time_year = time_day / year_Day + Bace_year;   
                                      time_day = time_day % year_Day - (time_day / year_Day)/4;
                              }
                              else
                              {
                                      time_year = time_day / year_Day + Bace_year - 1;
                                  if((time_day / year_Day ) / 4)
                                              time_day = 366 + time_day % year_Day - (time_day / year_Day)/4; 
                                      else
                                              time_day = 365 + time_day % year_Day - (time_day / year_Day)/4; 
                              }
              
                              Time.UN.Setime[0] = (U8_T)(time_year / 100);           //year high
                              Time.UN.Setime[1] = (U8_T)(time_year % 100);           //year low
              
C51 COMPILER V9.00   GUDPBC                                                                05/08/2013 16:47:35 PAGE 4   

                              if(!(time_year % 4))  //leap year
                              {
                                      if( (time_day >= 0) && (time_day <= 30) ) // january
                                      {
                                              Time.UN.Setime[2] = 1;               //month                     
                                              Time.UN.Setime[4] = time_day + 1;    //day
                                      }
                                      else if( (time_day >= 31) && (time_day <= 59) ) // february
                                      {
                                              Time.UN.Setime[2] = 2;
                                              Time.UN.Setime[4] = time_day - 31 + 1;  
                                      }
                                      else if( (time_day >= 60) && (time_day <= 90) ) //3
                                      {
                                              Time.UN.Setime[2] = 3;
                                              Time.UN.Setime[4] = time_day - 60 + 1;  
                                      }
                                      else if( (time_day >= 91) && (time_day <= 120) )//4
                                      {
                                              Time.UN.Setime[2] = 4;
                                              Time.UN.Setime[4] = time_day - 91 + 1;  
                                      }
                                      else if( (time_day >= 121) && (time_day <= 151) ) //5
                                      {
                                              Time.UN.Setime[2] = 5;
                                              Time.UN.Setime[4] = time_day - 121 + 1; 
                                      }
                                      else if( (time_day >= 152) && (time_day <= 181) ) //6
                                      {
                                              Time.UN.Setime[2] = 6;
                                              Time.UN.Setime[4] = time_day - 152 + 1; 
                                      }
                                      else if( (time_day >= 182) && (time_day <= 212) ) //7
                                      {
                                              Time.UN.Setime[2] = 7;
                                              Time.UN.Setime[4] = time_day - 182 + 1; 
                                      }
                                      else if( (time_day >= 213) && (time_day <= 243) ) //8
                                      {
                                              Time.UN.Setime[2] = 8;
                                              Time.UN.Setime[4] = time_day - 213 + 1; 
                                      }
                                      else if( (time_day >= 244) && (time_day <= 273) ) //9
                                      {
                                              Time.UN.Setime[2] = 9;
                                              Time.UN.Setime[4] = time_day - 243 + 1; 
                                      }
                                      else if( (time_day >= 274) && (time_day <= 304) ) //10
                                      {
                                              Time.UN.Setime[2] = 10;
                                              Time.UN.Setime[4] = time_day - 274 + 1; 
                                      }
                                      else if( (time_day >= 305) && (time_day <= 334) ) //11
                                      {
                                              Time.UN.Setime[2] = 11;
                                              Time.UN.Setime[4] = time_day - 304 + 1; 
                                      }
                                      else if( (time_day >= 335) && (time_day <= 365) ) //12
                                      {
                                              Time.UN.Setime[2] = 12;
                                              Time.UN.Setime[4] = time_day - 335 + 1; 
                                      }
C51 COMPILER V9.00   GUDPBC                                                                05/08/2013 16:47:35 PAGE 5   

              
                              }
                              else
                              {
                                      if( (time_day >= 0) && (time_day <= 30) ) // january
                                      {
                                              Time.UN.Setime[2] = 1;
                                              Time.UN.Setime[4] = time_day - 0 + 1;
                                      }
                                      else if( (time_day >= 31) && (time_day <= 58) ) // february
                                      {
                                              Time.UN.Setime[2] = 2;
                                              Time.UN.Setime[4] = time_day - 31 + 1;  
                                      }
                                      else if( (time_day >= 59) && (time_day <= 89) ) //3
                                      {
                                              Time.UN.Setime[2] = 3;
                                              Time.UN.Setime[4] = time_day - 59 + 1;  
                                      }
                                      else if( (time_day >= 90) && (time_day <= 119) )//4
                                      {
                                              Time.UN.Setime[2] = 4;
                                              Time.UN.Setime[4] = time_day - 90 + 1;  
                                      }
                                      else if( (time_day >= 120) && (time_day <= 150) ) //5
                                      {
                                              Time.UN.Setime[2] = 5;
                                              Time.UN.Setime[4] = time_day - 120 + 1; 
                                      }
                                      else if( (time_day >= 151) && (time_day <= 180) ) //6
                                      {
                                              Time.UN.Setime[2] = 6;
                                              Time.UN.Setime[4] = time_day - 151 + 1; 
                                      }
                                      else if( (time_day >= 181) && (time_day <= 211) ) //7
                                      {
                                              Time.UN.Setime[2] = 7;
                                              Time.UN.Setime[4] = time_day - 181 + 1; 
                                      }
                                      else if( (time_day >= 212) && (time_day <= 242) ) //8
                                      {
                                              Time.UN.Setime[2] = 8;
                                              Time.UN.Setime[4] = time_day - 212 + 1; 
                                      }
                                      else if( (time_day >= 243) && (time_day <= 272) ) //9
                                      {
                                              Time.UN.Setime[2] = 9;
                                              Time.UN.Setime[4] = time_day - 242 + 1; 
                                      }
                                      else if( (time_day >= 273) && (time_day <= 303) ) //10
                                      {
                                              Time.UN.Setime[2] = 10;
                                              Time.UN.Setime[4] = time_day - 273 + 1; 
                                      }
                                      else if( (time_day >= 304) && (time_day <= 333) ) //11
                                      {
                                              Time.UN.Setime[2] = 11;
                                              Time.UN.Setime[4] = time_day - 303 + 1; 
                                      }
                                      else if( (time_day >= 334) && (time_day <= 364) ) //12
                                      {
                                              Time.UN.Setime[2] = 12;
C51 COMPILER V9.00   GUDPBC                                                                05/08/2013 16:47:35 PAGE 6   

                                              Time.UN.Setime[4] = time_day - 334 + 1; 
                                      }
                      
                              }
                              Time.UN.Setime[5] = (U8_T)(time_h / Hour_s);  //Hour
                              time_h = time_h % Hour_s;
                              Time.UN.Setime[6] = (U8_T)(time_h / Min_s);  //minute
                              Time.UN.Setime[7] = (U8_T)(time_h % Min_s); //second            
                              
                              Initial_Clock();
                      //      Uart0_Tx(Time.UN.Setime,8);
                      }
              }
              
              #endif
 314          
 315          
 316          
 317          #if GUDPBC_EEPROM_CONFIG
              /*
               * ----------------------------------------------------------------------------
               * Function Name: I2C_Init
               * Purpose:
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void I2C_Init(void)
              {
                      switch (CSREPR & (BIT6|BIT7))
                      {
                              case SYS_CLK_100M :
                                      /* I2C master mode, interrupt enable, fast mode in slave, 7-bits address, 400KHz at 100M */
                                      I2C_Setup(I2C_ENB|I2C_FAST|I2C_MST_IE|I2C_7BIT|I2C_MASTER_MODE, 0x0031, 0x005A);
                                      break;
                              case SYS_CLK_50M :
                                      /* I2C master mode, interrupt enable, fast mode in slave, 7-bits address, 400KHz at 50M */
                                      I2C_Setup(I2C_ENB|I2C_FAST|I2C_MST_IE|I2C_7BIT|I2C_MASTER_MODE, 0x0018, 0x005A);
                                      break;
                              case SYS_CLK_25M :
                                      /* I2C master mode, interrupt enable, fast mode in slave, 7-bits address, 400KHz at 25M */
                                      I2C_Setup(I2C_ENB|I2C_FAST|I2C_MST_IE|I2C_7BIT|I2C_MASTER_MODE, 0x000c, 0x005A);
                                      break;
                      }
              }
              #endif
 346          
 347          /*
 348           * ----------------------------------------------------------------------------
 349           * Function Name: GUDPBC_Task
 350           * Purpose: 
 351           * Params:
 352           * Returns:
 353           * Note:
 354           * ----------------------------------------------------------------------------
 355           */
 356          void GUDPBC_Task(void)
 357          {
 358   1      
 359   1      } /* End of GUDPBC_Task() */
 360          
C51 COMPILER V9.00   GUDPBC                                                                05/08/2013 16:47:35 PAGE 7   

 361          /*
 362           * ----------------------------------------------------------------------------
 363           * Function Name: GUDPBC_Init()
 364           * Purpose: Initialization
 365           * Params:
 366           * Returns:
 367           * Note:
 368           * ----------------------------------------------------------------------------
 369           */
 370          void GUDPBC_Init(U16_T localPort)
 371          {
 372   1              U8_T    i;
 373   1      
 374   1      //      printd("GUDPBC_Init()...\n\r");
 375   1      
 376   1              for (i = 0; i < GUDPBC_MAX_CONNS; i++)
 377   1                      gudpbc_Conns[i].State = GUDPBC_STATE_FREE;
 378   1      
 379   1              gudpbc_InterAppId = TCPIP_Bind(GUDPBC_NewConn, GUDPBC_Event, GUDPBC_Receive);
 380   1                      
 381   1              /* unicast packet */
 382   1      //      TCPIP_UdpListen(123, gudpbc_InterAppId);
 383   1              TCPIP_UdpListen(localPort, gudpbc_InterAppId);
 384   1              
 385   1      } /* End of GUDPBC_Init() */
 386          
 387          /*
 388           * ----------------------------------------------------------------------------
 389           * Function Name: GUDPBC_NewConn
 390           * Purpose: 
 391           * Params:
 392           * Returns:
 393           * Note:
 394           * ----------------------------------------------------------------------------
 395           */
 396          U8_T GUDPBC_NewConn(U32_T XDATA* pip, U16_T remotePort, U8_T socket)
 397          {
 398   1              U8_T    i;
 399   1      
 400   1              pip = pip;
 401   1              remotePort = remotePort;
 402   1      
 403   1      #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("GUDPBC_NewConn(remotePort=%d, socket=%d)\n\r",remotePort,socket);
              #endif  
 406   1      
 407   1              for (i = 0; i < GUDPBC_MAX_CONNS; i++)
 408   1              {
 409   2                      if (gudpbc_Conns[i].State == GUDPBC_STATE_FREE)
 410   2                      {
 411   3                              gudpbc_Conns[i].State = GUDPBC_STATE_CONNECTED;
 412   3      //                      gudpbc_Conns[i].Timer = (U16_T)SWTIMER_Tick();
 413   3      //                      gudpbc_Conns[i].Ip = *pip;
 414   3      //                      gudpbc_Conns[i].Port = remotePort;
 415   3                              gudpbc_Conns[i].UdpSocket = socket;
 416   3                              return i;
 417   3                      }
 418   2              }
 419   1              
 420   1              return GUDPBC_NO_NEW_CONN;
 421   1      
 422   1      } /* End of GUDPBC_NewConn() */
C51 COMPILER V9.00   GUDPBC                                                                05/08/2013 16:47:35 PAGE 8   

 423          
 424          /*
 425           * ----------------------------------------------------------------------------
 426           * Function Name: GUDPBC_Event
 427           * Purpose: 
 428           * Params:
 429           * Returns:
 430           * Note:
 431           * ----------------------------------------------------------------------------
 432           */
 433          void GUDPBC_Event(U8_T id, U8_T event)
 434          {
 435   1              gudpbc_Conns[id].State = event;
 436   1      
 437   1      } /* End of GUDPBC_Event() */
 438          
 439          /*
 440           * ----------------------------------------------------------------------------
 441           * Function Name: GUDPBC_Receive
 442           * Purpose: 
 443           * Params:
 444           * Returns:
 445           * Note:
 446           * ----------------------------------------------------------------------------
 447           */
 448          U8_T IDATA fwAutoUpdated[4] _at_ 0x31;
 449          void GUDPBC_Receive(U8_T XDATA* pData, U16_T length, U8_T id)
 450          {
 451   1              U8_T opcode = 0xFF;
 452   1              BOOL bValidReq = FALSE;
 453   1              GCONFIG_MAC_ADDR macAddr;
 454   1              U8_T  n=0;
 455   1      
 456   1              if((pData[0]==100)&&(pData[1]==0))
 457   1              { 
 458   2                      scanstart=1;
 459   2                      state=1;
 460   2              }
 461   1              if(scanstart)
 462   1              {  
 463   2                      for(n = 0;n < (U8_T)length / 4;n++)
 464   2                      { 
 465   3                              if((pData[4*n+1] == 0xC0) && (pData[4*n+2] == 0xa8)
 466   3                                      &&(pData[4*n+3] == 0x00) && (pData[4*n+4] == 0x03))
 467   3                              { 
 468   4                                      scanstart=0;
 469   4                                      state=0;
 470   4                                      break;
 471   4                              }
 472   3                      }
 473   2      
 474   2                      if(state)
 475   2                      {
 476   3                      //                              gudpbc_HandleSearchReq(pData, id);
 477   3                              //use broadcast when scan
 478   3                              U8_T socket = TCPIP_UdpNew(2, 3, 0xffffffff, 0, 4321);
 479   3                              UdpData();
 480   3                              TCPIP_UdpSend(socket, 0, 0, InformationStr, 40);
 481   3                              TCPIP_UdpClose(socket);
 482   3                      }    
 483   2                      
 484   2              }
C51 COMPILER V9.00   GUDPBC                                                                05/08/2013 16:47:35 PAGE 9   

 485   1      
 486   1      
 487   1                      
 488   1                                
 489   1              if((pData[0]==0xee)&&(pData[1]==0x10))
 490   1              {   
 491   2                      gudpbc_HandleSearchReq(pData, id); 
 492   2                      IntFlashErase(ERA_RUN,0x60000);
 493   2                      FlagIsp=1;
 494   2                      RELAY1_8 = 0;
 495   2                      RELAY_LATCH = 0; 
 496   2                      RELAY_LATCH = 1;                
 497   2                      DI2_LATCH = 1;
 498   2                      KEY_LATCH = 1;
 499   2                      DI1_LATCH = 1;
 500   2                      P1 = 0xFF;
 501   2      
 502   2                      fwAutoUpdated[0] = 'a';
 503   2                      fwAutoUpdated[1] = 's';
 504   2                      fwAutoUpdated[2] = 'i';
 505   2                      fwAutoUpdated[3] = 'x';
 506   2                      AX11000_SoftReboot();   
 507   2              }
 508   1      
 509   1                      
 510   1         /*    if(pData[0]==100)
 511   1                       {  while( (pData[i]!=Para[13])&& (i<length) )
 512   1                    i++;
 513   1                  if(i==length)
 514   1                   gudpbc_HandleSearchReq(pData, id);
 515   1                 
 516   1                }
 517   1            */          
 518   1      } 
*** WARNING C280 IN LINE 453 OF MANAGEMENT\GUDPBC.C: 'macAddr': unreferenced local variable
 519          /*
 520           * ----------------------------------------------------------------------------
 521           * Function Name: gudpbc_HandleSearchReq
 522           * Purpose: 
 523           * Params:
 524           * Returns:
 525           * Note:
 526           * ----------------------------------------------------------------------------
 527           */
 528          void gudpbc_HandleSearchReq(U8_T XDATA* pData, U8_T id)
 529          {
 530   1              pData = pData;
 531   1              UdpData();
 532   1              TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, InformationStr, 26);
 533   1      
 534   1      }/* End of gudpbc_HandleSearchReq() */
 535          
 536          /*
 537           * ----------------------------------------------------------------------------
 538           * Function Name: gudpbc_HandleSetReq
 539           * Purpose: 
 540           * Params:
 541           * Returns:
 542           * Note:
 543           * ----------------------------------------------------------------------------
 544           */
 545          void gudpbc_HandleSetReq(U8_T XDATA* pData, U16_T length, U8_T id)
C51 COMPILER V9.00   GUDPBC                                                                05/08/2013 16:47:35 PAGE 10  

 546          {
 547   1      #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleSetReq()...\n\r");
              #endif
 550   1      
 551   1      #if GS2E_ENABLE_STATE_MACHINE   
                      if (GS2E_GetTaskState() == GS2E_STATE_IDLE)
              #else
 554   1              if (1)
 555   1      #endif
 556   1              {
 557   2                      GCONFIG_SetConfigPacket(&gudpbc_ConfigRxPkt);
 558   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_SET_ACK;
 559   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 560   2              }
 561   1              else
 562   1              {
 563   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_SET_DENY;     
 564   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);         
 565   2              }
 566   1      } /* End of gudpbc_HandleSetReq() */
 567          
 568          /*
 569           * ----------------------------------------------------------------------------
 570           * Function Name: gudpbc_HandleUpgradeReq
 571           * Purpose: 
 572           * Params:
 573           * Returns:
 574           * Note:
 575           * ----------------------------------------------------------------------------
 576           */
 577          void gudpbc_HandleUpgradeReq(U8_T XDATA* pData, U16_T length, U8_T id)
 578          {       
 579   1      #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleUpgradeReq()...\n\r");
              #endif
 582   1      
 583   1      #if GS2E_ENABLE_STATE_MACHINE   
                      if (GS2E_GetTaskState() == GS2E_STATE_IDLE)
              #else
 586   1              if (1)
 587   1      #endif
 588   1              {
 589   2                      GCONFIG_SetFirmwareUpgradeMode(GCONFIG_FW_UPGRADE_ENABLE);
 590   2                      GCONFIG_WriteConfigData();
 591   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_UPGRADE_ACK;
 592   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 593   2              //      FirmwareUpdate();
 594   2              }
 595   1              else
 596   1              {
 597   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_UPGRADE_DENY;         
 598   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 599   2              }
 600   1      } /* End of gudpbc_HandleUpgradeReq() */
 601          
 602          /*
 603           * ----------------------------------------------------------------------------
 604           * Function Name: gudpbc_HandleResetReq
 605           * Purpose: 
 606           * Params:
 607           * Returns:
C51 COMPILER V9.00   GUDPBC                                                                05/08/2013 16:47:35 PAGE 11  

 608           * Note:
 609           * ----------------------------------------------------------------------------
 610           */
 611          void gudpbc_HandleResetReq(U8_T XDATA* pData, U16_T length, U8_T id)
 612          {
 613   1      #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleResetReq()...\n\r");
              #endif
 616   1      
 617   1      #if GS2E_ENABLE_STATE_MACHINE   
                      if (GS2E_GetTaskState() == GS2E_STATE_IDLE)
              #else
 620   1              if (1)
 621   1      #endif
 622   1              {
 623   2                      GCONFIG_ReadDefaultConfigData();
 624   2                      GCONFIG_WriteConfigData();
 625   2                      GCONFIG_GetConfigPacket(&gudpbc_ConfigRxPkt);
 626   2                      gudpbc_ConfigRxPkt.Opcode = GCONFIG_OPCODE_RESET_ACK;
 627   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, (U8_T*) &gudpbc_ConfigRxPkt, GCONFIG_CFG_PKT_LEN);
 628   2              }
 629   1              else
 630   1              {
 631   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_RESET_DENY;   
 632   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 633   2              }
 634   1      } /* End of gudpbc_HandleResetReq() */
 635          
 636          /*
 637           * ----------------------------------------------------------------------------
 638           * Function Name: gudpbc_HandleRebootReq
 639           * Purpose: 
 640           * Params:
 641           * Returns:
 642           * Note:
 643           * ----------------------------------------------------------------------------
 644           */
 645          void gudpbc_HandleRebootReq(U8_T XDATA* pData, U16_T length, U8_T id)
 646          {
 647   1      #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleRebootReq()...\n\r");
              #endif
 650   1      
 651   1      #if GS2E_ENABLE_STATE_MACHINE
                      if (GS2E_GetTaskState() == GS2E_STATE_IDLE)
              #else
 654   1              if (1)
 655   1      #endif
 656   1              {
 657   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_REBOOT_ACK;   
 658   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 659   2                      // May store current status/setting here before restart
 660   2              
 661   2                      AX11000_SoftReboot();
 662   2              }
 663   1              else
 664   1              {
 665   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_RESET_DENY;   
 666   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 667   2              }
 668   1      } /* End of gudpbc_HandleRebootReq() */
 669          
C51 COMPILER V9.00   GUDPBC                                                                05/08/2013 16:47:35 PAGE 12  

 670          #if GUDPBC_EEPROM_CONFIG
              /*
               * ----------------------------------------------------------------------------
               * Function Name: gudpbc_HandleEepromReadReq
               * Purpose: 
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void gudpbc_HandleEepromReadReq(U8_T XDATA* pData, U16_T length, U8_T id)
              {
              #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleEepromReadReq()...\n\r");
              #endif
              
                      GCONFIG_GetConfigPacket(&gudpbc_ConfigRxPkt);
                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_EEPROM_READ_ACK;
                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
              }
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: gudpbc_HandleEepromWriteReq
               * Purpose: 
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void gudpbc_HandleEepromWriteReq(U8_T XDATA* pData, U16_T length, U8_T id)
              {
              #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleEepromWriteReq()...\n\r");
              #endif
              
                      GCONFIG_SetEpromData(&gudpbc_ConfigRxPkt);
                      GCONFIG_SetConfigPacket(&gudpbc_ConfigRxPkt);
                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_EEPROM_WRITE_ACK;
                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
              }
              #endif
 712          /* End of gudpbc.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1352    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    194      36
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
