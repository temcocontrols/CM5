C51 COMPILER V9.00   ADAPTER                                                               05/08/2013 16:47:34 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE ADAPTER
OBJECT MODULE PLACED IN .\Build\adapter.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ADAPTER\adapter.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\S
                    -RC\FreeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\SR
                    -C\UART\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;.
                    -.\SRC\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management\
                    -;..\SRC\dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule;..\SRC\program;..\SRC\Sca
                    -n) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\adapter.lst) OBJECT(.\Build\adapter.obj)

line level    source

   1          /*
   2           ******************************************************************************
   3           *     Copyright (c) 2006       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           ******************************************************************************
  10           */
  11           /*============================================================================
  12           * Module Name: adapter.c
  13           * Purpose:
  14           * Author:
  15           * Date:
  16           * Notes:
  17           * $Log: adapter.c,v $
  18           *=============================================================================
  19           */
  20          
  21          /* INCLUDE FILE DECLARATIONS */
  22          #include "adapter.h"
  23          #include "stoe.h"
  24          #include "dma.h"
  25          #include "tcpip.h"
  26          #include "pppoe.h"
  27          #if (!STOE_TRANSPARENT)
  28          #include "mstimer.h"
  29          #endif
  30          
  31          
  32          /* NAMING CONSTANT DECLARATIONS */
  33          #define ETH_HEADER_LEN          14
  34          #define ETH_NON_TRANSPARENT     0
  35          #define ETH_TRANSPARENT         1
  36          #if (!STOE_TRANSPARENT)
  37          #define ETH_ARP_SEND_INTERVAL_TIME      300
  38          #endif
  39          
  40          /* GLOBAL VARIABLES DECLARATIONS */
  41          U8_T ETH_IsPppoe = 0;
  42          U8_T ETH_DoDhcp = 0;
  43          U8_T ETH_PppoeHeaderLen = 0;
  44          
  45          
  46          /* LOCAL VARIABLES DECLARATIONS */
  47          static U8_T eth_EthHeadLen = 0;
  48          static U16_T eth_PayLoadOffset = 0;
  49          #if (!STOE_TRANSPARENT)
  50          static BOOL eth_GatewayArpStaticFlag = FALSE;
C51 COMPILER V9.00   ADAPTER                                                               05/08/2013 16:47:34 PAGE 2   

  51          static U32_T eth_ArpSendIntervalTime = 5;
  52          static U32_T eth_ArpSendTime = 0;
  53          #endif
  54          
  55          extern  U8_T far Mac_Addr[6];
  56          
  57          
  58          
  59          /* LOCAL SUBPROGRAM DECLARATIONS */
  60          static void eth_RcvHandle(U8_T XDATA*, U16_T, U8_T);
  61          #if (!STOE_TRANSPARENT)
  62          static BOOL eth_CheckGatewayIp(U8_T XDATA* pBuf);
  63          #endif
  64          
  65          /*
  66           * ----------------------------------------------------------------------------
  67           * Function Name: ETH_Init
  68           * Purpose:
  69           * Params:
  70           * Returns:
  71           * Note:
  72           * ----------------------------------------------------------------------------
  73           */
  74          void ETH_Init(void)
  75          {
  76   1              U8_T*           point;
  77   1      
  78   1              /* ethernet initiation */
  79   1              STOE_Init(ETH_PHY_SENSE_TYPE);
  80   1              STOE_RcvCallback = eth_RcvHandle;
  81   1      
  82   1      #if (STOE_TRANSPARENT)
                      /* Initialise TCP/UDP up-layer interfaces */
                      TCPIP_Init(ETH_TRANSPARENT);
                      eth_EthHeadLen = ETH_HEADER_LEN;
              #else
  87   1              TCPIP_Init(ETH_NON_TRANSPARENT);
  88   1              eth_EthHeadLen = 0;
  89   1      #endif
  90   1          /* Initialise the ARP cache. */
  91   1              point = MAC_GetMacAddr();
  92   1              TCPIP_SetMacAddr(point);
  93   1      
  94   1              TCPIP_AssignLowlayerXmitFunc(ETH_Send);
  95   1      
  96   1              /* PPPoE initiation */
  97   1              PPPOE_Init();
  98   1      
  99   1      } /* End of ETH_Init */
 100          
 101          /*
 102           * ----------------------------------------------------------------------------
 103           * Function Name: ETH_Start
 104           * Purpose:
 105           * Params:
 106           * Returns:
 107           * Note:
 108           * ----------------------------------------------------------------------------
 109           */
 110          void ETH_Start(void)
 111          {
 112   1              STOE_Start();
C51 COMPILER V9.00   ADAPTER                                                               05/08/2013 16:47:34 PAGE 3   

 113   1      
 114   1      } /* End of ETH_Start */
 115          
 116          /*
 117           * ----------------------------------------------------------------------------
 118           * Function Name: eth_RcvHandle
 119           * Purpose:
 120           * Params:
 121           * Returns:
 122           * Note:
 123           * ----------------------------------------------------------------------------
 124           */
 125          void eth_RcvHandle(U8_T XDATA* pbuf, U16_T length, U8_T protocol)
 126          {
 127   1              /* copy packet into uIP buffer */
 128   1              DMA_GrantXdata(TCPIP_GetRcvBuffer(), pbuf, length);
 129   1      
 130   1              TCPIP_SetRcvLength(length);
 131   1      
 132   1      #if (STOE_TRANSPARENT == STOE_NON_TRANSPARENT_MODE)
 133   1              if (protocol == 0xff)
 134   1              {
 135   2                      if ((*pbuf > 0x44) && (*pbuf < 0x50))
 136   2                      {
 137   3                              protocol = *(pbuf + 9);
 138   3                              PBDP->STOE_RxInform.Protocol = protocol;
 139   3                      }
 140   2              }
 141   1      #endif
 142   1      
 143   1              switch (protocol)
 144   1              {
 145   2              default:
 146   2                      break;
 147   2              case 1:
 148   2              case 2:
 149   2              case 6:
 150   2              case 17:
 151   2      #if STOE_TRANSPARENT
                              if (ETH_IsPppoe)
                              {
                                      if (!PPPOE_Receive(TCPIP_GetRcvBuffer(), length))
                                              return;
                              }
                              else if (ETH_DoDhcp == 0)
                                      uip_arp_ipin();
              #endif
 160   2                      TCPIP_Receive();
 161   2                      if(TCPIP_GetXmitLength() > 0)
 162   2                      {
 163   3      #if STOE_TRANSPARENT
                                      if (!ETH_IsPppoe)
                                              uip_arp_out();
              #endif
 167   3                              ETH_Send(0);
 168   3                      }
 169   2                      break;
 170   2              case 0xff:
 171   2      #if STOE_TRANSPARENT
                              if (ETH_IsPppoe)
                              {
                                      if (!PPPOE_Receive(TCPIP_GetRcvBuffer(), length))
C51 COMPILER V9.00   ADAPTER                                                               05/08/2013 16:47:34 PAGE 4   

                                              return;
                              }
                              else
                              {
                                      if(pbuf[12] == 0x08 && pbuf[13] == 0x06)
                                      {
                                              uip_arp_arpin();
                                  if(TCPIP_GetXmitLength() > 0)
                                                      ETH_Send(0);
                                      }
                              }
              #else
 187   2                      // receive a arp reply packet, check the ip.
 188   2                      // If this ip is the gateway's ip, update the hardware arp table,
 189   2                      // and set it static
 190   2                      if(pbuf[12] == 0x08 && pbuf[13] == 0x06 && pbuf[21] == 0x02)
 191   2                      {
 192   3                              if (eth_CheckGatewayIp(pbuf))
 193   3                              {
 194   4                                      if (STOE_AddArpTable(&pbuf[6], *(U32_T *)&pbuf[28], 1))
 195   4                                      {
 196   5                                              eth_GatewayArpStaticFlag = TRUE;
 197   5                                              eth_ArpSendIntervalTime = ETH_ARP_SEND_INTERVAL_TIME;
 198   5                                      }
 199   4                              }
 200   3                      }
 201   2      #endif
 202   2                      break;
 203   2              }  /* End of switch */
 204   1      
 205   1      } /* End of eth_RcvHandle */
 206          
 207          /*
 208          * -----------------------------------------------------------------------------
 209           * Function Name: ETH_Send
 210           * Purpose: Copy Data to Mac ram and send to Ethernet.
 211           * Params: 
 212           * Returns: none
 213           * Note:
 214           * ----------------------------------------------------------------------------
 215           */
 216          void ETH_Send(U16_T     payloadOffset)
 217          {
 218   1              U16_T   length = TCPIP_GetXmitLength();
 219   1      
 220   1              eth_PayLoadOffset = payloadOffset;
 221   1      
 222   1      #if STOE_TRANSPARENT
                      if (ETH_IsPppoe)
                      {
                              length += (eth_EthHeadLen + ETH_PppoeHeaderLen);
                              if (!PPPOE_GetState())
                                      return;
              
                              PPPOE_Send (TCPIP_GetXmitBuffer(), length);
                      }
              #endif
 232   1      
 233   1              ETH_SendPkt(TCPIP_GetXmitBuffer(), length);
 234   1                      
 235   1      } /* End of ETH_Send() */
 236          
C51 COMPILER V9.00   ADAPTER                                                               05/08/2013 16:47:34 PAGE 5   

 237          /*
 238          * -----------------------------------------------------------------------------
 239           * Function Name: ETH_SendPkt
 240           * Purpose: Copy Data to Mac ram and send to Ethernet.
 241           * Params: none
 242           * Returns: none
 243           * Note:
 244           * ----------------------------------------------------------------------------
 245           */
 246          void ETH_SendPkt(U8_T XDATA* psour, U16_T length)
 247          {
 248   1              U8_T XDATA* pBuf;
 249   1              U8_T XDATA* point;
 250   1              U16_T           len;
 251   1              U16_T           addr;
 252   1              U8_T            isPppoeIp = 0;
 253   1              U16_T           totalLen = length;
 254   1      
 255   1              if (!PBDP->MacInfo.LinkSpeed)
 256   1                      return;
 257   1              pBuf = STOE_AssignSendBuf(length + MAC_TX_RX_HEADER);
 258   1              if (!pBuf)
 259   1                      return;
 260   1              point = pBuf + MAC_TX_RX_HEADER;
 261   1      
 262   1      #if STOE_TRANSPARENT
                      if (ETH_IsPppoe)
                      {
                              if ((*(psour + 12) == 0x88) && (*(psour + 13) == 0x64) && (*(psour + 20) == 0) && (*(psour + 21) == 0x21
             -))
                              {
                                      isPppoeIp = 1;
                                      PBDP->STOE_TxInform.Protocol = *(psour + 31);
                              }
                              else
                              {
                                      eth_PayLoadOffset = length;
                                      PBDP->STOE_TxInform.Protocol = 0xff;
                              }
                      }
                      else
              #endif
 278   1              {
 279   2      #if STOE_TRANSPARENT
                              if ((*(psour + 12) == 8) && (*(psour + 13) == 0))
                                      PBDP->STOE_TxInform.Protocol = *(psour + 23);
                              else
                                      PBDP->STOE_TxInform.Protocol = 0xff;
              #else
 285   2                      if (*psour == 0x45)
 286   2                              PBDP->STOE_TxInform.Protocol = *(psour + 9);
 287   2                      else
 288   2                              PBDP->STOE_TxInform.Protocol = 0xff;
 289   2      #endif
 290   2              }
 291   1      
 292   1              if (pBuf)
 293   1              {
 294   2                      if (eth_PayLoadOffset)
 295   2                              len = eth_PayLoadOffset;
 296   2                      else
 297   2                      {
C51 COMPILER V9.00   ADAPTER                                                               05/08/2013 16:47:34 PAGE 6   

 298   3      #if STOE_TRANSPARENT
                                      if (ETH_IsPppoe)
                                              len = 48 + eth_EthHeadLen;
                                      else
              #endif
 303   3                                      len = 40 + eth_EthHeadLen;
 304   3                      }
 305   2      
 306   2                      if (length > len)
 307   2                      {
 308   3                              /* Do software DMA */
 309   3                              DMA_GrantXdata(point, TCPIP_GetXmitBuffer(), len);
 310   3      
 311   3                              point += len;
 312   3                              length -= len;
 313   3      
 314   3                              addr = (U32_T)(TCPIP_GetPayloadBuffer()) >> 8;
 315   3      
 316   3                              if(addr > 0x8000)       /*if(flag_dataincode)*/
 317   3                                      STOE_CopyCode2TPBR(point, TCPIP_GetPayloadBuffer(), length);
 318   3                              else if (addr >= 0x100)
 319   3                                      DMA_Grant(point, TCPIP_GetPayloadBuffer(), length);
 320   3                              else
 321   3                                      DMA_GrantXdata(point, TCPIP_GetPayloadBuffer(), length);
 322   3                      }
 323   2                      else
 324   2                      {
 325   3                              /* Do software DMA */
 326   3                              DMA_GrantXdata(point, TCPIP_GetXmitBuffer(), len);
 327   3      
 328   3                      } /* End of if (length > len) */
 329   2      
 330   2                      if (isPppoeIp)
 331   2                              pBuf[5] = 0x80;
 332   2                      else
 333   2                              pBuf[5] = 0;
 334   2                      STOE_Send(pBuf, totalLen, PBDP->STOE_TxInform.Protocol);
 335   2              }
 336   1      
 337   1              eth_PayLoadOffset = 0; /* clear offset flag */
 338   1      
 339   1      } /* End of ETH_SendPkt() */
 340          
 341          #if (!STOE_TRANSPARENT)
 342          /*
 343          * -----------------------------------------------------------------------------
 344           * Function Name: eth_CheckGatewayIp
 345           * Purpose: Copy Data to Mac ram and send to Ethernet.
 346           * Params: none
 347           * Returns: none
 348           * Note:
 349           * ----------------------------------------------------------------------------
 350           */
 351          BOOL eth_CheckGatewayIp(U8_T XDATA* pBuf)
 352          {
 353   1              U32_T   gatewayIp, receiveIp;
 354   1      
 355   1              gatewayIp = STOE_GetGateway();
 356   1              if (!gatewayIp)
 357   1              {
 358   2                      return FALSE;
 359   2              }
C51 COMPILER V9.00   ADAPTER                                                               05/08/2013 16:47:34 PAGE 7   

 360   1      
 361   1              receiveIp = *(U32_T *)&pBuf[28];
 362   1              if (gatewayIp != receiveIp)
 363   1              {
 364   2                      return FALSE;
 365   2              }
 366   1      
 367   1              return TRUE;
 368   1      }
 369          
 370          /*
 371          * -----------------------------------------------------------------------------
 372           * Function Name: ETH_SendArpToGateway
 373           * Purpose: send arp request to gateway
 374           * Params: none
 375           * Returns: none
 376           * Note:
 377           * ----------------------------------------------------------------------------
 378           */
 379          void ETH_SendArpToGateway(BOOL StopSendAfterRcvReply)
 380          {
 381   1              U32_T   gateway, ip, TempTime;
 382   1              U8_T    *buf = uip_buf;
 383   1              U8_T*   point;
 384   1      
 385   1              if (StopSendAfterRcvReply)
 386   1              {
 387   2                      if (eth_GatewayArpStaticFlag)
 388   2                              return;
 389   2              }
 390   1      
 391   1              // first check stoe gateway setting
 392   1              gateway = STOE_GetGateway();
 393   1              if (!gateway)
 394   1                      return;
 395   1      
 396   1              // check stoe source ip setting
 397   1              ip = STOE_GetIPAddr();
 398   1              if (!ip)
 399   1                      return;
 400   1      
 401   1              // check is it time to send arp request
 402   1              TempTime = SWTIMER_Tick();
 403   1              if ((TempTime - eth_ArpSendTime) < (eth_ArpSendIntervalTime * SWTIMER_COUNT_SECOND))
 404   1                      return;
 405   1      
 406   1              // update time
 407   1              eth_ArpSendTime = TempTime;
 408   1      
 409   1              switch(eth_ArpSendIntervalTime)
 410   1              {
 411   2                      case 5:
 412   2                              eth_ArpSendIntervalTime = 10;
 413   2                              break;
 414   2                      case 10:
 415   2                              eth_ArpSendIntervalTime = 15;
 416   2                              break;
 417   2                      case 15:
 418   2                              eth_ArpSendIntervalTime = 30;
 419   2                              break;
 420   2                      case 30:
 421   2                              eth_ArpSendIntervalTime = 60;
C51 COMPILER V9.00   ADAPTER                                                               05/08/2013 16:47:34 PAGE 8   

 422   2                              break;
 423   2                      case 60:
 424   2                              eth_ArpSendIntervalTime = 120;
 425   2                              break;
 426   2                      case 120:
 427   2                              eth_ArpSendIntervalTime = 180;
 428   2                              break;
 429   2                      case 180:
 430   2                      case 300:
 431   2                      default:
 432   2                              eth_ArpSendIntervalTime = ETH_ARP_SEND_INTERVAL_TIME;
 433   2                              break;
 434   2              }
 435   1      
 436   1              // send arp request to gateway,
 437   1              // in order to get gateway MAC address.
 438   1              point = MAC_GetMacAddr();
 439   1              uip_len = 42;
 440   1      
 441   1              buf[0] = 0xFF;
 442   1              buf[1] = 0xFF;
 443   1              buf[2] = 0xFF;
 444   1              buf[3] = 0xFF;
 445   1              buf[4] = 0xFF;
 446   1              buf[5] = 0xFF;
 447   1              buf[6] = *(point);        Mac_Addr[0] = buf[6];
 448   1              buf[7] = *(point + 1);   Mac_Addr[1] = buf[7];
 449   1              buf[8] = *(point + 2);    Mac_Addr[2] = buf[8];
 450   1              buf[9] = *(point + 3);    Mac_Addr[3] = buf[9];
 451   1              buf[10] = *(point + 4);    Mac_Addr[4] = buf[10];
 452   1              buf[11] = *(point + 5);   Mac_Addr[5] = buf[11];
 453   1              buf[12] = 0x08; 
 454   1              buf[13] = 0x06;
 455   1      
 456   1              buf[14] = 0x00;
 457   1              buf[15] = 0x01;
 458   1              buf[16] = 0x08;
 459   1              buf[17] = 0x00;
 460   1              buf[18] = 0x06;
 461   1              buf[19] = 0x04;
 462   1              buf[20] = 0x00;
 463   1              buf[21] = 0x01;
 464   1      
 465   1              buf[22] = *(point);
 466   1              buf[23] = *(point + 1);
 467   1              buf[24] = *(point + 2);
 468   1              buf[25] = *(point + 3);
 469   1              buf[26] = *(point + 4);
 470   1              buf[27] = *(point + 5);
 471   1              *(U32_T *)&buf[28] = STOE_GetIPAddr();
 472   1              
 473   1              buf[32] = 0x00;
 474   1              buf[33] = 0x00;
 475   1              buf[34] = 0x00;
 476   1              buf[35] = 0x00;
 477   1              buf[36] = 0x00;
 478   1              buf[37] = 0x00;
 479   1              *(U32_T *)&buf[38] = gateway;
 480   1      
 481   1              ETH_Send(0);
 482   1      
 483   1              return;
C51 COMPILER V9.00   ADAPTER                                                               05/08/2013 16:47:34 PAGE 9   

 484   1      }
 485          
 486          /*
 487          * -----------------------------------------------------------------------------
 488           * Function Name: ETH_RestartSendArpToGateway
 489           * Purpose: Restart sending arp request to gateway
 490           * Params: none
 491           * Returns: none
 492           * Note:
 493           * ----------------------------------------------------------------------------
 494           */
 495          void ETH_RestartSendArpToGateway(void)
 496          {
 497   1              eth_GatewayArpStaticFlag = FALSE;
 498   1              eth_ArpSendIntervalTime = 5;
 499   1      }
 500          #endif
 501          
 502          /* End of adapter.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2840    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     16      38
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
