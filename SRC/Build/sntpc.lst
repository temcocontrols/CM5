C51 COMPILER V9.00   SNTPC                                                                 05/08/2013 16:47:36 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SNTPC
OBJECT MODULE PLACED IN .\Build\sntpc.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SNTP\sntpc.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\Fr
                    -eeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\SRC\UAR
                    -T\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;..\SRC
                    -\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management\;..\S
                    -RC\dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule;..\SRC\program;..\SRC\Scan) DE
                    -FINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\sntpc.lst) OBJECT(.\Build\sntpc.obj)

line level    source

   1          /*
   2          *********************************************************************************
   3          *     Copyright (c) 2006   ASIX Electronic Corporation      All rights reserved.
   4          *
   5          *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6          *
   7          *     The copyright notice above does not evidence any actual or intended
   8          *
   9          *     publication of such source code.
  10          *********************************************************************************
  11          
  12          
  13          /* INCLUDE FILE DECLARATIONS */
  14          #include "adapter.h"
  15          
  16          #if 1
  17          #include "sntpc.h"
  18          #include "tcpip.h"
  19          #include "uart.h"
  20          #include "mstimer.h"
  21          //#include "printd.h"
  22          #include <stdio.h>
  23          #include "../modbus/define.h"
  24          
  25          /* NAMING CONSTANT DECLARATIONS */
  26          
  27          /* GLOBAL VARIABLES DECLARATIONS */
  28          
  29          /* LOCAL VARIABLES DECLARATIONS */
  30          static TimeInfo t;
  31          static SNTPHeader *psntpcpMsg;
  32          static U16_T timetickinfo;
  33          static S16_T GMT;
  34          static U8_T     Month[12] = {31,28,31,30,31,30,31,31,30,31,30,31};
  35          static U8_T     AddMonth[12] = {31,29,31,30,31,30,31,31,30,31,30,31};
  36          static SNTPC_CONN sntpc_Conns;
  37          static U8_T sntpc_InterAppId;
  38          static U8_T     sntp_Buf[48];
  39          static U8_T sntp_Retry = 0;
  40          
  41          
  42          /* LOCAL SUBPROGRAM DECLARATIONS */
  43          
  44          
  45          /*
  46           * ----------------------------------------------------------------------------
  47           * Function Name: SNTPC_Init
  48           * Purpose: to initial the SNTP client connection information.
  49           * Params:
  50           * Returns:
C51 COMPILER V9.00   SNTPC                                                                 05/08/2013 16:47:36 PAGE 2   

  51           * Note:
  52           * ----------------------------------------------------------------------------
  53           */
  54          void SNTPC_Init(void)
  55          {
  56   1              sntpc_Conns.State = SNTP_STATE_INITIAL;
  57   1              sntpc_InterAppId = TCPIP_Bind(NULL, SNTPC_Event, SNTPC_Receive);
  58   1      //      printd("sntp init...\n\r");
  59   1      
  60   1      } /* End of SNTPC_Init() */
  61          
  62          /*
  63           * ----------------------------------------------------------------------------
  64           * Function Name: SNTPC_Event
  65           * Purpose: 
  66           * Params:
  67           * Returns:
  68           * Note:
  69           * ----------------------------------------------------------------------------
  70           */
  71          void SNTPC_Event(U8_T id, U8_T event)
  72          {
  73   1              if (id != 0)
  74   1                      return;
  75   1      
  76   1              if (event == TCPIP_CONNECT_CANCEL)
  77   1              {
  78   2                      TCPIP_UdpClose(sntpc_Conns.UdpSocket);
  79   2                      sntpc_Conns.State = SNTP_STATE_INITIAL;
  80   2              }
  81   1      
  82   1      } /* End of SNTPC_Event() */
  83          
  84          /*
  85           * ----------------------------------------------------------------------------
  86           * Function Name: SNTPC_Receive
  87           * Purpose: 
  88           * Params:
  89           * Returns:
  90           * Note:
  91           * ----------------------------------------------------------------------------
  92           */
  93          void SNTPC_Receive(U8_T XDATA* pData, U16_T length, U8_T id)
  94          {
  95   1              U8_T i = 0;
  96   1              S8_T signhour, signmin;
  97   1              U8_T hour, min;
  98   1      
  99   1              if(id != 0)
 100   1                      return;
 101   1              length = length;
 102   1      
 103   1              signhour = GMT / 100;
 104   1              signmin = GMT % 100;
 105   1      
 106   1              t.sntpcPktPtr = (SNTPHeader*)pData;
 107   1              psntpcpMsg = (SNTPHeader*)t.sntpcPktPtr;
 108   1              t.timestamp = psntpcpMsg->receive_time1;
 109   1      
 110   1              if (signhour < 0)
 111   1              {
 112   2                      hour = -signhour;
C51 COMPILER V9.00   SNTPC                                                                 05/08/2013 16:47:36 PAGE 3   

 113   2                      min = -signmin;
 114   2              t.timestamp -= (hour*3600 + min*60);
 115   2              }
 116   1              else
 117   1              {
 118   2                      hour = signhour;
 119   2                      min = signmin;
 120   2                      t.timestamp += (hour*3600 + min*60);
 121   2              }
 122   1      
 123   1              t.second_remain = t.timestamp % 86400;
 124   1              t.day_total = t.timestamp / 86400;
 125   1              t.HH = t.second_remain / 3600;
 126   1              t.MI_r = t.second_remain % 3600;
 127   1              t.MI = t.MI_r / 60;
 128   1              t.SS = t.MI_r % 60;
 129   1              t.YY = t.day_total / 365.2425;
 130   1      
 131   1              if((t.YY % 4) == 0)
 132   1              {       
 133   2                      t.DD_r = t.day_total-(t.YY*365)-(t.YY/4);
 134   2                      t.DD_r++;
 135   2                      t.DD_r++;       
 136   2                      while(t.DD_r>0)
 137   2                      {
 138   3                              t.DD = t.DD_r;
 139   3                              t.DD_r -= AddMonth[i];
 140   3                              i++;
 141   3                      }
 142   2              }
 143   1              else
 144   1              {
 145   2                      t.DD_r = t.day_total-(t.YY*365)-(t.YY/4);
 146   2                      t.DD_r++;
 147   2                      if(t.DD_r>365){
 148   3                              t.DD_r = 1;
 149   3                              t.YY++;
 150   3                      }
 151   2                      while(t.DD_r>0)
 152   2                      {
 153   3                              t.DD = t.DD_r;
 154   3                              t.DD_r -= Month[i];
 155   3                              i++;
 156   3                      }
 157   2              }
 158   1              t.MM = i;
 159   1              t.YY += 1900;
 160   1      
 161   1      //Evan commented.
 162   1      //      Modbus.Time.Clk.century = t.YY / 100;
 163   1      //      Modbus.Time.Clk.year = t.YY % 100;
 164   1      //      Modbus.Time.Clk.mon = t.MM;
 165   1      //      Modbus.Time.Clk.day = t.DD;
 166   1      //      Modbus.Time.Clk.hour = t.HH;
 167   1      //      Modbus.Time.Clk.min = t.MI;
 168   1      //      Modbus.Time.Clk.sec = t.SS;
 169   1      
 170   1      } /* End of SNTPC_Receive() */
 171          
 172          /*
 173           * ----------------------------------------------------------------------------
 174           * Function Name: SNTPC_GetTime
C51 COMPILER V9.00   SNTPC                                                                 05/08/2013 16:47:36 PAGE 4   

 175           * Purpose: 
 176           * Params:
 177           * Returns:
 178           * Note:
 179           * ----------------------------------------------------------------------------
 180           */
 181          U8_T* SNTP_GetTime(void)
 182          {
 183   1              if (sntpc_Conns.State != SNTP_STATE_GET_DONE)
 184   1                      return NULL;
 185   1      
 186   1              sntpc_Conns.State = SNTP_STATE_INITIAL;
 187   1              sprintf (sntp_Buf, "%d/%.2bd/%.2bd %.2bd:%.2bd:%.2bd",
 188   1                      t.YY, t.MM, (U8_T)t.DD, t.HH, t.MI, t.SS);
 189   1              sntp_Buf[20] = 0;
 190   1      
 191   1              return sntp_Buf;
 192   1      
 193   1      } /* End of SNTP_GetTime() */
 194          
 195          /*
 196           * ----------------------------------------------------------------------------
 197           * Function Name: sntpc_Send
 198           * Purpose: 
 199           * Params:
 200           * Returns:
 201           * Note:
 202           * ----------------------------------------------------------------------------
 203           */
 204          void sntpc_Send(U8_T InterUdpId)
 205          {
 206   1              U8_T len = 48;
 207   1              U8_T i;
 208   1      
 209   1              sntp_Buf[0] = 0x0b;
 210   1              for (i = 1; i < len; i++)
 211   1                      sntp_Buf[i] = 0;
 212   1              
 213   1              TCPIP_UdpSend(InterUdpId, 0, 0, sntp_Buf, len);
 214   1      //      printd("sntp send...\n\r");
 215   1      
 216   1      } /* End of sntpc_Send() */
 217          
 218          /*
 219           * ----------------------------------------------------------------------------
 220           * Function Name: SNTPC_Start
 221           * Purpose: 
 222           * Params:
 223           * Returns:
 224           * Note:
 225           * ----------------------------------------------------------------------------
 226           */
 227          U8_T SNTPC_Start(S16_T gmt, U32_T timesrIP)
 228          {
 229   1      /*      if (sntpc_Conns.State != SNTP_STATE_INITIAL)
 230   1                      return SNTP_STATE_NOTREADY;             */
 231   1      
 232   1              sntpc_Conns.ServerIp = timesrIP;
 233   1              GMT = gmt;
 234   1      
 235   1              /* Create SNTP client port */
 236   1              if ((sntpc_Conns.UdpSocket = TCPIP_UdpNew(sntpc_InterAppId, 0, sntpc_Conns.ServerIp,
C51 COMPILER V9.00   SNTPC                                                                 05/08/2013 16:47:36 PAGE 5   

 237   1                      0, SNTP_SERVER_PORT)) == TCPIP_NO_NEW_CONN)
 238   1              {
 239   2      
 240   2      //              printd ("Allocate SNTPC socket port fail.\n\r");
 241   2      
 242   2                      return SNTP_STATE_NOTREADY;
 243   2              }
 244   1      
 245   1              sntpc_Send(sntpc_Conns.UdpSocket);
 246   1              sntpc_Conns.State = SNTP_STATE_WAIT;
 247   1              timetickinfo = (U16_T)SWTIMER_Tick();
 248   1              sntp_Retry = 0;
 249   1      //      printd("sntp start...\n\r");
 250   1              return SNTP_STATE_WAIT;
 251   1      } /* End of SNTPC_Start() */
 252          
 253          /*
 254           * ----------------------------------------------------------------------------
 255           * Function Name: SNTPC_Stop
 256           * Purpose: 
 257           * Params:
 258           * Returns:
 259           * Note:
 260           * ----------------------------------------------------------------------------
 261           */
 262          void SNTPC_Stop(void)
 263          {
 264   1              if (sntpc_Conns.State != SNTP_STATE_INITIAL)
 265   1              {
 266   2                      TCPIP_UdpClose(sntpc_Conns.UdpSocket);
 267   2                      sntpc_Conns.State = SNTP_STATE_INITIAL;
 268   2              }
 269   1      
 270   1      } /* End of SNTPC_Stop() */
 271          
 272          /*
 273           * ----------------------------------------------------------------------------
 274           * Function Name: SNTPC_GetState
 275           * Purpose: 
 276           * Params:SNTPC_Debug(void)
 277           * Returns:
 278           * Note:
 279           * ----------------------------------------------------------------------------
 280           */
 281          U8_T SNTPC_GetState(void)
 282          {
 283   1              if(sntpc_Conns.State == SNTP_STATE_WAIT)
 284   1              {
 285   2                      U16_T   CurTime = (U16_T)SWTIMER_Tick();
 286   2                if(1)
 287   2              //      if ((CurTime - timetickinfo) >= SNTPC_REQUEST_TIMEOUT)//SNTPC_REQUEST_TIMEOUT bigger to 5
 288   2                      {  /** printd ("SNTP >timeout\n\r");
 289   3                              if (++sntp_Retry >= SNTPC_MAX_RETRY)//SNTPC_MAX_RETRY bigger to 6
 290   3                              { printd ("SNTP retry exceed\n\r");
 291   3                                      TCPIP_UdpClose(sntpc_Conns.UdpSocket);
 292   3                                      sntpc_Conns.State = SNTP_STATE_INITIAL;
 293   3      
 294   3                                      return SNTP_STATE_TIMEOUT;
 295   3                              }***/
 296   3                 
 297   3                              sntpc_Send(sntpc_Conns.UdpSocket);
 298   3                 // printd ("SNTP send in while\n\r");
C51 COMPILER V9.00   SNTPC                                                                 05/08/2013 16:47:36 PAGE 6   

 299   3                              timetickinfo = (U16_T)SWTIMER_Tick();
 300   3                  sntp_Retry=0;
 301   3                      }
 302   2           // else
 303   2                 // printd ("SNTP <timeout\n\r");
 304   2              }
 305   1              return sntpc_Conns.State;
 306   1      }
 307          
 308          /* only for debug */
 309          void SNTPC_Debug(void)
 310          {
 311   1      //      printd ("SNTPC Connection state: %bx\n\r", sntpc_Conns.State);
 312   1      }
 313          
 314          
 315          #endif /* #if (INCLUDE_SNTP_CLIENT) */
 316          
 317          
 318          /* End of sntpc.c */
 319          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1428    ----
   CONSTANT SIZE    =     33    ----
   XDATA SIZE       =    114      15
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
