C51 COMPILER V9.00   MAIN                                                                  05/08/2013 16:47:34 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Build\main.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\SRC\main\main.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\
                    -SRC\FreeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\S
                    -RC\UART\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;
                    -..\SRC\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management
                    -\;..\SRC\dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule;..\SRC\program;..\SRC\Sc
                    -an) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\main.lst) OBJECT(.\Build\main.obj)

line level    source

   1          /*
   2           *********************************************************************************
   3           *     Copyright (c) 2005   ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           *********************************************************************************
  10           */
  11          
  12          /* Standard includes. */
  13          
  14          #include "main.h"
  15          
  16          #define Tcpip_STACK_SIZE        ((unsigned portSHORT)1024)
  17          #define Common_STACK_SIZE       ((unsigned portSHORT)1024)
  18          #define Schedule_STACK_SIZE     ((unsigned portSHORT)1024)
  19          #define UpdateAISTACK_SIZE      ((unsigned portSHORT)1024)
  20          #define SampleDISTACK_SIZE      ((unsigned portSHORT)1024)
  21          #define UpdateDISTACK_SIZE      ((unsigned portSHORT)1024)
  22          #define ScanReslut_STACK_SIZE   ((unsigned portSHORT)1024)
  23          
  24          
  25          
  26          
  27          
  28          xTaskHandle xHandleCommon;
  29          xTaskHandle xSoftWatchTask;
  30          xTaskHandle xHandleTcp;
  31          xTaskHandle xHandleSchedule;
  32          xTaskHandle Handle_UpdateAI; 
  33          xTaskHandle Handle_SampleDI;
  34          xTaskHandle Handle_UpdateDI;
  35          xTaskHandle xHandleScanReslut;
  36          
  37          U16_T far Test[50];
  38          U8_T ChangeFlash = 0;
  39          U8_T WriteFlash = 0;
  40          
  41          
  42          /*
  43                  put E2prom data to buffer when start-up 
  44          */
  45          void Read_ALL_Data(void)
  46          {
  47   1              U8_T loop;
  48   1              U8_T  temp[64];
  49   1      
  50   1              /* base infomation */
C51 COMPILER V9.00   MAIN                                                                  05/08/2013 16:47:34 PAGE 2   

  51   1      //      for(loop = 0;loop < 4;loop++)   
  52   1      //      E2prom_Read_Byte(EEP_SERIALNUMBER_LOWORD + loop,& serialNum[loop]);
  53   1      
  54   1      //      E2prom_Read_Byte(EEP_ADDRESS,& address);
  55   1              E2prom_Read_Byte(EEP_BAUDRATE,& baudrate);
  56   1               baudrate = 1;
  57   1              if( baudrate == 0) // 9600
  58   1              {
  59   2                      PCON = 0;
  60   2              }
  61   1              else   // 19200
  62   1              {
  63   2                      PCON |= 0xc0;
  64   2              }
  65   1              E2prom_Read_Byte(EEP_UPDTE_STATUS,& update_status);
  66   1              E2prom_Read_Byte(EEP_BASE_ADDRESS,& BASE_ADRESS);
  67   1              E2prom_Read_Byte(EEP_TCP_TYPE,& TCP_TYPE);
  68   1      //      TCP_TYPE = 0; // for test 
  69   1              if( TCP_TYPE == 0)  // static ip, read ip address fromm E2prom
  70   1              {
  71   2                      for(loop = 0;loop < 4;loop++)
  72   2                      {
  73   3                              E2prom_Read_Byte(EEP_IP + loop,&IP_Addr[loop]);
  74   3                      //       IP_Addr[loop] = temp[loop];
  75   3              
  76   3                      //      E2prom_Read_Byte(EEP_SUBNET + loop,&SUBNET[loop]);
  77   3                      //       SUBNET[loop] = temp[loop];
  78   3              
  79   3                      }
  80   2                      SUBNET[0] = 255;
  81   2                      SUBNET[1] = 255;
  82   2                      SUBNET[2] = 255;
  83   2                      SUBNET[3] = 0;
  84   2      
  85   2                      GETWAY[0] = 192;
  86   2                      GETWAY[1] = 168;
  87   2                      GETWAY[2] = 0;
  88   2                      GETWAY[3] = 1;
  89   2              }       
  90   1              
  91   1              for(loop = 0;loop < 4;loop++) 
  92   1                      E2prom_Read_Byte(EEP_SERIALNUMBER_LOWORD + loop,&serialNum[loop]);
  93   1      //      Modbus_Data.baudrate = read_eeprom(EEP_BAUDRATE);
  94   1      
  95   1      //      SNWriteflag = 0;//read_eeprom(EEP_SERIALNUMBER_WRITE_FLAG);
  96   1      
  97   1              E2prom_Read_Byte(EEP_UNIT,&unit);
  98   1      
  99   1      
 100   1              for(loop = 0;loop < 10;loop++) 
 101   1              {
 102   2                      E2prom_Read_Byte(EEP_INPUT1_RANGE + loop,&Input_Range[loop]);
 103   2                      if(Input_Range[loop] > 5 || Input_Range[loop] < 0)
 104   2                                      Input_Range[loop] = 0;
 105   2                      E2prom_Read_Byte(EEP_INPUT1_FILTER + loop,&Input_Filter[loop]);
 106   2                      E2prom_Read_Int(EEP_INPUT1_CAL + loop * 2,&Input_CAL[loop]);            
 107   2              }
 108   1              
 109   1              for(loop = 0;loop < 8;loop++) 
 110   1                      E2prom_Read_Byte(EEP_DI_TYPE1 + loop,&DI_Type[loop]);
 111   1      
 112   1              E2prom_Read_Int(EEP_OUTPUT_LOW,&DO_Value);
C51 COMPILER V9.00   MAIN                                                                  05/08/2013 16:47:34 PAGE 3   

 113   1              E2prom_Read_Byte(EEP_SWITCH,&DO_SoftSwitch);
 114   1              E2prom_Read_Byte(EEP_PRIORTITY,&Priority);
 115   1      //      Master = read_eeprom(EEP_MASTER);
 116   1              
 117   1              E2prom_Read_Int(EEP_DI_ENABLE_LOW,&DI_Enable);
 118   1              E2prom_Read_Int(EEP_AI_ENABLE_LOW,&AI_Enable);
 119   1              E2prom_Read_Int(EEP_DINPUT_AM_LOW,&DInputAM);
 120   1              E2prom_Read_Int(EEP_OUTPUT_AM_LOW,&OuputAM);
 121   1              E2prom_Read_Int(EEP_AINPUT_AM_LOW,&AInputAM);
 122   1      
 123   1      
 124   1      //      for(loop = 0;loop < 7;loop++) 
 125   1      //              Modbus_Data.Time.all[loop] = read_eeprom(EEP_SEC + loop);
 126   1              
 127   1              E2prom_Read_Byte(EEP_DAYLIGHT_STATUS,&daylight_flag);
 128   1              if(daylight_flag > 2)
 129   1              {
 130   2                      daylight_enable = 0;
 131   2                      E2prom_Write_Byte(EEP_DAYLIGHT_ENABLE,daylight_enable);
 132   2                      daylight_flag  = 0;
 133   2                      E2prom_Write_Byte(EEP_DAYLIGHT_STATUS,daylight_flag);
 134   2              }
 135   1              else
 136   1              {
 137   2                      E2prom_Read_Byte(EEP_DAYLIGHT_ENABLE,&daylight_enable);
 138   2              }
 139   1      
 140   1              E2prom_Read_Byte(EEP_DIS_TEMP_NUM,&dis_temp_num);
 141   1              if(dis_temp_num > 9)   dis_temp_num = 0;
 142   1              E2prom_Read_Byte(EEP_DIS_TEMP_INTERVAL,&dis_temp_interval);
 143   1              for(loop = 0;loop < 10;loop++)
 144   1              {
 145   2                      E2prom_Read_Byte(EEP_DIS_TEMP_SEQ_FIRST + loop,&dis_temp_seq[loop]);
 146   2                      if(dis_temp_seq[loop] > 9)   dis_temp_num = 0;
 147   2              }
 148   1              
 149   1      }
*** WARNING C280 IN LINE 48 OF ..\SRC\MAIN\MAIN.C: 'temp': unreferenced local variable
 150          
 151          void Read_Info_From_Flash(void)
 152          {
 153   1              
 154   1      
 155   1              Flash_Read_Schedule();
 156   1      
 157   1      }
 158          
 159          
 160          void set_default_parameters(void)
 161          { 
 162   1              U8_T i;
 163   1              E2prom_Write_Byte(EEP_ADDRESS, 254);    
 164   1      //      E2prom_Write_Byte(EEP_PRODUCT_MODEL, 50);       
 165   1      //      E2prom_Write_Byte(EEP_HARDWARE_REV, 4); 
 166   1              E2prom_Write_Byte(EEP_UNIT, 0);
 167   1      //      E2prom_Write_Byte(EEP_SERIALNUMBER_WRITE_FLAG, 0);
 168   1              for(i = 0;i < 8;i++)
 169   1              {       
 170   2                      E2prom_Write_Byte(EEP_SUBADDR1 + i, 0);
 171   2                      E2prom_Write_Byte(EEP_DI_TYPE1 + i, DI_TSTAT);
 172   2              }       
 173   1              for(i = 0;i < 10;i++)
C51 COMPILER V9.00   MAIN                                                                  05/08/2013 16:47:34 PAGE 4   

 174   1              {       
 175   2                      E2prom_Write_Byte(EEP_INPUT1_RANGE + i, 0);
 176   2                      E2prom_Write_Byte(EEP_INPUT1_FILTER + i, 2);
 177   2                      E2prom_Write_Byte(EEP_INPUT1_CAL + 2 * i, 150);  // default value is 150
 178   2                      E2prom_Write_Byte(EEP_INPUT1_CAL + 2 * i + 1, 0);
 179   2              }
 180   1      
 181   1              E2prom_Write_Byte(EEP_OUTPUT_LOW, 0);
 182   1              E2prom_Write_Byte(EEP_OUTPUT_HIGH, 0);
 183   1              E2prom_Write_Byte(EEP_SWITCH, 0);
 184   1              E2prom_Write_Byte(EEP_PRIORTITY, 0);
 185   1      
 186   1              E2prom_Write_Byte(EEP_DI_ENABLE_LOW, 0);
 187   1              E2prom_Write_Byte(EEP_DI_ENABLE_HIGH, 0);
 188   1              E2prom_Write_Byte(EEP_AI_ENABLE_LOW, 0);
 189   1              E2prom_Write_Byte(EEP_AI_ENABLE_HIGH, 0);
 190   1              E2prom_Write_Byte(EEP_DINPUT_AM_LOW, 0);
 191   1              E2prom_Write_Byte(EEP_DINPUT_AM_HIGH, 0);
 192   1              E2prom_Write_Byte(EEP_OUTPUT_AM_LOW, 0);
 193   1              E2prom_Write_Byte(EEP_OUTPUT_AM_HIGH, 0);
 194   1              E2prom_Write_Byte(EEP_AINPUT_AM_LOW, 0);
 195   1              E2prom_Write_Byte(EEP_AINPUT_AM_HIGH, 0);
 196   1      
 197   1      //      E2prom_Write_Byte(EEP_FIRST_TIME, 0xaa);
 198   1              E2prom_Write_Byte(EEP_TCP_TYPE,0);
 199   1      
 200   1              E2prom_Write_Byte(EEP_IP, 192);
 201   1              E2prom_Write_Byte(EEP_IP + 1, 168);
 202   1              E2prom_Write_Byte(EEP_IP + 2, 0);
 203   1              E2prom_Write_Byte(EEP_IP + 3, 178);
 204   1      
 205   1              E2prom_Write_Byte(EEP_SUBNET, 255);
 206   1              E2prom_Write_Byte(EEP_SUBNET + 1, 255);
 207   1              E2prom_Write_Byte(EEP_SUBNET + 2, 255);
 208   1              E2prom_Write_Byte(EEP_SUBNET + 3, 0);
 209   1              
 210   1              E2prom_Write_Byte(EEP_DIS_TEMP_NUM,1);
 211   1              E2prom_Write_Byte(EEP_DIS_TEMP_INTERVAL,5);
 212   1              for(i = 0;i < 8;i++)
 213   1                      E2prom_Write_Byte(EEP_DIS_TEMP_SEQ_FIRST + i,0); 
 214   1      
 215   1              memset(WR_Roution,'\0',sizeof(STR_WR) * MAX_WR);
 216   1              memset(AR_Roution,'\0',sizeof(STR_AR) * MAX_AR);
 217   1              memset(ID_Config,'\0',sizeof(UN_ID) * MAX_ID);
 218   1      
 219   1              memset(menu_name,'\0',MAX_NAME * NAME_SIZE);    // 10 output 26 input
 220   1        
 221   1               // for test
 222   1      //       for(i = 0;i < 36;i++)
 223   1      //              memcpy(menu_name[i],"         ",NAME_SIZE);
 224   1      //      IntFlashErase(ERA_RUN,0x70000); 
 225   1              Flash_Write_Schedule();
 226   1      
 227   1      
 228   1      }
 229          
 230          
 231          void Output_Count_Priority_Task(void);
 232          
 233          void Common_task(void) reentrant
 234          {
 235   1              static U8_T count = 0;
C51 COMPILER V9.00   MAIN                                                                  05/08/2013 16:47:34 PAGE 5   

 236   1      //      static U8_T relay_value = 0;
 237   1              static U16_T refresh_flash_timer = 0;
 238   1              portTickType xDelayPeriod = ( portTickType ) 200 / portTICK_RATE_MS;
 239   1              for (;;)
 240   1              {
 241   2                      vTaskDelay(xDelayPeriod);
 242   2                      Test[2]++;
 243   2              //      count++;
 244   2              /*{
 245   2                      Test[2]++;
 246   2              //      Flash_Write_Schedule();
 247   2              //      Lcd_Show_Data(3,15,Test[2],0,1);
 248   2                      }
 249   2                      else
 250   2      
 251   2                      {
 252   2                              Test[2] = 0;
 253   2                      //      Lcd_Initial();  
 254   2                      }  */
 255   2               //   P0 = ~P0;
 256   2               //     control_logic();
 257   2                      Updata_Clock(); 
 258   2                      Output_Count_Priority_Task();
 259   2              
 260   2      
 261   2                      if(ChangeFlash == 1)
 262   2                      {  
 263   3                              ChangeFlash = 0;
 264   3                              refresh_flash_timer = 25;                       
 265   3                      }
 266   2      
 267   2                      if(refresh_flash_timer)
 268   2                      {
 269   3                              refresh_flash_timer--;
 270   3                              if(refresh_flash_timer == 0)
 271   3                              {
 272   4                                      WriteFlash = 1;
 273   4                                      Flash_Write_Schedule();
 274   4                                      WriteFlash = 0;
 275   4                              }
 276   3                      }
 277   2      
 278   2              
 279   2              }
 280   1      }
*** WARNING C280 IN LINE 235 OF ..\SRC\MAIN\MAIN.C: 'count': unreferenced local variable
 281          
 282          
 283          
 284          
 285          void watchdog(void)
 286          {
 287   1              /*software watchdog */
 288   1              #if AX_WATCHDOG_ENB
                              TA = 0xAA;
                              TA = 0x55;
                              RWT=1;
                      #endif
 293   1      }
 294          
 295          
 296          
C51 COMPILER V9.00   MAIN                                                                  05/08/2013 16:47:34 PAGE 6   

 297          
 298          
 299          void SoftwareWatchdog_task(void) reentrant
 300          {       
 301   1              portTickType xDelayPeriod = ( portTickType ) 100 / portTICK_RATE_MS;
 302   1              for (;;)
 303   1              {
 304   2                      vTaskDelay(xDelayPeriod);
 305   2                      /* clear watch dog */
 306   2                      watchdog();
 307   2              }
 308   1      }
 309          
 310          
 311          
 312          
 313          void Read_ALL_Data(void);
 314          void vStartDisplayTasks(U8_T uxPriority);
 315          void Display_Initial_Data(void);
 316          
 317          
 318          void main( void )
 319          {
 320   1              U8_T                regisp;
 321   1              U8_T loop;
 322   1              U8_T flag_store_schedule;
 323   1      
 324   1      
 325   1              AX11000_Init();
 326   1      
 327   1              #if (RUNTIME_CODE_START_ADDRESS == RUNTIME_CODE_START_AT_24kH)
 328   1                      ExecuteRuntimeFlag = 1;
 329   1              #else
                              ExecuteRuntimeFlag = 0;
                      #endif
 332   1      
 333   1      #if AX_WATCHDOG_ENB
                      AX11000_WatchDogSetting(0, 1, 0, WD_INTERVAL_67M);  /* time out, reset cpu */
                      sTaskCreate(SoftwareWatchdog_task, (const signed portCHAR * const)"softwatch_task",portMINIMAL_STACK_SIZE
             -, NULL, tskIDLE_PRIORITY + 5 , (xTaskHandle *)&xSoftWatchTask);
              #endif
 337   1              for(loop = 0;loop < 50;loop++)
 338   1                      Test[loop] = 0;
 339   1      
 340   1              DELAY_Init();
 341   1              UART_Init(0);
 342   1              UART_Init(1);
 343   1              Key_Inital();
 344   1              Lcd_Initial();
 345   1      //      Test_program();
 346   1              Display_Initial_Data(); 
 347   1              E2prom_Initial();
 348   1              initSerial();
 349   1              Flash_Inital();
 350   1              
 351   1              Comm_Tstat_Initial_Data();
 352   1              calculate_ID_table();           
 353   1      
 354   1              // read pic version
 355   1      
 356   1              loop = 0;
 357   1      
C51 COMPILER V9.00   MAIN                                                                  05/08/2013 16:47:34 PAGE 7   

 358   1      #if (RUNTIME_CODE_START_ADDRESS == RUNTIME_CODE_START_AT_24kH)
 359   1      
 360   1              IntFlashReadByte(0x60001,&regisp);
 361   1              IntFlashReadByte(0x6ffff,& IspVer);
 362   1              if(regisp == 0xff && regisp != 0xaa)
 363   1              { /* initial defautl parameters*/
 364   2              //      Eeprom_Write_Cpu_Config();
 365   2                      set_default_parameters();
 366   2                      regisp = 0xaa;
 367   2                      IntFlashWriteByte(0x60001,regisp);               
 368   2              }
 369   1      #endif
 370   1              IntFlashReadByte(0x7fff0, &flag_store_schedule);
 371   1              if(flag_store_schedule == 0x55) 
 372   1              {
 373   2                      //Flash_Read_Schedule(); // read scheduel data from flash
 374   2                      Read_Info_From_Flash();
 375   2              }
 376   1              Read_ALL_Data(); 
 377   1              initial_input_value();
 378   1      
 379   1              sTaskCreate(TCPIP_Task,"TCPIP_task",Tcpip_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, (xTaskHandle *)&xHandle
             -Tcp);
 380   1              sTaskCreate(Schedule_task,"schedule_task",Schedule_STACK_SIZE, NULL, tskIDLE_PRIORITY + 2, (xTaskHandle *
             -)&xHandleSchedule);
 381   1              sTaskCreate(Common_task,"Common_task",Common_STACK_SIZE, NULL, tskIDLE_PRIORITY + 3, (xTaskHandle *)&xHan
             -dleCommon);
 382   1              
 383   1              vStartCommSubTasks(tskIDLE_PRIORITY + 8);
 384   1      //      vStartSubSerialTasks(tskIDLE_PRIORITY + 12);
 385   1      //      sTaskCreate( Update_AI_Task, "UpdateAItask", UpdateAISTACK_SIZE, NULL, tskIDLE_PRIORITY + 6, &Handle_Up
             -dateAI );
 386   1              sTaskCreate( Sampel_DI_Task, "SampleDItask", SampleDISTACK_SIZE, NULL, tskIDLE_PRIORITY + 5, &Handle_Samp
             -leDI );
 387   1              sTaskCreate( Update_DI_Task, "UpdateDItask", UpdateDISTACK_SIZE, NULL, tskIDLE_PRIORITY + 7, &Handle_Upda
             -teDI );
 388   1              vStartUpdateOutputTasks(tskIDLE_PRIORITY + 4); 
 389   1              vStartDisplayTasks(tskIDLE_PRIORITY + 9);        
 390   1              vStartKeyTasks(tskIDLE_PRIORITY + 11);
 391   1              vStartMainSerialTasks(tskIDLE_PRIORITY + 13);       
 392   1              
 393   1              /* Finally kick off the scheduler.  This function should never return. */
 394   1              vTaskStartScheduler( portUSE_PREEMPTION );
 395   1      
 396   1              /* Should never reach here now under control of the scheduler. */
 397   1      
 398   1      }
 399          /*-----------------------------------------------------------*/
 400          
 401          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2078    ----
   CONSTANT SIZE    =     63    ----
   XDATA SIZE       =     29      69
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =    100    ----
C51 COMPILER V9.00   MAIN                                                                  05/08/2013 16:47:34 PAGE 8   

   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
