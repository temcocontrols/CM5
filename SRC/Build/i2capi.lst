C51 COMPILER V9.00   I2CAPI                                                                05/08/2013 16:47:35 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE I2CAPI
OBJECT MODULE PLACED IN .\Build\i2capi.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE I2C\i2capi.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\Fr
                    -eeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\SRC\UAR
                    -T\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;..\SRC
                    -\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management\;..\S
                    -RC\dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule;..\SRC\program;..\SRC\Scan) DE
                    -FINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\i2capi.lst) OBJECT(.\Build\i2capi.obj)

line level    source

   1          /*
   2           *********************************************************************************
   3           *     Copyright (c) 2005       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           *********************************************************************************
  10           */
  11          /*================================================================================
  12           * Module Name : i2capi.c
  13           * Purpose     : API functions invovle I2C driver functions.
  14           *               To transmit and to reveive packet by these functions.
  15           * Author      : Robin Lee
  16           * Date        : 2006-01-10
  17           * Notes       :
  18           * $Log: i2capi.c,v $
  19           * Revision 1.0  2009-01-05 14:03:32+08  wong
  20           * Initial revision
  21           *
  22           * Revision 1.1  2006/04/07 11:38:34  robin6633
  23           * no message
  24           *
  25           *================================================================================
  26           */
  27          
  28          /* INCLUDE FILE DECLARATIONS */
  29          #include        <stdio.h>
  30          #include        "reg80390.h"
  31          #include        "types.h"
  32          #include        "buffer.h"
  33          #include        "i2c.h"
  34          #include        "i2capi.h"
  35          
  36          
  37          /* STATIC VARIABLE DECLARATIONS */
  38          
  39          
  40          /* LOCAL SUBPROGRAM DECLARATIONS */
  41          
  42          
  43          /* LOCAL SUBPROGRAM BODIES */
  44          
  45          
  46          /* EXPORTED SUBPROGRAM BODIES */
  47          
  48          /*
  49           *--------------------------------------------------------------------------------
  50           * BOOL I2C_ByteWrite(U16_T addrOfDev, U16_T addrOfMem, U8_T byteData, U8_T endCond)
C51 COMPILER V9.00   I2CAPI                                                                05/08/2013 16:47:35 PAGE 2   

  51           * Purpose : i2c master send a packet for write one data to a device
  52           * Params  : addrOfDev : id address of a device
  53           *           addrOfMem : address for accessing in a device
  54           *           byteData  : data for writing
  55           *           endCond   : packet condition after transmitting
  56           * Returns : TRUE : this accessing is successful
  57           *           FALSE: this accessing is failed
  58           * Note    :
  59           *--------------------------------------------------------------------------------
  60           */
  61          BOOL I2C_ByteWrite(U16_T addrOfDev, U16_T addrOfMem, U8_T byteData, U8_T endCond)
  62          {
  63   1              I2C_BUF         *ptTxPkt = NULL;
  64   1              U8_T            addrMode = 0;
  65   1      
  66   1              /* Get buffer of this packet */
  67   1              ptTxPkt = (I2C_BUF *)GetPktBuf();
  68   1              /* The end condition after transfer complete */
  69   1              ptTxPkt->I2cEnd = endCond;
  70   1              /* Indicate the packet's direction to master transmit */
  71   1              ptTxPkt->I2cDir = I2C_MST_XMIT;
  72   1              /* Data length exclude device address */
  73   1              ptTxPkt->DataLen = 0x02;
  74   1      
  75   1              /* Device Address with 10-bit or 7-bit */
  76   1              I2C_Cmd(SI_RD, I2CCTL, &addrMode);
  77   1              if (addrMode & I2C_10BIT)
  78   1              {
  79   2                      ptTxPkt->I2cAddr.TenBitAddr = (U16_T)(addrOfDev | ((addrOfMem & 0x0700) >> 8));
  80   2              }
  81   1              else
  82   1              {
  83   2                      ptTxPkt->I2cAddr.SevenBitAddr = (U8_T)(addrOfDev | ((addrOfMem & 0x0700) >> 8));
  84   2              }
  85   1              /* Register word Address */
  86   1              ptTxPkt->I2cData[0] = (U8_T)(addrOfMem & 0x00FF);
  87   1              /* Access Data */
  88   1              ptTxPkt->I2cData[1] = byteData;
  89   1      
  90   1              /* To send packet and i2c bus will be busy for this transfer */
  91   1              I2C_FlagEnb(I2C_BUSY);
  92   1              I2C_PktBuf(ptTxPkt);
  93   1              /* Waiting for transfer completely */
  94   1              while (I2C_FlagChk(I2C_BUSY)) {}
  95   1              /* If the packet does not have any ACK echoed, this transfer fail */
  96   1              if (I2C_FlagChk(I2C_NACK))
  97   1              {
  98   2                      I2C_FlagClr(I2C_NACK);
  99   2                      return FALSE;
 100   2              }
 101   1      
 102   1              return TRUE;
 103   1      }
 104          
 105          /*
 106           *--------------------------------------------------------------------------------
 107           * BOOL I2C_PageWrite(U16_T addrOfDev, U16_T addrOfMem, U8_T*ptPageData, U16_T writeLen, U8_T endCond)
 108           * Purpose : i2c master send a packet for writing more data to a device
 109           * Params  : addrOfDev : id address of a device
 110           *           addrOfMem : address for accessing in a device
 111           *           ptPageData: data string for writing
 112           *           writeLen  : data length for transmitting include addrOfMem and data string
C51 COMPILER V9.00   I2CAPI                                                                05/08/2013 16:47:35 PAGE 3   

 113           *           endCond   : packet condition after transmitting
 114           * Returns : TRUE : this accessing is successful
 115           *           FALSE: this accessing is failed
 116           * Note    :
 117           *--------------------------------------------------------------------------------
 118           */
 119          BOOL I2C_PageWrite(U16_T addrOfDev, U16_T addrOfMem, U8_T *ptPageData, U16_T writeLen, U8_T endCond)
 120          {
 121   1              
 122   1              I2C_BUF XDATA   *ptTxPkt = NULL;
 123   1              U16_T                   i;
 124   1              U8_T XDATA              addrMode = 0;
 125   1              
 126   1              /* Get buffer of this packet */
 127   1              ptTxPkt = (I2C_BUF *)GetPktBuf();
 128   1              /* The end condition after transfer complete */
 129   1              ptTxPkt->I2cEnd = endCond;
 130   1              /* Indicate the packet's direction to master transmit */
 131   1              ptTxPkt->I2cDir = I2C_MST_XMIT;
 132   1              /* Data length exclude device address */
 133   1              ptTxPkt->DataLen = writeLen + 1;
 134   1              /* Device Address with 10-bit or 7-bit */
 135   1              I2C_Cmd(SI_RD, I2CCTL, &addrMode);
 136   1              if (addrMode & I2C_10BIT)
 137   1              {
 138   2                      ptTxPkt->I2cAddr.TenBitAddr = (U16_T)(addrOfDev | ((addrOfMem & 0x0700) >> 8));
 139   2              }
 140   1              else
 141   1              {
 142   2                      ptTxPkt->I2cAddr.SevenBitAddr = (U8_T)(addrOfDev | ((addrOfMem & 0x0700) >> 8));
 143   2              }
 144   1              /* Register word Address */
 145   1              ptTxPkt->I2cData[0] = (U8_T)(addrOfMem & 0x00FF);
 146   1              /* Access Data */
 147   1              for (i = 0 ; i < writeLen ; i ++)
 148   1              {
 149   2                      ptTxPkt->I2cData[i + 1] = *(ptPageData + i);
 150   2              }
 151   1              /* To send packet and i2c bus will be busy for this transfer */
 152   1              I2C_FlagEnb(I2C_BUSY);
 153   1              I2C_PktBuf(ptTxPkt);
 154   1              /* Waiting for transfer completely */
 155   1              while (I2C_FlagChk(I2C_BUSY)) {}
 156   1              /* If the packet does not have any ACK echoed, this transfer fail */
 157   1              if (I2C_FlagChk(I2C_NACK))
 158   1              {
 159   2                      I2C_FlagClr(I2C_NACK);
 160   2                      return FALSE;
 161   2              }
 162   1      
 163   1              return TRUE;
 164   1      }
 165          
 166          /*
 167           *--------------------------------------------------------------------------------
 168           * BOOL I2C_RdmRead(U16_T addrOfDev, U16_T addrOfMem ,I2C_BUF *ptPktTemp, U16_T readLen, U8_T endCond)
 169           * Purpose : i2c master send a packet for reading data from a device
 170           * Params  : addrOfDev : id address of a device
 171           *           addrOfMem : address for accessing in a device
 172           *           ptPktTemp : read data buffer pointer
 173           *           readLen   : data length for reading
 174           *           endCond   : packet condition after transfer
C51 COMPILER V9.00   I2CAPI                                                                05/08/2013 16:47:35 PAGE 4   

 175           * Returns : TRUE : this accessing is successful
 176           *           FALSE: this accessing is failed
 177           * Note    :
 178           *--------------------------------------------------------------------------------
 179           */
 180          BOOL I2C_RdmRead(U16_T addrOfDev, U16_T addrOfMem ,I2C_BUF *ptPktTemp, U16_T readLen, U8_T endCond)
 181          {
 182   1              I2C_BUF         *ptRxPkt = NULL;
 183   1              U16_T           i;
 184   1              U8_T            addrMode = 0;
 185   1      
 186   1              /* Get buffer of this packet */
 187   1              ptRxPkt = (I2C_BUF *)GetPktBuf();
 188   1              /* The end condition after transfer complete */
 189   1              ptRxPkt->I2cEnd = I2C_STOP_COND;
 190   1              /* Indicate the packet's direction to master receive */
 191   1              ptRxPkt->I2cDir = I2C_MST_RCVR;
 192   1              /* Data length exclude device address */
 193   1              ptRxPkt->DataLen = readLen;
 194   1              /* Device Address with 10-bit or 7-bit */
 195   1              I2C_Cmd(SI_RD, I2CCTL, &addrMode);
 196   1              if (addrMode & I2C_10BIT)
 197   1              {
 198   2                      ptRxPkt->I2cAddr.TenBitAddr = (U16_T)(addrOfDev | ((addrOfMem & 0x0700) >> 8));
 199   2              }
 200   1              else
 201   1              {
 202   2                      ptRxPkt->I2cAddr.SevenBitAddr = (U8_T)(addrOfDev | ((addrOfMem & 0x0700) >> 8));
 203   2              }
 204   1              /* Send a dummy packet to indicate the internal address of devices */
 205   1              if (endCond & I2C_STOP_COND)
 206   1              {
 207   2                      if (I2C_DummyWrite(addrOfDev, addrOfMem, I2C_STOP_COND))
 208   2                      {
 209   3                              /* To send packet and i2c bus will be busy for this transfer */
 210   3                              I2C_FlagEnb(I2C_BUSY);
 211   3                              I2C_PktBuf(ptRxPkt);
 212   3                              /* Waiting for transfer completely */
 213   3                              while (I2C_FlagChk(I2C_BUSY)) {}
 214   3                              /* If the packet does not have any ACK echoed, this transfer fail */
 215   3                              if (I2C_FlagChk(I2C_NACK))
 216   3                              {
 217   4                                      I2C_FlagClr(I2C_NACK);
 218   4                                      return FALSE;
 219   4                              }
 220   3                              /* Get data received in this transfer */
 221   3                              for (i=0 ; i<=readLen ; i++)
 222   3                              {
 223   4                                      ptPktTemp->I2cData[i] = ptRxPkt->I2cData[i+1];
 224   4                              }
 225   3                              return TRUE;
 226   3                      }
 227   2                      else
 228   2                              return FALSE;
 229   2              }
 230   1              else
 231   1              {
 232   2                      if (I2C_DummyWrite(addrOfDev, addrOfMem, endCond))
 233   2                      {
 234   3                              /* To check the packet has a restart condition for next access */
 235   3                              while (!I2C_FlagChk(I2C_RESTART)) {}
 236   3                              /* To send packet and i2c bus will be busy for this transfer */
C51 COMPILER V9.00   I2CAPI                                                                05/08/2013 16:47:35 PAGE 5   

 237   3                              I2C_FlagClr(I2C_RESTART);
 238   3                              I2C_FlagEnb(I2C_BUSY);
 239   3                              I2C_PktBuf(ptRxPkt);
 240   3                              /* Waiting for transfer completely */
 241   3                              while (I2C_FlagChk(I2C_BUSY)) {}
 242   3                              /* If the packet does not have any ACK echoed, this transfer fail */
 243   3                              if (I2C_FlagChk(I2C_NACK))
 244   3                              {
 245   4                                      I2C_FlagClr(I2C_NACK);
 246   4                                      return FALSE;
 247   4                              }
 248   3                              /* Get data received in this transfer */
 249   3                              for (i=0 ; i<=readLen ; i++)
 250   3                              {
 251   4                                      ptPktTemp->I2cData[i] = ptRxPkt->I2cData[i];
 252   4                              }
 253   3                              return TRUE;
 254   3                      }
 255   2                      else
 256   2                              return FALSE;
 257   2              }
 258   1      }
 259          
 260          /*
 261           *--------------------------------------------------------------------------------
 262           * BOOL I2C_DummyWrite(U16_T addrOfDev, U16_T addrOfMem, U8_T endCond)
 263           * Purpose : i2c master send a dummy packet for accessing a device
 264           * Params  : addrOfDev : id address of a device
 265           *           addrOfMem : address for accessing in a device
 266           *           endCond   : packet condition after transmitting
 267           * Returns : TRUE : this accessing is successful
 268           *           FALSE: this accessing is failed
 269           * Note    : this function only transmit the address of accessing,
 270           *           it does not have any data
 271           *--------------------------------------------------------------------------------
 272           */
 273          BOOL I2C_DummyWrite(U16_T addrOfDev, U16_T addrOfMem, U8_T endCond)
 274          {
 275   1              I2C_BUF         *ptTxPkt = NULL;
 276   1              U8_T            addrMode = 0;
 277   1      
 278   1              /* Get buffer of this packet */
 279   1              ptTxPkt = (I2C_BUF *)GetPktBuf();
 280   1              /* The end condition after transfer complete */
 281   1              ptTxPkt->I2cEnd = endCond;
 282   1              /* Indicate the packet's direction to master transmit */
 283   1              ptTxPkt->I2cDir = I2C_MST_XMIT;
 284   1              /* Data length exclude device address */
 285   1              ptTxPkt->DataLen = 0x01;
 286   1              /* Device Address with 10-bit or 7-bit */
 287   1              I2C_Cmd(SI_RD, I2CCTL, &addrMode);
 288   1              if (addrMode & I2C_10BIT)
 289   1              {
 290   2                      ptTxPkt->I2cAddr.TenBitAddr = (U16_T)(addrOfDev | ((addrOfMem & 0x0700) >> 8));
 291   2              }
 292   1              else
 293   1              {
 294   2                      ptTxPkt->I2cAddr.SevenBitAddr = (U8_T)(addrOfDev | ((addrOfMem & 0x0700) >> 8));
 295   2              }
 296   1              /* Register word Address */
 297   1              ptTxPkt->I2cData[0] = (U8_T)(addrOfMem & 0x00FF);
 298   1              /* No Access Data */
C51 COMPILER V9.00   I2CAPI                                                                05/08/2013 16:47:35 PAGE 6   

 299   1              /* To send packet and i2c bus will be busy for this transfer */
 300   1              I2C_FlagEnb(I2C_BUSY);
 301   1              I2C_FlagClr(I2C_RESTART);
 302   1              I2C_PktBuf(ptTxPkt);
 303   1              /* Waiting for transfer completely */
 304   1              while (I2C_FlagChk(I2C_BUSY)) {}
 305   1              /* If the packet does not have any ACK echoed, this transfer fail */
 306   1              if (I2C_FlagChk(I2C_NACK))
 307   1              {
 308   2                      I2C_FlagClr(I2C_NACK);
 309   2                      return FALSE;
 310   2              }
 311   1      
 312   1              return TRUE;
 313   1      }
 314          
 315          
 316          /* End of i2capi.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1643    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      50
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
