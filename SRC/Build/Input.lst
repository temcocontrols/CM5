C51 COMPILER V9.00   INPUT                                                                 05/08/2013 16:47:37 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE INPUT
OBJECT MODULE PLACED IN .\Build\Input.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Modbus\Input.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\
                    -FreeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\SRC\U
                    -ART\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;..\S
                    -RC\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management\;..
                    -\SRC\dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule;..\SRC\program;..\SRC\Scan) 
                    -DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\Input.lst) OBJECT(.\Build\Input.obj)

line level    source

   1          #include "pic.h"
   2          #include "serial.h"
   3          #include "main.h"
   4          #include <string.h>
   5          
   6          
   7          
   8          
   9          //#define CALIBRATION_OFFSET    128 //allows us to store FLASH_CALIBRATION as an U8_T
  10          
  11          U16_T temperature[10];
  12          signed int xdata old_reading[10];
  13          //S16_T xdata mul_analog_in_buffer[10];
  14          //S16_T xdata mul_analog_filter[10];
  15          
  16          U16_T  look_up_table(U16_T count);
  17          signed int RangeConverter(unsigned char function, signed int para,unsigned char i,unsigned int cal);
  18          
  19          
  20          U8_T data input1[8] = 0;
  21          U8_T data input2[8] = 0;
  22          U8_T xdata count1[8] = 0;
  23          U8_T xdata count2[8] = 0;
  24          U8_T xdata counthigh1[8] = 0;
  25          U8_T xdata counthigh2[8] = 0;   
  26          U8_T data temp1 = 0;
  27          U8_T data temp2 = 0;
  28          
  29          #if 1
  30          
  31          void initial_input_value(void)
  32          {
  33   1              U8_T loop = 0;
  34   1              U8_T count = 0;
  35   1              memset(input1,0,8);
  36   1              memset(input2,0,8);
  37   1              memset(count1,0,8);
  38   1              memset(count2,0,8);
  39   1              memset(counthigh1,0,8);
  40   1              memset(counthigh2,0,8);  
  41   1              memset(old_reading,0,20);  
  42   1              memset(temperature,0,20);
  43   1              // get stable input value power-up
  44   1              while(count < 5)
  45   1              {
  46   2                      if(loop < AI_CHANNEL)
  47   2                      {
  48   3                              
  49   3                              if(read_pic(loop))
  50   3                              {
C51 COMPILER V9.00   INPUT                                                                 05/08/2013 16:47:37 PAGE 2   

  51   4              
  52   4                                      temperature[loop] =     (RangeConverter(1,AI_Value[loop], loop , Input_CAL[loop]));      // range is 1
  53   4                                      
  54   4                                      loop++;
  55   4                              }
  56   3                                      
  57   3                      }       
  58   2                      else 
  59   2                      {
  60   3                              loop = 0; 
  61   3                              count++; 
  62   3                      }
  63   2              } 
  64   1      }
  65          
  66          
  67          
  68          /* per 25ms read 1 channel, 250ms refresh 10 inputs*/
  69          void Update_AI_Task(void)
  70          {
  71   1              portTickType xDelayPeriod = ( portTickType ) 100 / portTICK_RATE_MS;     
  72   1              static U8_T loop = 0;   
  73   1      
  74   1              for( ; ;)
  75   1              {       
  76   2                      Test[4]++;
  77   2                      vTaskDelay(xDelayPeriod);
  78   2                      if( AInputAM & (0x01 << loop) == 0)         // auto 
  79   2                      {
  80   3                              if(loop < AI_CHANNEL)
  81   3                              {
  82   4                                      if(read_pic(loop))
  83   4                                      { 
  84   5                                              temperature[loop] =     (RangeConverter(1,AI_Value[loop], loop , Input_CAL[loop]));      // range is 1                          
  85   5                                              loop++;
  86   5                                      }
  87   4                                              
  88   4                              }       
  89   3                              else loop = 0; 
  90   3                      }
  91   2              }
  92   1      }
  93          
  94          
  95          void Update_AI(void)
  96          {
  97   1              static U8_T loop = 0;   
  98   1      
  99   1              if(loop < AI_CHANNEL)
 100   1              {
 101   2                      //if( AInputAM & (0x01 << loop) == 0)
 102   2                      {
 103   3                              if(read_pic(loop))
 104   3                              { 
 105   4                                      temperature[loop] =     (RangeConverter(1,AI_Value[loop], loop , Input_CAL[loop]));      // range is 1                          
 106   4                                      loop++;
 107   4                              }
 108   3                      }       
 109   2              }       
 110   1              else loop = 0; 
 111   1      }
 112          
C51 COMPILER V9.00   INPUT                                                                 05/08/2013 16:47:37 PAGE 3   

 113          
 114          /*
 115          input voltage is 24AC, if input is 0 and last at least 50ms, it means the input is low.
 116          else it is high.
 117          sampel frequence is 10ms.
 118          */
 119          void Sampel_DI_Task(void)
 120          {
 121   1              portTickType xDelayPeriod = ( portTickType ) 10 / portTICK_RATE_MS;
 122   1              for( ; ;)
 123   1              {       
 124   2                      char loop = 0;
 125   2                      vTaskDelay(xDelayPeriod);
 126   2                      Test[5]++;
 127   2      
 128   2                      if(WriteFlash == 1) 
 129   2                      {                       
 130   3                              continue;
 131   3                      }
 132   2              
 133   2                      DI2_LATCH = 1; KEY_LATCH = 1;RELAY_LATCH = 0;
 134   2                      DI1_LATCH = 0;
 135   2                      temp1 = DI1; 
 136   2                      DI1_LATCH = 1;
 137   2      
 138   2                      for(loop = 0;loop < 8;loop++)           
 139   2                      {
 140   3                              if(DI_Type[loop] == DI_SWITCH)
 141   3                              {
 142   4                                      if(temp1 & (0x01 << loop))
 143   4                                      {
 144   5                                              counthigh1[loop]++;
 145   5                                              if(counthigh1[loop] > 10) // keep high at least 100ms   
 146   5                                              {
 147   6                                                      input1[loop] = 1;
 148   6                                                      count1[loop] = 0;
 149   6                                                      counthigh1[loop] = 0;
 150   6                                              }
 151   5                                      }
 152   4                                      else   // if input is 0, keep low for larger than 50s, it is low.
 153   4                                      {
 154   5                                              if(count1[loop] < 50)  
 155   5                                              {
 156   6                                                      count1[loop]++;
 157   6                                              }
 158   5                                              else            // 30ms
 159   5                                              {                               
 160   6                                                      input1[loop] = 0;
 161   6                                                      count1[loop] = 0;
 162   6                                                      counthigh1[loop] = 0;
 163   6                                              }
 164   5                                      }               
 165   4                              }
 166   3                              else
 167   3                                      input1[loop] = 0;
 168   3                      }
 169   2                      //EA = 0;
 170   2                      DI1_LATCH = 1;  KEY_LATCH = 1;RELAY_LATCH = 0;
 171   2                      DI2_LATCH = 0;
 172   2                      temp2 = DI2; 
 173   2                      DI2_LATCH = 1;
 174   2                      //EA = 1;
C51 COMPILER V9.00   INPUT                                                                 05/08/2013 16:47:37 PAGE 4   

 175   2                      for(loop = 0;loop < 8;loop++)           
 176   2                      {
 177   3                              if(temp2 & (0x01 << loop))
 178   3                              {
 179   4                                      counthigh2[loop]++;
 180   4                                      if(counthigh2[loop] > 10)       
 181   4                                      {
 182   5                                              input2[loop] = 1;
 183   5                                              count2[loop] = 0;
 184   5                                              counthigh2[loop] = 0;
 185   5                                      }
 186   4                              }
 187   3                              else   // if input is 0, keep low for larger than 50s, it is low, otherwise it is still high.
 188   3                              {
 189   4                                      if(count2[loop] < 50)  
 190   4                                      {
 191   5                                              count2[loop]++;
 192   5                                      }
 193   4                                      else            // 50ms
 194   4                                      {                               
 195   5                                              input2[loop] = 0;
 196   5                                              count2[loop] = 0;
 197   5                                              counthigh2[loop] = 0;
 198   5                                      }
 199   4                              }               
 200   3                      }
 201   2              
 202   2              }
 203   1      
 204   1      }
 205          
 206          
 207          void Update_DI_Task(void)
 208          {
 209   1              portTickType xDelayPeriod = ( portTickType ) 100 / portTICK_RATE_MS;
 210   1              for( ; ;)
 211   1              {       
 212   2                      U8_T loop = 0;  
 213   2                      Test[6]++;
 214   2                      vTaskDelay(xDelayPeriod);
 215   2      
 216   2                      for(loop = 0;loop < 8;loop++)
 217   2                      {
 218   3              /* check the input type is AUTO Or Manual */
 219   3                              if(!( DInputAM & (0x01 << loop)))
 220   3                              {
 221   4                                       DI1_Value &= ~(0x01 << loop);
 222   4                                       DI1_Value |= (input1[loop] << loop);
 223   4                              }
 224   3      
 225   3                              if(!( DInputAM & (0x01 << (loop + 8))))
 226   3                              {
 227   4                                       DI2_Value &= ~(0x01 << loop);
 228   4                                       DI2_Value |= (input2[loop] << loop);
 229   4                              }
 230   3                      }
 231   2              } 
 232   1      } 
 233          
 234          
 235          
 236          
C51 COMPILER V9.00   INPUT                                                                 05/08/2013 16:47:37 PAGE 5   

 237          unsigned char const code def_tab[11] =
 238                                  {                                        // 10k termistor GREYSTONE -40 to 120 Deg.C or -40 to 248 Deg.F 
 239                                   192, 209, 206, 187, 161, 131, 103, 79, 61, 45, 155
 240                                  };
 241          //MHF:12-30-05,Added 4 values to make the tstat can measure minus degree
 242          unsigned char const code def_tab_pic[15] =
 243                                  {                                        // 10k termistor GREYSTONE -40 to 120 Deg.C or -40 to 248 Deg.F 
 244                                   56, 41, 61, 83, 102, 113, 112, 101, 85, 67, 51, 38, 28, 21, 65
 245                                  };
 246          
 247          
 248          unsigned int   look_up_table(unsigned int count)
 249          {
 250   1              int   xdata val;
 251   1          char  index=14;
 252   1              int   xdata work_var;
 253   1       
 254   1              if (1/*pic_exists*/)
 255   1                      work_var= def_tab_pic[index];
 256   1              else
 257   1                      work_var= def_tab[index];
 258   1                        
 259   1              if (work_var > count )
 260   1              {
 261   2                      val =  index  * 100 ;
 262   2                      return ( val );
 263   2              }
 264   1      
 265   1              do 
 266   1              {
 267   2                      index--;
 268   2      
 269   2                      if (1/*pic_exists*/)
 270   2                              work_var += def_tab_pic[index];
 271   2                      else
 272   2                              work_var += def_tab[index];
 273   2      
 274   2                      if( work_var > count)
 275   2                              {
 276   3                              val = ( work_var - count )*100;
 277   3      
 278   3                              if (1/*pic_exists*/)
 279   3                                      val /= def_tab_pic[index];
 280   3                              else
 281   3                                      val /= def_tab[index];
 282   3                              if(index >= 4)
 283   3                              {
 284   4                                      val +=  (index - 4) * 100;
 285   4                                      val = val & 0x7fff;
 286   4                              }
 287   3                              else
 288   3                              {
 289   4                                      val += index*100;
 290   4                                      val = 400 - val;
 291   4                                      val = val | 0x8000;
 292   4                              }                        
 293   3                              return (val);
 294   3                              }
 295   2              } while (index) ;
 296   1      
 297   1                      val =  33768;
 298   1      
C51 COMPILER V9.00   INPUT                                                                 05/08/2013 16:47:37 PAGE 6   

 299   1                      return ( val );
 300   1      }
 301          
 302          
 303          
 304          
 305          /******************************************RangeConverter******************************************/
 306          /*
 307          Description: Convert the  raw data from adc to correspond engineer units.
 308          parameter:      finction,       The engineer units want to get,
 309                                  para,           Raw data from ADC
 310                                  i,                      Be used for function = 4,customer sensor,because there are only two 
 311                                                          customer tables,so should check this parameter not bigger than 2 on fun4.
 312                                  cal,            calibration data for the correspond input channel
 313          Return:         Changed input to the expected engineer units.   
 314                                  
 315          */
 316          /*********************************RangeConverter funtion start**************************************/
 317          signed int RangeConverter(unsigned char function, signed int para,unsigned char i,unsigned int cal)
 318          {
 319   1              signed int xdata siAdcResult;
 320   1              unsigned char xdata ucFunction;
 321   1              unsigned char xdata ucI;
 322   1              signed   int  xdata siInput;
 323   1              unsigned int  xdata uiCal;
 324   1              signed   int  xdata siResult;
 325   1              bit bAnalogInputStatus;
 326   1              ucFunction = function;
 327   1              siInput = para;
 328   1              ucI = i;
 329   1              uiCal = cal;
 330   1      
 331   1              if(ucFunction == 0)
 332   1              {
 333   2                      siResult = siInput + uiCal - CALIBRATION_OFFSET;        
 334   2              }        
 335   1              //-----------10K Thermistor---------------
 336   1              else if (ucFunction == 1)
 337   1              {
 338   2       
 339   2                      siAdcResult = look_up_table(siInput);
 340   2       
 341   2                      //MHF:01-02-06,Added minus temperature display
 342   2                      if(siAdcResult & 0x8000)
 343   2                      siResult = -(signed int)(siAdcResult & 0x7fff);
 344   2                      else
 345   2                      siResult = siAdcResult;
 346   2                      //analog_input[i] = adc_result;
 347   2                      
 348   2                      if(unit)  
 349   2                              siResult = (siResult * 9)/5 + 320; 
 350   2      
 351   2                      // Add the calibration term to the input.
 352   2                      siResult = siResult + uiCal - CALIBRATION_OFFSET;
 353   2      
 354   2                              
 355   2              }
 356   1              //-----------0-100%---------------
 357   1              else if(ucFunction == 2)  //MHF: Feb 24th 2005 new range setting for analog inputs
 358   1              {
 359   2                      siResult = (float)(siInput)/1023*100;
 360   2              }
C51 COMPILER V9.00   INPUT                                                                 05/08/2013 16:47:37 PAGE 7   

 361   1              //-----------ON/OFF---------------
 362   1              else if(ucFunction == 3 || ucFunction == 5)
 363   1              {
 364   2                      siAdcResult = (float)(siInput)/1023*50;
 365   2                      if(siAdcResult <= 24)
 366   2                      {
 367   3                              if(ucFunction == 5)
 368   3                                      bAnalogInputStatus = 1; 
 369   3                              else if(ucFunction == 3)
 370   3                                      bAnalogInputStatus = 0; 
 371   3                      }
 372   2                      else if(siAdcResult >= 26)
 373   2                      {
 374   3                              if(ucFunction == 5)
 375   3                                      bAnalogInputStatus = 0; 
 376   3                              else if(ucFunction == 3)
 377   3                                      bAnalogInputStatus = 1; 
 378   3                      }
 379   2                      siResult = (unsigned int)(bAnalogInputStatus);
 380   2                      
 381   2              }
 382   1              //-----------Custom Sensor---------------
 383   1              /*else if(ucFunction == 4 && ucI < 3)
 384   1              {
 385   1                      siAdcResult = look_up_customtable(EEP_TABLE1_ZERO + (22*ucI),siInput,slope_type[ucI]);
 386   1                       
 387   1                      // Add the calibration term to the input.
 388   1                      siResult = siAdcResult + uiCal - CALIBRATION_OFFSET;
 389   1              } */
 390   1              
 391   1              return siResult;
 392   1      }
 393          
 394          
 395          /**********************************Filter***********************************************************/
 396          /*
 397          Description: Filter the data sampled from ADC to get rid of illegal value caused by noise.
 398          parameter:      channel ,there are eight channels for this product,they should be 0 to 7.if channel = 8,
 399                                  it means that the signal from internal thermistor.
 400                                  input, Reading from ADC ,need to be filtered
 401          Return:         Filtered value for send to PC or use for other purpose  
 402                                  
 403          */
 404          /*********************************Filter funtion start***********************************************/
 405          unsigned int Filter(unsigned char channel,signed int input)
 406          {
 407   1              // -------------FILTERING------------------
 408   1              // -------------FILTERING------------------
 409   1              signed int xdata siDelta;
 410   1              signed int xdata siResult;
 411   1          signed int xdata siTemp;
 412   1              signed long xdata slTemp;
 413   1          unsigned char xdata I;
 414   1              
 415   1         
 416   1          I = channel;
 417   1              siTemp = input;
 418   1       
 419   1              siDelta = siTemp - (signed int)old_reading[I] ;    //compare new reading and old reading
 420   1      
 421   1              // If the difference in new reading and old reading is greater than 5 degrees, implement rough filtering.
 422   1          if (( siDelta >= 100 ) || ( siDelta <= -100 ) ) // deg f
C51 COMPILER V9.00   INPUT                                                                 05/08/2013 16:47:37 PAGE 8   

 423   1              {
 424   2                      old_reading[I] = old_reading[I] + (siDelta >> 1);
 425   2              }                       
 426   1              // Otherwise, implement fine filtering.
 427   1              else
 428   1              {                           
 429   2                      slTemp = (signed long)Input_Filter[I]*old_reading[I];
 430   2                      slTemp += (signed long)siTemp;
 431   2                      old_reading[I] = (signed int)(slTemp/(Input_Filter[I] +1));                      
 432   2          }
 433   1              siResult = old_reading[I];
 434   1              return siResult;        
 435   1      }
 436          
 437          
 438          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2439    ----
   CONSTANT SIZE    =     26    ----
   XDATA SIZE       =     74      44
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
