C51 COMPILER V7.50   GSM                                                                   12/29/2009 13:05:29 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE GSM
OBJECT MODULE PLACED IN .\Build\Gsm.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\SRC\GSM\Gsm.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SR
                    -C\FreeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\SRC
                    -\UART\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\uIP\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;..\S
                    -RC\GSM\;..\SRC\Web\) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\Gsm.lst) OBJECT(.\Build\Gsm.obj)

line level    source

   1          #include        "reg80390.h"
   2          #include   "types.h"
   3          #include        "stdio.h"
   4          
   5          #define         SERAIL_IO       TRUE
   6          
   7          #if (SERAIL_IO == TRUE)
   8          /* Software UART */
   9          
  10          /* software serial port :  2 General IO and TIME0 */
  11          #define         GSM_ENABLE      P3_1
  12          
  13          #define         GSM_TXD         P1_1
  14          #define         GSM_RXD         P3_0
  15          
  16          U8_T   bdata rs_BUF;                  //串行收、发时用的移位暂存器。   `
  17          sbit rs_BUF_bit7 = rs_BUF^7;        //移位暂存器的最高位。 
  18          U8_T   rs_shift_count;                //移位计数器。  
  19          U8_T bdata rsFlags;
  20          sbit rs_f_TI        = rsFlags^0;    //0:正在发送; 1: 一个字符完毕  
  21          sbit rs_f_RI_enable = rsFlags^1;   //0:禁止接收; 1:允许接收  
  22          sbit rs_f_TI_enable = rsFlags^2;   //0:禁止发送; 1:允许发送  
  23          
  24          
  25          
  26          //收、发一位所需定时器计数   
  27          #define rs_FULL_BIT0     217            // (Fosc/ 2 ) / Baud        1302 ( 9600 )   2604 ( 4800 )
  28          #define rs_FULL_BIT     (65536 - rs_FULL_BIT0)
  29          #define rs_FULL_BIT_H   rs_FULL_BIT >> 8        //收、发一位所需定时器计数高位   
  30          #define rs_FULL_BIT_L   (rs_FULL_BIT & 0x00FF)  //收、发一位所需定时器计数低位   
  31          //检测起始位的时间间隔所需定时器计数    
  32          #define rs_TEST0 rs_FULL_BIT0 / 4             //波特率较低时可以除以 3 或除以 2    
  33          #define rs_TEST ((~rs_TEST0))
  34          #define rs_TEST_H rs_TEST >> 8                //高位  
  35          #define rs_TEST_L rs_TEST & 0x00FF            //低位  
  36          //发送起始位所需定时器总计数   
  37          #define rs_START_BIT 0xFFFF - 217/*(Fosc/12/Baud)*/ + 0x28
  38          #define rs_START_BIT_H rs_START_BIT >> 8      //发送起始位所需定时器计数高位    
  39          #define rs_START_BIT_L rs_START_BIT & 0x00FF  //发送起始位所需定时器计数低位   
  40          #define rs_RECEIVE_MAX   128                  //最大接收长度  
  41          U8_T rs232buffer[rs_RECEIVE_MAX];          //收、发缓冲区
  42          U16_T ReceivePoint;                       //接收数据存储指针  
  43          
  44          
  45          void soft_rs232_interrupt( void );
  46          
  47          void soft_rs232_init (void)            //串口初始化  
  48          {
  49   1          TR0 = 0;             //停止定时器  
  50   1          TH0 = 0xf8;
  51   1          TL0 = 0x06;
  52   1              GSM_RXD = 1;
C51 COMPILER V7.50   GSM                                                                   12/29/2009 13:05:29 PAGE 2   

  53   1              GSM_TXD = 1;
  54   1          TMOD &= 0xf0;               // set timer way
  55   1          TMOD |= 0x01;
  56   1          PT0 = 1;                        //置中断优先级为高  
  57   1          ET0 = 1;                        //允许定时器中断 
  58   1              TR0 = 1;             //启动定时器  
  59   1      }
  60          
  61          U32_T Timer0Counter = 0;
  62          
  63          void vTimer0ISR( void ) interrupt 1   
  64          {  //           U8_T    temp;
  65   1                      ET0 = 0;
  66   1              //      TH0 = 0xf8;
  67   1          //  TL0 = 0x06;
  68   1              //      Timer0Counter++;
  69   1                      soft_rs232_interrupt();
  70   1                      
  71   1                      ET0 = 1;
  72   1      
  73   1              //      P3_1 = ~P3_1;
  74   1              /*      if (GSM_RXD == 0 | rs_shift_count > 0)
  75   1              { soft_rs232_interrupt(); }
  76   1              else
  77   1              {
  78   1                  TH0 = rs_TEST_H;
  79   1                  TL0 = rs_TEST_L;
  80   1              }*/
  81   1      }
  82           
  83          
  84          void soft_receive_init()               //监测起始位  
  85          {
  86   1          TR0 = 0;             //停止定时器  
  87   1          TH0 = rs_TEST_H;
  88   1          TL0 = rs_TEST_L;
  89   1          rs_shift_count = 0;
  90   1          TR0 = 1;             //启动定时器  
  91   1      }
  92          
  93          void soft_receive_enable()             //允许接收  
  94          {
  95   1          rs_f_RI_enable = 1;                //允许接收  
  96   1          rs_f_TI_enable = 0;                //禁止发送   
  97   1          soft_receive_init();               //监测起始位, RXD 下降沿触发接收字节过程.     
  98   1      }
  99          void soft_send_enable (void)        //允许发送  
 100          {
 101   1          TR0 = 0;             //停止定时器  
 102   1          rs_f_TI_enable = 1;                //允许发送  
 103   1          rs_f_RI_enable = 0;                //禁止接收  
 104   1          rs_shift_count = 0;                //清移位计数器  
 105   1          rs_f_TI   = 1;                     //发送一个字符完毕标志  
 106   1          TR0 = 1;             //启动定时器
 107   1      }
 108          void soft_rs232_interrupt( void )
 109          {
 110   1          /************************ 接收 ****************************/
 111   1          if (rs_f_RI_enable == 1)
 112   1          {
 113   2              if (rs_shift_count == 0)        //移位计数器==0, 表示检测到起始位的起点   
 114   2              {
C51 COMPILER V7.50   GSM                                                                   12/29/2009 13:05:29 PAGE 3   

 115   3                  if ( GSM_RXD == 1 )
 116   3                  {
 117   4                      soft_receive_enable (); //起始位错, 从新开始   
 118   4                  }
 119   3                  else
 120   3                  {
 121   4                      //下次中断在数据位或停止位中的某时刻发生    
 122   4                      TL0 += rs_FULL_BIT_L/* + 0x10*/; 
 123   4                      TH0 = rs_FULL_BIT_H;
 124   4                      rs_shift_count++;              
 125   4                      rs_BUF = 0;             //清移位缓冲变量   
 126   4                  }
 127   3              }
 128   2              else
 129   2              {
 130   3                  TL0 += rs_FULL_BIT_L; //下次中断在数据位或停止位中发生    
 131   3                  TH0 = rs_FULL_BIT_H;
 132   3                                             
 133   3                  rs_shift_count++;           //2--9:数据位 10:停止位 
 134   3                                             
 135   3                  if ( rs_shift_count == 9)
 136   3                  {
 137   4                      rs_BUF = rs_BUF >> 1;   //接收第8位   
 138   4                      rs_BUF_bit7 = GSM_RXD;
 139   4                      if( ReceivePoint < rs_RECEIVE_MAX)
 140   4                      {                       //保存收到的字节    
 141   5                          rs232buffer[ReceivePoint++] = rs_BUF;
 142   5                      }
 143   4                      else
 144   4                      {
 145   5                          rs_f_RI_enable = 0; //缓冲区满, 禁止接收   
 146   5                      }
 147   4                  }
 148   3                  else
 149   3                  {
 150   4                      if (rs_shift_count < 9 ) //收到的是数据位 1 -- 7  
 151   4                      {
 152   5                          rs_BUF = rs_BUF >> 1;
 153   5                          rs_BUF_bit7 = GSM_RXD;
 154   5                      }
 155   4                      else
 156   4                      {   //收到停止位，继续检测 PC 机发出的下一个起始位    
 157   5                          soft_receive_init(); 
 158   5                      }
 159   4                  }
 160   3              }
 161   2              TF0 = 0;                  //清定时器中断标志   
 162   2          }
 163   1          else
 164   1          {
 165   2              /************************ 发送 ****************************/  
 166   2              if (rs_f_TI_enable == 1)
 167   2              {
 168   3                  TL0 += rs_FULL_BIT_L;//下次中断在数据位的末尾时刻   
 169   3                  TH0 = rs_FULL_BIT_H;
 170   3                  rs_shift_count--;          //0:停止位末尾时刻到  
 171   3                                             //1:发送停止位  
 172   3                                             //2--9:发送数据位  
 173   3                  if (rs_shift_count > 9)    //错误状态  
 174   3                  {
 175   4                      rs_shift_count = 9;
 176   4                      rs_BUF = 0xFF;
C51 COMPILER V7.50   GSM                                                                   12/29/2009 13:05:29 PAGE 4   

 177   4                  }
 178   3                  if (rs_shift_count > 1)    //2--9:发送数据位  
 179   3                  {
 180   4                      ACC = rs_BUF;
 181   4                      ACC = ACC >> 1;
 182   4                      GSM_TXD = CY;
 183   4                      rs_BUF = ACC;
 184   4                  }
 185   3                  else
 186   3                  {
 187   4                      if (rs_shift_count == 0) //0:停止位末尾时刻到  
 188   4                      {
 189   5                          GSM_TXD = 1;
 190   5                          rs_f_TI = 1;       //已发送完毕一个字节  
 191   5                      }
 192   4                      else
 193   4                      {
 194   5                          GSM_TXD = 1;        //1:发送停止位  
 195   5                      }
 196   4                  }
 197   3              }
 198   2          }
 199   1      }
 200          //由收转到发时，要先调用 soft_send_enable ()  
 201          void rs_send_byte(U8_T SendByte)      //发送一个字节  
 202          {
 203   1          while ( rs_f_TI == 0);             //等待发送完毕前一个字节  
 204   1          GSM_TXD = 1;
 205   1          TL0 = rs_START_BIT_L;        //下次中断在起始位的末尾时刻   
 206   1          TH0 = rs_START_BIT_H;
 207   1          rs_BUF = SendByte;
 208   1          rs_shift_count = 10;
 209   1          GSM_TXD = 0;                        //发送起始位  
 210   1          rs_f_TI = 0;                       //清已发送完毕一个字节的标志   
 211   1      }
 212          
 213          
 214          void initiate_MCU (void)               //系统初始化  
 215          {
 216   1          soft_rs232_init();                 //串口初始化
 217   1          
 218   1          EA = 1;                            //开中断  
 219   1      }
 220          
 221          
 222          void DELAY_Us(U16_T loop);
 223          #if 0
              void Test_serial(void)
              {
              //首先发送 128 个字节 00H--7FH, 然后等待 PC 机发送的数据。当收到 128
              //个字节后，立刻将收到的 128 个数据回发送给 PC 机，然后继续等待下一个
              //数据块。
                
                  U8_T i;
                  initiate_MCU();                    //系统初始化  
                 soft_send_enable ();               //允许发送，禁止接收  
                 printf("enter\r\n");
                      //while(1)
                  for (i=0; i < rs_RECEIVE_MAX; i++ )
                  {
                      //      printf("send\r\n");
                      rs_send_byte(i);
C51 COMPILER V7.50   GSM                                                                   12/29/2009 13:05:29 PAGE 5   

                              DELAY_Us(1000);
                  }
                  while ( rs_f_TI == 0)  ;           // 等待最后一个字节发送完毕   
                  while(1)
                  {
                      //      printf("enter\r\n");
                      soft_receive_enable ();        //启动并开始接收，禁止发送  
                      while (ReceivePoint < 20); // 等待接收缓冲区满  
                      //      printf("rx0 %s\r\n",rs232buffer);
                      //      printf("rx1 %d\r\n",(int)rs232buffer[5]);
                      soft_send_enable ();           //允许发送，禁止接收  
                      for (i=0; i < 20; i++ )
                      {
                          rs_send_byte(rs232buffer[i]);
                      }
                      while ( rs_f_TI == 0)  ;       //等待最后一个字节发送完毕*/
                      ReceivePoint = 0;
                  }
              }
              #endif
 259          #if 1
 260          const char GSM_Test[] = "AT\r";
 261          void Test_serial(void)
 262          {
 263   1              U8_T i;
 264   1              initiate_MCU();  /* initial mcu */
 265   1              printf("test");
 266   1              /* initial gsm module */
 267   1              soft_send_enable();
 268   1              while(1)
 269   1              {
 270   2                      /*send "at" */
 271   2                      printf("at\r");
 272   2                      rs_send_byte('A');
 273   2                      rs_send_byte('T');
 274   2                      rs_send_byte('\r');
 275   2                      
 276   2                      /*receive "at" */
 277   2                      #if 0
                              soft_receive_enable ();      
                      while (ReceivePoint < 3); 
                      //      printf("rx0 %s\r\n",rs232buffer);
                              printf("rx1 %c %c %c \r\n",rs232buffer[0],rs232buffer[1],rs232buffer[2]);
                   /*   soft_send_enable ();           //允许发送，禁止接收  
                      for (i=0; i < 5; i++ )
                      {
                          rs_send_byte(rs232buffer[i]);
                      }
                      while ( rs_f_TI == 0)  ;       //等待最后一个字节发送完毕*/
                     // ReceivePoint = 0;
                              #endif
 290   2                      //DELAY_Us(50000);DELAY_Us(50000);DELAY_Us(50000);DELAY_Us(50000);DELAY_Us(50000);
 291   2                      DELAY_Us(50000);DELAY_Us(50000);DELAY_Us(50000);DELAY_Us(50000);DELAY_Us(50000);
 292   2              }
 293   1      
 294   1      }
*** WARNING C280 IN LINE 263 OF ..\SRC\GSM\GSM.C: 'i': unreferenced local variable
 295          
 296          #endif
 297          
 298          
 299          #else
C51 COMPILER V7.50   GSM                                                                   12/29/2009 13:05:29 PAGE 6   

              
              
              
              /**********************************************************/
              //   created by chelsea 2009/10/16
              
              void UART0_PutString(char* str)
              {
                      U8_T i;
                      U8_T len = strlen(str);
                      for(i = 0;i < len; i++)
                      {
                              uart0_PutChar(str[i]);
                      }
                      uart0_PutChar('\0');
              }
              
              
              /*
              char* UART0_GetString(void)
              {
                      
                      U8_T i = 0;
                      for(i = 0;i < 255;i++)
                      {
                      //      printf("str %d %c\r\n",(int)i,uart0_GetKey());
                              if(uart0_GetKey() != '\0')
                                      str[i] = uart0_GetKey();
                              else break;
                      }
                      str[++i] = '\0';
                      printf("str %s\r\n",str);
                      return str;
              }*/
              
              
              #endif 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    468    ----
   CONSTANT SIZE    =      9    ----
   XDATA SIZE       =    139       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
