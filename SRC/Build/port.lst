C51 COMPILER V9.00   PORT                                                                  05/08/2013 16:48:49 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE PORT
NO OBJECT MODULE REQUESTED
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\SRC\FreeRTOSSource\portable\Keil\AX11000\port.c LARGE OMF2 ROM(D16M) BRO
                    -WSE INTVECTOR(0X6020) INCDIR(..\SRC\FreeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\S
                    -RC\MS_TIMER\;..\SRC\SW_DMA\;..\SRC\UART\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAP
                    -TER;..\SRC\main;..\SRC\SD_Card\;..\SRC\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer
                    -\;..\SRC\hsur\;..\SRC\management\;..\SRC\dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\s
                    -chedule;..\SRC\program;..\SRC\Scan) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\port.lst) SRC(.\Build\port.SRC)

line level    source

   1          /*
   2                  FreeRTOS V2.6.0 - Copyright (C) 2003 - 2005 Richard Barry.
   3          
   4                  This file is part of the FreeRTOS distribution.
   5          
   6                  FreeRTOS is free software; you can redistribute it and/or modify
   7                  it under the terms of the GNU General Public License as published by
   8                  the Free Software Foundation; either version 2 of the License, or
   9                  (at your option) any later version.
  10          
  11                  FreeRTOS is distributed in the hope that it will be useful,
  12                  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13                  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14                  GNU General Public License for more details.
  15          
  16                  You should have received a copy of the GNU General Public License
  17                  along with FreeRTOS; if not, write to the Free Software
  18                  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  19          
  20                  A special exception to the GPL can be applied should you wish to distribute
  21                  a combined work that includes FreeRTOS, without being obliged to provide
  22                  the source code for any proprietary components.  See the licensing section 
  23                  of http://www.FreeRTOS.org for full details of how and when the exception
  24                  can be applied.
  25          
  26                  ***************************************************************************
  27                  See http://www.FreeRTOS.org for documentation, latest information, license 
  28                  and contact details.  Please ensure to read the configuration and relevant 
  29                  port sections of the online documentation.
  30                  ***************************************************************************
  31          */
  32          
  33          /*-----------------------------------------------------------
  34           * Implementation of functions defined in portable.h for the Cygnal port.
  35           *----------------------------------------------------------*/
  36          //#pragma SRC   
  37          /* Standard includes. */
  38          #include <string.h>
  39          
  40          /* Scheduler includes. */
  41          #include "projdefs.h"
  42          #include "portable.h"
  43          #include "task.h"
  44          #include "queue.h"
  45          #include "mstimer.h"
  46          #include "interrupt.h"
  47          #include "dma.h"
  48          
  49          /* Constants required to setup timer 2 to produce the RTOS tick. */
  50          //#define portCLOCK_DIVISOR                             ( ( unsigned portLONG ) 12 )
C51 COMPILER V9.00   PORT                                                                  05/08/2013 16:48:49 PAGE 2   

  51          //#define portMAX_TIMER_VALUE                           ( ( unsigned portLONG ) 0xffff )
  52          //#define portENABLE_TIMER                              ( ( unsigned portCHAR ) 0x04 )
  53          //#define portTIMER_2_INTERRUPT_ENABLE  ( ( unsigned portCHAR ) 0x20 )
  54          
  55          /* The value used in the IE register when a task first starts. */
  56          #define portGLOBAL_INTERRUPT_BIT        ( ( portSTACK_TYPE ) 0x80 )
  57          
  58          /* The value used in the PSW register when a task first starts. */
  59          #define portINITIAL_PSW                         ( ( portSTACK_TYPE ) 0x00 )
  60          
  61          /* Macro to clear the timer 2 interrupt flag. */
  62          #define portCLEAR_INTERRUPT_FLAG()      {                                       \
  63                                                                                          EINT5 = 0;              \
  64                                                                                          EIF &= ~INT5F;  \
  65                                                                                          EINT5 = 1;              \
  66                                                                                  }
  67                                                                                                  
  68          /* Used during a context switch to store the size of the stack being copied
  69          to or from XRAM. */
  70          //data static unsigned portCHAR ucStackBytes;
  71          //data  unsigned portCHAR ucStackBytes;
  72          
  73          /* Used during a context switch to point to the next byte in XRAM from/to which
  74          a RAM byte is to be copied. */
  75          //xdata static portSTACK_TYPE * data pxXRAMStack;
  76          //static portSTACK_TYPE xdata * data pxXRAMStack;
  77          
  78          /* Used during a context switch to point to the next byte in RAM from/to which
  79          an XRAM byte is to be copied. */
  80          //data static portSTACK_TYPE * data pxRAMStack;
  81          //static  portSTACK_TYPE data * data pxRAMStack;
  82          
  83          /* We require the address of the pxCurrentTCB variable, but don't want to know
  84          any details of its type. */
  85          //typedef void tskTCB;
  86          //extern volatile tskTCB * volatile pxCurrentTCB;
  87          
  88          void LoadCtx() reentrant;   /* Save the current working registers to stack, defined in OS_CPU_A.ASM */
  89          extern INT8U xdata * data C_XBP, TICK_INT;
  90          
  91          
  92          /*
  93           * Setup the hardware to generate an interrupt off timer 2 at the required 
  94           * frequency.
  95           */
  96          static void prvSetupTimerInterrupt( void );
  97          
  98          
  99          /* 
 100           * See header file for description. 
 101           */
 102          portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameter
             -s ) reentrant
 103          {
 104   1          portSTACK_TYPE * stk;
 105   1      
 106   1          stk    = (portSTACK_TYPE *) pxTopOfStack;        /* Load stack pointer                                
             -      */
 107   1      
 108   1              stk                             -= sizeof(void *);              /* Save the pvParameters to external stack */
 109   1              *(void**)stk     = pvParameters;        /*                               */
 110   1      
C51 COMPILER V9.00   PORT                                                                  05/08/2013 16:48:49 PAGE 3   

 111   1              stk                             -= sizeof(INT16U);                                              /* The value should be loaded to PC    */
 112   1              *(INT16U*)stk    = (INT16U) pxCode;                                             /* next time when this task is running */
 113   1      
 114   1              *--stk                   = (portSTACK_TYPE )(((INT32U) pxCode>>16)+0x7F);      /* Third byte of PC for dallas 390 */
 115   1      
 116   1      /* Following is the registers pushed into hardware stack */
 117   1              *--stk                   = 'A';                 /* ACC */
 118   1              *--stk                   = 'B';                 /* B   */
 119   1              *--stk                   = 'X';                 /* DPX */
 120   1              *--stk                   = 'H';                 /* DPH */
 121   1              *--stk                   = 'L';                 /* DPL */
 122   1      //      *--stk                   = 'X';                 /* DPX1 for second DPTR */
 123   1      //      *--stk                   = 'H';                 /* DPH1 for second DPTR */
 124   1      //      *--stk                   = 'L';                 /* DPL1 for second DPTR */
 125   1      //      *--stk                   = DPS;                 /* DPS for second DPTR */
 126   1              *--stk                   = PSW;                                 /* PSW */
 127   1              *--stk                   = 0;                   /* R0  */
 128   1      /*
 129   1              *--stk                   = 1;                   // should be R1
 130   1              *--stk                   = 2;                   // should be R2
 131   1              *--stk                   = 3;                   // should be R3
 132   1      */
 133   1              stk                             -= sizeof(void *);      /* Keil C uses R1,R2,R3 to pass the */
 134   1              *(void**)stk     = pvParameters;                  /* arguments of functions.          */
 135   1      
 136   1              *--stk                   = 4;                   /* R4  */
 137   1              *--stk                   = 5;                   /* R5  */
 138   1              *--stk                   = 6;                   /* R6  */
 139   1              *--stk                   = 7;                   /* R7  */
 140   1      /* Following is the registers pushed into hardware stack manually to support the dallas 390 */
 141   1          *--stk           = 0x80;                /* IE, EA is enabled  */
 142   1      
 143   1      /*
 144   1          Next is calculating the hardware stack pointer.
 145   1      */
 146   1          *--stk                       = (INT8U) portSTACK_START-1      /* Initial value when main was called    */
 147   1                                 +1                   /* IE */
 148   1                                 +8                   /* R0-R7, eight registers was saved      */
 149   1                             +5                   /* ACC, B, DPH, DPL, PSW, five registers */
 150   1                             +1                   /* Dallas 390 extra registers DPX1 */
 151   1      //                       +4                   /* Dallas 390 extra registers for second DPTR - DPL1 DPH1 DP
             -X1 DPS */
 152   1                             +sizeof(INT16U)      /* The PC value to be loaded             */
 153   1                             +sizeof(INT8U)       /* The third byte of PC value to be loaded for dallas 390  */
 154   1                                                 ;
 155   1          return ((void *)stk);
 156   1      
 157   1      }
 158          
 159          /* 
 160           * See header file for description. 
 161           */
 162          portSHORT sPortStartScheduler( portSHORT sUsePreemption ) reentrant
 163          {
 164   1              /* Stop compiler warnings.  This port uses a constant defined in
 165   1              portmacro.h to specify whether or not preemption is used. */
 166   1              sUsePreemption = sUsePreemption;
 167   1      
 168   1              /* Setup timer 2 to generate the RTOS tick. */
 169   1              prvSetupTimerInterrupt();       
 170   1      
 171   1          prvSetCurrentTCB_XBP();
C51 COMPILER V9.00   PORT                                                                  05/08/2013 16:48:49 PAGE 4   

 172   1              LoadCtx();
 173   1                                                                                      /* Should never get here! */
 174   1              return pdTRUE;
 175   1      }
 176          
 177          /*-----------------------------------------------------------*/
 178          
 179          void vPortEndScheduler(void) reentrant
 180          {
 181   1      
 182   1              /* Not implemented for this port. */
 183   1      }
 184          /*-----------------------------------------------------------*/
 185          
 186          
 187          /*********************************************************************************************************
             -*
 188          * C_OSCtxSw is the c part of OSCtxSw.
 189          * When control passes to this function, the processor registers have been saved in external stack
 190          **********************************************************************************************************
             -*/
 191          void vPortContextSwitch(void) reentrant
 192          {
 193   1      
 194   1      /*      Save processor registers; DONE in the OSCtxSw part in OS_CPU_ASM.ASM                                  *
             -/
 195   1      
 196   1      /*      Save the current task's stack pointer into the current task's OS_TCB:  
 197   1                      prvGetCurrentTCB_XBP();
 198   1              Call vTaskSwitchContext();                                    
 199   1              Get the stack pointer of the task to resume:                           
 200   1                      prvSetCurrentTCB_XBP;
 201   1              Restore all processor registers from the new task's stack;             
 202   1              Execute a return from interrupt instruction;                           */
 203   1          prvGetCurrentTCB_XBP();
 204   1          
 205   1              vTaskSwitchContext();
 206   1      
 207   1          prvSetCurrentTCB_XBP();
 208   1          LoadCtx();
 209   1      
 210   1      }
 211          
 212          
 213          INT8U data SaveSP;
 214          
 215          void OSIntCtxSw(void) reentrant
 216          {
 217   1      
 218   1              EA=0;
 219   1          SP=SaveSP;
 220   1      
 221   1          prvSetCurrentTCB_XBP();
 222   1      
 223   1      #pragma ASM
 224   1              EXTRN   CODE(_?KCOSCtxSw)
 225   1              MOV             A, #BYTE0( _?KCOSCtxSw)
 226   1              PUSH    ACC
 227   1              MOV             A, #BYTE1(_?KCOSCtxSw)
 228   1              PUSH    ACC
 229   1              MOV             A, #BYTE2(_?KCOSCtxSw)
 230   1              PUSH    ACC
C51 COMPILER V9.00   PORT                                                                  05/08/2013 16:48:49 PAGE 5   

 231   1              RETI
 232   1      #pragma ENDASM
 233   1      
 234   1      }
 235          
 236          
 237          void vIntPortContextSwitch(void) reentrant
 238          {
 239   1      
 240   1      /*      Save processor registers; DONE in the OSCtxSw part in OS_CPU_ASM.ASM                                  *
             -/
 241   1      
 242   1      /*      Save the current task's stack pointer into the current task's OS_TCB:  
 243   1                      prvGetCurrentTCB_XBP();
 244   1              Call vTaskSwitchContext();                                    
 245   1              Get the stack pointer of the task to resume:                           
 246   1                      prvSetCurrentTCB_XBP;
 247   1              Restore all processor registers from the new task's stack;             
 248   1              Execute a return from interrupt instruction;                           */
 249   1          prvGetCurrentTCB_XBP();
 250   1      
 251   1              if ( TICK_INT == 1 )
 252   1              {
 253   2                      vTaskIncrementTick();
 254   2                      TICK_INT = 0;
 255   2              }
 256   1              vTaskSwitchContext();
 257   1                      
 258   1              portCLEAR_INTERRUPT_FLAG();
 259   1      
 260   1          prvSetCurrentTCB_XBP();
 261   1          LoadCtx();
 262   1              return;
 263   1      
 264   1      }
 265          
 266          extern U8_T ChangeFlash;
 267          /*-----------------------------------------------------------*/
 268          
 269          #if portUSE_PREEMPTION == 1
 270          
 271          /*-----------------------------------------------------------*/
 272          void PWMoutput(void);  // added by chelsea
 273          
 274          void vTimer2ISR( void ) interrupt 10
 275          {
 276   1              unsigned portCHAR       isr;
 277   1      #pragma ASM
 278   1                      PUSH IE
 279   1      #pragma ENDASM
 280   1                      isr = EA;
 281   1                      EA = 0;
 282   1                      TICK_INT = 1;
 283   1                      SaveSP = SP;
 284   1              prvGetCurrentTCB_XBP();
 285   1                              
 286   1                      
 287   1                              PWMoutput();
 288   1      
 289   1                      EA = isr;
 290   1                      OSIntCtxSw();   
 291   1                      
C51 COMPILER V9.00   PORT                                                                  05/08/2013 16:48:49 PAGE 6   

 292   1      
 293   1      }
 294          
 295          #endif
 296          
 297          /*-----------------------------------------------------------*/
 298          static void prvSetupTimerInterrupt( void )
 299          {
 300   1              /* using MS_TIMER */
 301   1              U8_T XDATA      temp[2];
 302   1      
 303   1              /* set software timer */
 304   1              temp[1] = (U8_T)SWTIMER_INTERVAL;
 305   1              temp[0] = (U8_T)(SWTIMER_INTERVAL >> 8) + SWTIMER_START + SWTIMER_INT_ENABLE;
 306   1              DMA_WriteReg(SWTIMER_REG, temp, 2);
 307   1      
 308   1              EXTINT5(1);     /* Enable INT5 interrupt for software timer. */
 309   1      
 310   1      }
 311          
 312          #if ( configUSE_TICK_HOOK == 1 )
              void vApplicationTickHook( void )
              {
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    992    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
