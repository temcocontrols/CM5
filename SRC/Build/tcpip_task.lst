C51 COMPILER V9.00   TCPIP_TASK                                                            05/08/2013 16:47:34 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE TCPIP_TASK
OBJECT MODULE PLACED IN .\Build\tcpip_task.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main\tcpip_task.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\S
                    -RC\FreeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\SR
                    -C\UART\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;.
                    -.\SRC\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management\
                    -;..\SRC\dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule;..\SRC\program;..\SRC\Sca
                    -n) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\tcpip_task.lst) OBJECT(.\Build\tcpip_task.obj)

line level    source

   1          #include "main.h"
   2          
   3          #define INCLUDE_DNS_CLIENT  0
   4          #define INCLUDE_DHCP_CLIENT 1
   5          
   6          #if (INCLUDE_DHCP_CLIENT)
   7            #include "dhcpc.h"
   8          #endif
   9          #if (INCLUDE_DNS_CLIENT)
                #include "dnsctab.h"
              
              #endif
  13          
  14          /* NAMING CONSTANT DECLARATIONS */
  15          #ifdef DEBUG
              #define DBGMSG(A) {A}
              #else
  18          #define DBGMSG(A) {}
  19          #endif
  20          
  21          
  22          
  23          
  24          
  25          typedef struct app_buf {
  26                  U32_T   ipaddr;
  27                  U8_T    buf[100];
  28                  U16_T   uip_len;
  29                  U16_T   PayLoadOffset;
  30                  U8_T    wait;
  31          }APP_BUF;
  32          
  33          APP_BUF XDATA app_arp_buf;
  34          
  35          #define TIME_OUT_COUNTER        (250/SWTIMER_INTERVAL)  //250
  36          static U16_T ServerBroadcastListenPort;
  37          /*
  38           * ----------------------------------------------------------------------------
  39           * Function Name: UpdateIpSettings
  40           * Purpose: Update IP address, subnet mak, gateway IP address and DNS IP address 
  41           * Params:
  42           * Returns:
  43           * Note:
  44           * ----------------------------------------------------------------------------
  45           */
  46          void UpdateIpSettings(U32_T ip)
  47          {
  48   1               U32_T gateWay,subnet;
  49   1      
  50   1               if(ip > 0)
C51 COMPILER V9.00   TCPIP_TASK                                                            05/08/2013 16:47:34 PAGE 2   

  51   1               {
  52   2                      ip = STOE_GetIPAddr();
  53   2                      subnet = STOE_GetSubnetMask();
  54   2                      gateWay = STOE_GetGateway();
  55   2              
  56   2                      /*IP_Addr[3] = 192;//(U8_T)(ip>>24);            
  57   2                      IP_Addr[2] = 168;//(U8_T)(ip>>16);              
  58   2                      IP_Addr[1] = 0;//(U8_T)(ip>>8);         
  59   2                      IP_Addr[0] = 173;//(U8_T)(ip);
  60   2              
  61   2                      SUBNET[3] = 255;//(U8_T)(subnet>>24);
  62   2                      SUBNET[2] = 255;//(U8_T)(subnet>>16);
  63   2                      SUBNET[1] = 255;//(U8_T)(subnet>>8);
  64   2                      SUBNET[0] = 0;//(U8_T)(subnet);
  65   2              
  66   2                      GETWAY[3] = 192;//(U8_T)(gateWay>>24);
  67   2                      GETWAY[2] = 168;//(U8_T)(gateWay>>16);
  68   2                      GETWAY[1] = 0;//(U8_T)(gateWay>>8);
  69   2                      GETWAY[0] = 1;//(U8_T)(gateWay);*/      
  70   2                      IP_Addr[0] = (U8_T)(ip>>24);            
  71   2                      IP_Addr[1] = (U8_T)(ip>>16);            
  72   2                      IP_Addr[2] = (U8_T)(ip>>8);             
  73   2                      IP_Addr[3] = (U8_T)(ip);
  74   2              
  75   2                      SUBNET[0] = (U8_T)(subnet>>24);
  76   2                      SUBNET[1] = (U8_T)(subnet>>16);
  77   2                      SUBNET[2] = (U8_T)(subnet>>8);
  78   2                      SUBNET[3] = (U8_T)(subnet);
  79   2              
  80   2                      GETWAY[0] = (U8_T)(gateWay>>24);
  81   2                      GETWAY[1] = (U8_T)(gateWay>>16);
  82   2                      GETWAY[2] = (U8_T)(gateWay>>8);
  83   2                      GETWAY[3] = (U8_T)(gateWay);    
  84   2              }
  85   1              else
  86   1              {       
  87   2              //      IP_Addr[0] = 173;       IP_Addr[1] = 0; IP_Addr[2] = 168;       IP_Addr[3] = 192;                       
  88   2                      ip = (((U32_T)IP_Addr[0]) << 24) | ((U32_T)IP_Addr[1] << 16) | ((U32_T)IP_Addr[2] << 8) | (IP_Addr[3]);
  89   2              //      SUBNET[0] = 0;  SUBNET[1] = 255;        SUBNET[2] = 255;        SUBNET[3] = 255;
  90   2                      subnet = (((U32_T)SUBNET[0]) << 24) | ((U32_T)SUBNET[1] << 16) | ((U32_T)SUBNET[2] << 8) | (SUBNET[3]);
  91   2              //      GETWAY[0] = 1;  GETWAY[1] = 0;  GETWAY[2] = 168;        GETWAY[3] = 192;
  92   2                      gateWay = (((U32_T)GETWAY[0]) << 24) | ((U32_T)GETWAY[1] << 16) | ((U32_T)GETWAY[2] << 8) | (GETWAY[3]);
  93   2               
  94   2                      TCPIP_SetIPAddr(ip); 
  95   2                      TCPIP_SetSubnetMask(subnet);
  96   2                      TCPIP_SetGateway(gateWay);
  97   2                              
  98   2                      STOE_SetIPAddr(ip); 
  99   2                  STOE_SetSubnetMask(subnet);
 100   2                      STOE_SetGateway(gateWay);
 101   2              
 102   2              //      GCONFIG_SetServerDynamicIP(ip);                                         
 103   2              //      GCONFIG_WriteConfigData();
 104   2              //      GUDPBC_Init(ServerBroadcastListenPort);
 105   2              } 
 106   1      
 107   1      } /* End of UpdateIpSettings */
 108          
 109          /*
 110           * ----------------------------------------------------------------------------
 111           * Function Name: CheckArpTable
 112           * Purpose: Update IP address, subnet mak, gateway IP address and DNS IP address 
C51 COMPILER V9.00   TCPIP_TASK                                                            05/08/2013 16:47:34 PAGE 3   

 113           * Params:
 114           * Returns:
 115           * Note:
 116           * ----------------------------------------------------------------------------
 117           */
 118          void CheckArpTable(void)
 119          {
 120   1              if (app_arp_buf.wait) 
 121   1              {
 122   2                      U8_T valid = STOE_CHECK_MAC(&app_arp_buf.ipaddr);
 123   2                      if (valid) 
 124   2                      {
 125   3                              DMA_GrantXdata(uip_buf, app_arp_buf.buf, app_arp_buf.uip_len);
 126   3                      //      PRINTD(DEBUG_MSG ,("send out the packet from arp buffer\n\r"));
 127   3                              uip_len = app_arp_buf.uip_len;
 128   3                              ETH_Send(app_arp_buf.PayLoadOffset);
 129   3                              uip_len = 0;
 130   3                              app_arp_buf.wait = 0;
 131   3                      }
 132   2              }
 133   1      } /* End of CheckArpTable */
 134          
 135          
 136          
 137          void TCPIP_Task(void)reentrant
 138          {
 139   1         //U32_T far iP,gateWay,subnet;
 140   1         U8_T linktype = 0;
 141   1         portTickType xDelayPeriod  = ( portTickType ) 250 / portTICK_RATE_MS;//2 minutes writting flash.
 142   1              
 143   1      
 144   1       #if (BOOTLDR_ISR)
                      ERROR: BOOTLDR_ISR must set to '0' in non-bootloader driver.
                 #endif
 147   1         #if (!AX_ETH_INT_ENABLE)
                       ERROR: Must enable ethernet module in this driver.
                 #endif
 150   1               U32_T  timeCount,preTimeCount;
 151   1         #if (INCLUDE_DHCP_CLIENT)
 152   1              U8_T    cmdDhcpFlag = 0;
 153   1              U32_T   dhcpTimeStart = 0;
 154   1              U32_T   dhcpTimeStop = 0;
 155   1      #endif
 156   1      #if STOE_TRANSPARENT
              //      U8_T xdata arptimer;
              #endif
 159   1      
 160   1      //   U8_T WhichServer;
 161   1      
 162   1              /* Initialize Network adapter */
 163   1              ETH_Init();
 164   1      
 165   1              DHCP_Init();
 166   1              //if (DHCP_Init())
 167   1              //      printd("DHCP init ok.\n\r");
 168   1      
 169   1      #if (INCLUDE_DNS_CLIENT)
                      DNSCTAB_Init(); /* include DNS table */
              #endif
 172   1      
 173   1      
 174   1      #if GCONFIG_EEPROM_CONFIG
C51 COMPILER V9.00   TCPIP_TASK                                                            05/08/2013 16:47:34 PAGE 4   

                      I2C_Init();
              #endif
 177   1              GCONFIG_Init();
 178   1      
 179   1      //      ServerBroadcastListenPort = GCONFIG_GetServerBroadcastListenPort();
 180   1      //      printd ("ServerBroadcastListenPort = %d\n\r", ServerBroadcastListenPort);
 181   1      //      ServerBroadcastListenPort = 25122;
 182   1      //      GUDPBC_Init(ServerBroadcastListenPort);
 183   1      
 184   1      #if (INCLUDE_DHCP_CLIENT)       
 185   1              if ( (TCP_TYPE == DHCP) && ((GCONFIG_GetNetwork() & GCONFIG_NETWORK_DHCP_ENABLE) == GCONFIG_NETWORK_DHCP_
             -ENABLE) )
 186   1              {
 187   2              //      printd("DHCP request... ");
 188   2                      DHCP_Start();
 189   2      #if (!STOE_TRANSPARENT)
 190   2                      STOE_DisableIpFilter();
 191   2      #endif
 192   2                      cmdDhcpFlag = 1;
 193   2                      dhcpTimeStart = SWTIMER_Tick();
 194   2              }
 195   1              else
 196   1              {
 197   2                      UpdateIpSettings(0);
 198   2              }
 199   1      #else
              //      printd("DHCP module is not included. Use static IP address\n\r");
                      GCONFIG_SetServerDynamicIP(GCONFIG_GetServerStaticIP());                                                
                      GCONFIG_WriteConfigData();
                      GUDPBC_Init(ServerBroadcastListenPort);
              #endif
 205   1      
 206   1              ServerBroadcastListenPort = 1234; 
 207   1              GUDPBC_Init(ServerBroadcastListenPort);
 208   1      
 209   1              HTTP_Init();
 210   1      //      FSYS_Init();
 211   1      
 212   1      //      SNTPC_Init();
 213   1              
 214   1              ETH_Start();
 215   1      
 216   1      //      WhichServer=Para[45]; //customer choose which server fro Sync.
 217   1      //      SNTPC_Start(800, IpServer[WhichServer]);
 218   1      //      should add condition if whichserver exceeds 6
 219   1      
 220   1              while (1)
 221   1              {
 222   2      //              HSUR_ErrorRecovery(); 
 223   2        
 224   2      
 225   2      #if (!STOE_TRANSPARENT)
 226   2                      ETH_SendArpToGateway(ETH_CONTINUE_ARP_REQUEST_TO_GATEWAY_AFTER_REPLY);
 227   2      #endif
 228   2                      Test[0]++;
 229   2                      CheckArpTable();
 230   2      
 231   2      #if (INCLUDE_DHCP_CLIENT)
 232   2                      if (cmdDhcpFlag == 1)
 233   2                      {                       
 234   3                              if (DHCP_GetState() > DHCP_IDLE_STATE)
 235   3                              {
C51 COMPILER V9.00   TCPIP_TASK                                                            05/08/2013 16:47:34 PAGE 5   

 236   4                                      DHCP_Send();
 237   4                              }
 238   3                              else
 239   3                              {
 240   4                                      UpdateIpSettings(STOE_GetIPAddr());
 241   4      #if (!STOE_TRANSPARENT)
 242   4                                      STOE_EnableIpFilter();
 243   4      #endif
 244   4                                      cmdDhcpFlag = 0;
 245   4                              }
 246   3                      }
 247   2      #endif
 248   2      
 249   2      #if (STOE_GET_INTSTATUS_MODE == STOE_INTERRUPT_MODE)    /* interrupt mode */
                              if (STOE_GetInterruptFlag())
                              {
                                      STOE_ProcessInterrupt();
                              }
              #else   /* polling mode */
 255   2                      STOE_ProcessInterrupt();
 256   2      #endif
 257   2      
 258   2      #if (!MAC_GET_INTSTATUS_MODE)
 259   2                      if (MAC_GetInterruptFlag())
 260   2                      {
 261   3                              MAC_ProcessInterrupt();
 262   3                      }
 263   2      #else
                              linktype = MAC_LinkSpeedChk();
                              if(linktype == 0)  flag_EthPort = 0;
                              else    flag_EthPort = 1;
              #endif
 268   2      
 269   2                      timeCount = (U16_T)SWTIMER_Tick();
 270   2                      if ((timeCount- preTimeCount)>= TIME_OUT_COUNTER)
 271   2                      {
 272   3                              preTimeCount = timeCount;
 273   3                              TCPIP_PeriodicCheck();
 274   3                      }
 275   2              //      vTaskDelay(xDelayPeriod);
 276   2                      
 277   2             timeCount = (U16_T)SWTIMER_Tick();
 278   2               #if 0    // dont understand it 
                     if(Para[43]==2)
                         {
                                SNTPC_GetState();Para[43]=1;
                     }
                      #endif
 284   2            //  SNTPC_Debug();
 285   2      
 286   2      #if (INCLUDE_DNS_CLIENT)
                              if (cmdDnsFlag == 1)
                              {
                                      U8_T state = DNSCTAB_GetState();/* include DNS table */
              
                                      if (state == DNSC_STATE_FREE)
                                      {
                                              cmdDnsFlag = 0;
                                              //printf ("Can not find DNS server.\n\r");
                                      }
                                      else if (state == DNSC_STATE_RESPONSED)
                                      {
C51 COMPILER V9.00   TCPIP_TASK                                                            05/08/2013 16:47:34 PAGE 6   

                                              U32_T   ip;
              
                                              cmdDnsFlag = 0;
              
                                              if ((ip = DNSCTAB_GetIP()) == 0)
                                              {
                                              //      printf ("Can not find remote station via DNS server.\n\r");
                                              }
                                              else
                                              {
                                              //      printf ("Get IP address from DNS server : %lx\n\r", ip);
                                              }
                                      }
                              }
              #endif
 313   2      
 314   2              }
 315   1      } /* End of main() */
 316          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1485    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    111      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
