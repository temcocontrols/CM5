C51 COMPILER V9.00   I2C                                                                   05/08/2013 16:47:35 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN .\Build\i2c.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE I2C\i2c.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\FreeR
                    -TOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\SRC\UART\;
                    -..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;..\SRC\GS
                    -M\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management\;..\SRC\
                    -dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule;..\SRC\program;..\SRC\Scan) DEFIN
                    -E(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\i2c.lst) OBJECT(.\Build\i2c.obj)

line level    source

   1          /*
   2           *********************************************************************************
   3           *     Copyright (c) 2005       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           *********************************************************************************
  10           */
  11          /*================================================================================
  12           * Module Name : i2c.c
  13           * Purpose     : This module handles the I2C serial interface driver.
  14           * Author      : Robin Lee
  15           * Date        : 2005-01-10
  16           * Notes       :
  17           * $Log: i2c.c,v $
  18           * Revision 1.0  2009-01-05 14:03:31+08  wong
  19           * Initial revision
  20           *
  21           * Revision 1.2  2006/04/14 00:56:42  robin6633
  22           * Fixed the function name error "I2cCmd() -> I2C_Cmd()".
  23           *
  24           * Revision 1.1  2006/04/07 11:38:34  robin6633
  25           * no message
  26           *
  27           *================================================================================
  28           */
  29          
  30          /* INCLUDE FILE DECLARATIONS */
  31          #include        <stdio.h>
  32          #include        "reg80390.h"
  33          #include        "types.h"
  34          #include        "i2c.h"
  35          #if I2C_SLAVE_ENABLE
              #include        "console_debug.h"       
              #endif
  38          
  39          /* STATIC VARIABLE DECLARATIONS */
  40           U8_T           i2cCtrl = 0;
  41           U8_T           i2cEndCond = 0;
  42           U8_T           i2cActF = 0;    // indicate the condition of a transfer
  43           U16_T  i2cDataLen = 0; // The I2cPktLen includes address and data
  44           U16_T  i2cDataLenCnt = 0;      // Packet's counter of transferring 
  45           U8_T           i2cPktDir = 0;  // Packet's direction
  46          static I2C_BUF  *ptI2cTxBuf = 0;
  47          static I2C_BUF  *ptI2cRxBuf = 0;
  48           U8_T           i2cState = 0;   // I2C master state flag
  49           U8_T           i2cSlvRxPkt[SLV_MAX_PKT_NUM];
  50           U8_T           i2cSlvTxPkt[SLV_MAX_PKT_NUM];
C51 COMPILER V9.00   I2C                                                                   05/08/2013 16:47:35 PAGE 2   

  51          
  52          
  53          /* LOCAL SUBPROGRAM DECLARATIONS */
  54          static void i2c_MstStatus(U8_T i2cStatus);
  55          static void i2c_SlvStatus(U8_T i2cStatus);
  56          static void i2c_MasterXmit(U8_T wrData, U8_T mstCmd);
  57          static void i2c_MasterRcvr(U8_T *rdData, U8_T mstCmd);
  58          static void i2c_SlaveXmit(U8_T wrData, U8_T slvCmd);
  59          static void i2c_SlaveRcvr(U8_T *rdData, U8_T slvCmd);
  60          
  61          #if I2C_SLAVE_ENABLE
              static void i2c_SlvRxProcess(void);
              #endif
  64          
  65          
  66          /* LOCAL SUBPROGRAM BODIES */
  67          
  68          /*
  69           *--------------------------------------------------------------------------------
  70           * static void i2c_MstStatus(U8_T i2cStatus)
  71           * Purpose : Checks the interrupt status of I2C master mode.
  72           * Params  : i2cStatus - master status when interrupt occured.
  73           * Returns : none
  74           * Note    : none
  75           *--------------------------------------------------------------------------------
  76           */
  77          static void i2c_MstStatus(U8_T i2cStatus)
  78          {
  79   1              if (i2cPktDir == I2C_MST_XMIT)
  80   1      
  81   1                      /* Check the current byte ack */        {
  82   2                      if ((!(i2cStatus & I2C_NO_ACK)) && (i2cStatus & I2C_INTR_FLAG)
  83   2                      && (!(i2cStatus & I2C_TIP)) && (i2cStatus & I2C_BUS_BUSY))
  84   2                      {
  85   3                              if (!I2C_FlagChk(I2C_BUSY))
  86   3                              {
  87   4                                      I2C_FlagEnb(I2C_RESTART);
  88   4                              }
  89   3                              else
  90   3                              {
  91   4                                      if ((i2cCtrl & I2C_10BIT) && (i2cActF & I2C_START_COND))
  92   4                                      {
  93   5                                              i2c_MasterXmit((U8_T)(ptI2cTxBuf->I2cAddr.TenBitAddr & 0x00FF), I2C_MASTER_GO | I2C_CMD_WRITE);
  94   5                                      }
  95   4                                      else
  96   4                                      {
  97   5                                              if (i2cDataLenCnt < (i2cDataLen-1))
  98   5                                              {
  99   6                                                      /* transmit the first data byte */
 100   6                                                      i2c_MasterXmit(ptI2cTxBuf->I2cData[i2cDataLenCnt], I2C_MASTER_GO | I2C_CMD_WRITE);
 101   6                                                      i2cDataLenCnt ++;
 102   6                                              }
 103   5                                              else if (i2cDataLenCnt == (i2cDataLen-1))
 104   5                                              {
 105   6                                                      /* transmit the last data byte */
 106   6                                                      if (i2cEndCond & I2C_STOP_COND)
 107   6                                                      {
 108   7                                                              i2c_MasterXmit(ptI2cTxBuf->I2cData[i2cDataLenCnt], I2C_MASTER_GO | I2C_CMD_WRITE | I2C_STOP_COND);
 109   7                                                              i2cDataLenCnt = 0;
 110   7                                                      }
 111   6                                                      else
 112   6                                                      {
C51 COMPILER V9.00   I2C                                                                   05/08/2013 16:47:35 PAGE 3   

 113   7                                                              i2c_MasterXmit(ptI2cTxBuf->I2cData[i2cDataLenCnt], I2C_MASTER_GO | I2C_CMD_WRITE);
 114   7                                                              i2cDataLenCnt = 0;
 115   7                                                              EA = 0;
 116   7                                                              I2C_FlagClr(I2C_BUSY);
 117   7                                                              EA = 1;
 118   7                                                      }
 119   6                                              }
 120   5                                      }
 121   4                              }
 122   3                      /*      if (i2cActF & I2C_STOP_COND)
 123   3                              {
 124   3                                      i2cDataLenCnt = 0;
 125   3                                      EA = 0;
 126   3                                      I2C_FlagClr(I2C_BUSY);
 127   3                                      EA = 1;
 128   3                              }*/
 129   3                      }
 130   2                      else if (i2cStatus & I2C_NO_ACK)
 131   2                      {
 132   3                              i2cDataLenCnt = 0;
 133   3                              if (i2cActF & I2C_START_COND)
 134   3                              {
 135   4                                      /* transmit the STOP condition */
 136   4                                      i2c_MasterXmit(0, I2C_MASTER_GO | I2C_STOP_COND);
 137   4                                      i2cDataLenCnt = 0;
 138   4                                      EA = 0;
 139   4                                      I2C_FlagClr(I2C_BUSY);
 140   4                                      I2C_FlagEnb(I2C_NACK);
 141   4                                      EA = 1;
 142   4                              }
 143   3                              else
 144   3                              {
 145   4                                      i2cDataLenCnt = 0;
 146   4                                      EA = 0;
 147   4                                      I2C_FlagClr(I2C_BUSY);
 148   4                                      EA = 1;
 149   4                              }
 150   3                      }
 151   2                      else if (i2cStatus & I2C_ARB_LOST)
 152   2                      {
 153   3                              i2c_MasterXmit(0, I2C_MASTER_GO | I2C_STOP_COND);
 154   3                              i2cDataLenCnt = 0;
 155   3                              EA = 0;
 156   3                              I2C_FlagClr(I2C_BUSY);
 157   3                              I2C_FlagEnb(I2C_NACK);
 158   3                              //printf("I2C arbitration lost\n\r");
 159   3                              EA = 1;
 160   3                      }
 161   2                      else if (i2cStatus & I2C_TIP)
 162   2                      {
 163   3                              i2cDataLenCnt = 0;
 164   3                              if (i2cActF & I2C_START_COND)
 165   3                              {
 166   4                                      I2C_FlagClr(I2C_BUSY);
 167   4                                      /* transmit the STOP condition */
 168   4                                      i2c_MasterXmit(0, I2C_MASTER_GO | I2C_STOP_COND);
 169   4                              }
 170   3                              else
 171   3                              {
 172   4                                      /* transmit the STOP condition or repeat START condition */
 173   4                                      I2C_PktBuf(ptI2cTxBuf);
 174   4                              }
C51 COMPILER V9.00   I2C                                                                   05/08/2013 16:47:35 PAGE 4   

 175   3                      }
 176   2                      else if ((!(i2cStatus & I2C_NO_ACK)) && (!(i2cStatus & I2C_TIP)) && (!(i2cStatus & I2C_BUS_BUSY)))
 177   2                      {
 178   3                              if (i2cActF & I2C_STOP_COND)
 179   3                              {
 180   4                                      i2cDataLenCnt = 0;
 181   4                                      EA = 0;
 182   4                                      I2C_FlagClr(I2C_BUSY);
 183   4                                      EA = 1;
 184   4                              }
 185   3                      }
 186   2              }
 187   1              else if (i2cPktDir == I2C_MST_RCVR)
 188   1              {
 189   2                      /* Check the current byte ack */
 190   2                      if ((!(i2cStatus & I2C_NO_ACK)) && (i2cStatus & I2C_INTR_FLAG)
 191   2                      && (!(i2cStatus & I2C_TIP)) && (i2cStatus & I2C_BUS_BUSY))
 192   2                      {
 193   3                              if (i2cActF & I2C_START_COND)
 194   3                              {
 195   4                                      if (i2cDataLenCnt == (i2cDataLen - 1))
 196   4                                              i2c_MasterRcvr(&(ptI2cRxBuf->I2cData[0]), I2C_MASTER_GO | I2C_CMD_READ | I2C_STOP_COND);
 197   4                                      else
 198   4                                              i2c_MasterRcvr(&(ptI2cRxBuf->I2cData[0]), I2C_MASTER_GO | I2C_CMD_READ);
 199   4                              }
 200   3                              else if (i2cActF & I2C_STOP_COND)
 201   3                              {
 202   4                                      I2C_FlagClr(I2C_BUSY);
 203   4                                      i2c_MasterRcvr(&(ptI2cRxBuf->I2cData[i2cDataLenCnt]), 0);
 204   4                              }
 205   3                              else
 206   3                              {
 207   4                                      if (i2cDataLenCnt < (i2cDataLen - 1))
 208   4                                      {
 209   5                                              /* reveive the next byte */
 210   5                                              i2c_MasterRcvr(&(ptI2cRxBuf->I2cData[i2cDataLenCnt]), I2C_MASTER_GO | I2C_CMD_READ);
 211   5                                      }
 212   4                                      else if (i2cDataLenCnt == (i2cDataLen - 1))
 213   4                                      {
 214   5                                              /* receive the last byte */
 215   5                                              i2c_MasterRcvr((U8_T *)(&(ptI2cRxBuf->I2cData[i2cDataLenCnt])), I2C_MASTER_GO | I2C_CMD_READ | I2C_ST
             -OP_COND);
 216   5                                      }
 217   4                              }
 218   3                      }
 219   2                      else if (i2cStatus & I2C_NO_ACK)
 220   2                      {
 221   3                              i2cDataLenCnt = 0;
 222   3                              if (i2cActF & I2C_START_COND)
 223   3                              {
 224   4                                      i2c_MasterXmit(0, I2C_MASTER_GO | I2C_STOP_COND);
 225   4                                      i2cDataLenCnt = 0;
 226   4                                      EA = 0;
 227   4                                      I2C_FlagClr(I2C_BUSY);
 228   4                                      I2C_FlagEnb(I2C_NACK);
 229   4                                      EA = 1;
 230   4                              }
 231   3                              else
 232   3                              {
 233   4                                      i2cDataLenCnt = 0;
 234   4                                      EA = 0;
 235   4                                      I2C_FlagClr(I2C_BUSY);
C51 COMPILER V9.00   I2C                                                                   05/08/2013 16:47:35 PAGE 5   

 236   4                                      EA = 1;
 237   4                              }
 238   3                      }
 239   2                      else
 240   2                      {
 241   3                              if (i2cActF & I2C_STOP_COND)
 242   3                              {
 243   4                                      I2C_FlagClr(I2C_BUSY);
 244   4                                      i2c_MasterRcvr(&(ptI2cRxBuf->I2cData[i2cDataLenCnt]), 0);
 245   4                              }
 246   3                      }
 247   2              }
 248   1      }
 249          
 250          /*
 251           *--------------------------------------------------------------------------------
 252           * static void i2c_SlvStatus(U8_T i2cStatus)
 253           * Purpose : Handles the interrupt status of I2C slave mode.
 254           * Params  : none
 255           * Returns : none
 256           * Note    : none
 257           *--------------------------------------------------------------------------------
 258           */
 259          static void i2c_SlvStatus(U8_T i2cStatus)
 260          {
 261   1              U8_T    devAddr;
 262   1      
 263   1              if (i2cStatus & I2C_SLV_STOP)
 264   1              {
 265   2                      if (!(i2cStatus & I2C_SLV_START))
 266   2                      {
 267   3                              if (i2cPktDir == I2C_SLV_RCVR)
 268   3                              {
 269   4                                      i2cDataLen = i2cDataLenCnt;
 270   4                                      #if I2C_SLAVE_ENABLE
                                              i2c_SlvRxProcess();
                                              #endif
 273   4                              }
 274   3                              i2cDataLenCnt = 0;
 275   3                              i2c_SlaveRcvr(&i2cSlvRxPkt[i2cDataLenCnt], I2C_SLAVE_GO);
 276   3                      }
 277   2              }
 278   1              if (i2cStatus & I2C_SLV_NACK)
 279   1              {
 280   2                      i2c_SlaveRcvr(&devAddr, I2C_RLS);
 281   2              }
 282   1              else
 283   1              {
 284   2                      if (i2cStatus & I2C_SLV_WR)
 285   2                      {
 286   3                              if (i2cStatus & I2C_SLV_START)
 287   3                              {
 288   4                                      i2c_SlaveRcvr(&devAddr, I2C_SLAVE_GO);
 289   4                                      i2cPktDir = I2C_SLV_RCVR;
 290   4                                      i2cDataLenCnt = 0;
 291   4                              }
 292   3                              else if (i2cStatus & I2C_SLV_STOP)
 293   3                              {
 294   4                                      i2c_SlaveRcvr(&i2cSlvRxPkt[i2cDataLenCnt], I2C_SLAVE_GO);
 295   4                                      i2cDataLen = i2cDataLenCnt;
 296   4                                      #if I2C_SLAVE_ENABLE
                                              i2c_SlvRxProcess();
C51 COMPILER V9.00   I2C                                                                   05/08/2013 16:47:35 PAGE 6   

                                              #endif
 299   4                                      i2cDataLenCnt = 0;
 300   4                              }
 301   3                              else if (i2cStatus & I2C_SLV_RESTART)
 302   3                              {
 303   4                                      i2c_SlaveRcvr(&devAddr, I2C_SLAVE_GO);
 304   4                                      i2cPktDir = I2C_SLV_RCVR;
 305   4                                      i2cDataLenCnt = 0;
 306   4                              }
 307   3                              else
 308   3                              {
 309   4                                      i2c_SlaveRcvr(&i2cSlvRxPkt[i2cDataLenCnt], I2C_SLAVE_GO);
 310   4                                      i2cDataLenCnt ++;
 311   4                              }
 312   3                      }
 313   2                      else if (i2cStatus & I2C_SLV_RD)
 314   2                      {
 315   3                              if (i2cStatus & I2C_SLV_STOP)
 316   3                              {
 317   4                                      i2c_SlaveRcvr(&devAddr, I2C_SLAVE_GO);
 318   4                                      i2cDataLenCnt = 0;
 319   4                              }
 320   3                              else if (i2cStatus & I2C_SLV_START)
 321   3                              {
 322   4                                      i2cPktDir = I2C_SLV_XMIT;
 323   4                                      i2cDataLenCnt = 0;
 324   4                                      #if I2C_SLAVE_ENABLE
                                              i2c_SlvRxProcess();
                                              #endif
 327   4                                      i2c_SlaveXmit(i2cSlvTxPkt[i2cDataLenCnt], I2C_SLAVE_GO);
 328   4                                      i2cDataLenCnt ++;
 329   4                              }
 330   3                              else if (i2cStatus & I2C_SLV_RESTART)
 331   3                              {
 332   4                                      i2cPktDir = I2C_SLV_XMIT;
 333   4                                      i2cDataLenCnt = 0;
 334   4                                      #if I2C_SLAVE_ENABLE
                                              i2c_SlvRxProcess();
                                              #endif
 337   4                                      i2c_SlaveXmit(i2cSlvTxPkt[i2cDataLenCnt], I2C_SLAVE_GO);
 338   4                                      i2cDataLenCnt ++;
 339   4                              }
 340   3                              else
 341   3                              {
 342   4                                      if (i2cSlvRxPkt[0] == I2C_SLV_BRDM)
 343   4                                      {
 344   5                                              #if I2C_SLAVE_ENABLE
                                                      i2c_SlvRxProcess();
                                                      #endif
 347   5                                      }
 348   4                                      i2c_SlaveXmit(i2cSlvTxPkt[i2cDataLenCnt], I2C_SLAVE_GO);
 349   4                                      i2cDataLenCnt ++;
 350   4                              }
 351   3                      }
 352   2              }
 353   1      }
 354          
 355          #if I2C_SLAVE_ENABLE
              /*
               *--------------------------------------------------------------------------------
               * static void i2c_SlvRxProcess(void)
               * Purpose : Handling received command functions in I2C slave mode And replying
C51 COMPILER V9.00   I2C                                                                   05/08/2013 16:47:35 PAGE 7   

               *           packets corresponding with the received command.
               * Params  : none
               * Returns : none
               * Note    : none
               *--------------------------------------------------------------------------------
               */
              static void i2c_SlvRxProcess(void)
              {
                      U8_T    slvCmd;
                      U8_T    sfrAddr;
                      U8_T    cmdIndReg, realReg, realLen;
                      U32_T   memAddr, memData;
                      U16_T   i;
              
                      slvCmd = i2cSlvRxPkt[0];
                      if ((slvCmd & 0xF0) == I2C_SLV_SWSFR)
                      {
                              realLen = (slvCmd & 0x0F) + 1;
                              sfrAddr = i2cSlvRxPkt[1];
                              for (i = 0 ; i < realLen ; i ++)
                              {
                                      CLI_SfrWr((U32_T)sfrAddr, (U32_T)i2cSlvRxPkt[i + 2]);
                              }
                      }
                      else if ((slvCmd & 0xF0) == I2C_SLV_SRSFR)
                      {
                              realLen = (slvCmd & 0x0F) + 1;
                              sfrAddr = i2cSlvRxPkt[1];
                              for (i = 0 ; i < realLen ; i ++)
                              {
                                      CLI_SfrRd((U32_T)sfrAddr, &memData);
                                      i2cSlvTxPkt[i] = (U8_T)memData;
                              }
                      }
                      else if ((slvCmd & 0xF0) == I2C_SLV_IWSFR)
                      {
                              cmdIndReg = i2cSlvRxPkt[1];
                              realReg = i2cSlvRxPkt[2];
                              realLen = (slvCmd & 0x0F) + 1;
                              if (cmdIndReg == SFR_I2CCIR)
                              {
                                      CLI_I2cWr((U32_T)realReg, &i2cSlvRxPkt[3], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_SPICIR)
                              {
                                      CLI_SpiWr((U32_T)realReg, &i2cSlvRxPkt[3], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_OWCIR)
                              {
                                      CLI_OwWr((U32_T)realReg, &i2cSlvRxPkt[3], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_CANCIR)
                              {
                                      CLI_CanWr((U32_T)realReg, &i2cSlvRxPkt[3], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_TCIR)
                              {
                                      CLI_ToeWr((U32_T)realReg, &i2cSlvRxPkt[3], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_MCIR)
                              {
                                      CLI_MacWr((U32_T)realReg, &i2cSlvRxPkt[3], (U8_T)realLen);
C51 COMPILER V9.00   I2C                                                                   05/08/2013 16:47:35 PAGE 8   

                              }
                      }
                      else if ((slvCmd & 0xF0) == I2C_SLV_IRSFR)
                      {
                              cmdIndReg = i2cSlvRxPkt[1];
                              realReg = i2cSlvRxPkt[2];
                              realLen = (slvCmd & 0x0F) + 1;
                              if (cmdIndReg == SFR_I2CCIR)
                              {
                                      CLI_I2cRd((U32_T)realReg, &i2cSlvTxPkt[i2cDataLenCnt], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_SPICIR)
                              {
                                      CLI_SpiRd((U32_T)realReg, &i2cSlvTxPkt[i2cDataLenCnt], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_OWCIR)
                              {
                                      CLI_OwRd((U32_T)realReg, &i2cSlvTxPkt[i2cDataLenCnt], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_CANCIR)
                              {
                                      CLI_CanRd((U32_T)realReg, &i2cSlvTxPkt[i2cDataLenCnt], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_TCIR)
                              {
                                      CLI_ToeRd((U32_T)realReg, &i2cSlvTxPkt[i2cDataLenCnt], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_MCIR)
                              {
                                      CLI_MacRd((U32_T)realReg, &i2cSlvTxPkt[i2cDataLenCnt], (U8_T)realLen);
                              }
                      }
                      else if (slvCmd == I2C_SLV_BWDM)
                      {
                              memAddr = ((U32_T)i2cSlvRxPkt[3] << 16) | ((U32_T)i2cSlvRxPkt[2] << 8) | ((U32_T)i2cSlvRxPkt[1]);
                              for (i = 4 ; i < i2cDataLen ; i ++)
                              {
                                      CLI_ExtMemWr((U32_T)memAddr, (U32_T)i2cSlvRxPkt[i]);
                                      memAddr ++;
                              }
                      }
                      else if (slvCmd == I2C_SLV_BRDM)
                      {
                              if (i2cDataLenCnt == 0)
                              {
                                      memAddr = ((U32_T)i2cSlvRxPkt[3] << 16) | ((U32_T)i2cSlvRxPkt[2] << 8) | ((U32_T)i2cSlvRxPkt[1]);
                              }
                              CLI_ExtMemRd((U32_T)memAddr, &memData);
                              i2cSlvTxPkt[i2cDataLenCnt] = (U8_T)memData;
                              memAddr ++;
                      }
              }
              #endif
 475          
 476          /*
 477           *--------------------------------------------------------------------------------
 478           * static void i2c_MasterXmit(U8_T wrData, U8_T mstCmd)
 479           * Purpose : Putting the data into i2c transmitting register and setting the
 480           *           master's command and condition in I2C master mode.
 481           * Params  : wrData - one byte data to transmit.
 482           *           mstCmd - master command of the current byte data.
 483           * Returns : none
C51 COMPILER V9.00   I2C                                                                   05/08/2013 16:47:35 PAGE 9   

 484           * Note    : none
 485           *--------------------------------------------------------------------------------
 486           */
 487          static void i2c_MasterXmit(U8_T wrData, U8_T mstCmd)
 488          {
 489   1              /* Record the globe flag of command condition */
 490   1              i2cActF = mstCmd;
 491   1              /* First the master flipper sends the slave address to access */
 492   1              I2C_Cmd(SI_WR, I2CTR, &wrData);
 493   1              /* Order command to I2CCR */
 494   1              I2C_Cmd(SI_WR, I2CCR, &mstCmd);
 495   1      }
 496          
 497          /*
 498           *--------------------------------------------------------------------------------
 499           * static void i2c_MasterRcvr(U8_T *rdData, U8_T mstCmd)
 500           * Purpose : Getting the receiving byte data in I2C master mode.
 501           * Params  : *rdData - a pointer to store receiving data.
 502           *           mstCmd - master command of the current byte data.
 503           * Returns : none
 504           * Note    : none
 505           *--------------------------------------------------------------------------------
 506           */
 507          static void i2c_MasterRcvr(U8_T *rdData, U8_T mstCmd)
 508          {
 509   1              /* Record the globe flag of command condition */
 510   1              i2cActF = mstCmd;
 511   1              /* After ACK, read data from I2CRR */
 512   1              I2C_Cmd(SI_RD, I2CRR, rdData);
 513   1              /* Then, reply ACK to slave */
 514   1              I2C_Cmd(SI_WR, I2CCR, &mstCmd);
 515   1      
 516   1              i2cDataLenCnt ++;
 517   1      }
 518          
 519          /*
 520           *--------------------------------------------------------------------------------
 521           * static void i2c_SlaveXmit(U8_T wrData, U8_T slvCmd)
 522           * Purpose : Putting the data into i2c transmitting register and setting the
 523           *           master's command and condition in I2C slave mode.
 524           * Params  : wrData - one byte data to transmit.
 525           *           slvCmd - slave command of the current byte data.
 526           * Returns : none
 527           * Note    : none
 528           *--------------------------------------------------------------------------------
 529           */
 530          static void i2c_SlaveXmit(U8_T wrData, U8_T slvCmd)
 531          {
 532   1              /* Record the globe flag of command condition */
 533   1              i2cActF = slvCmd;
 534   1              /* transmit the data byte */
 535   1              I2C_Cmd(SI_WR, I2CTR, &wrData);
 536   1              /* Order command to I2CCR */
 537   1              I2C_Cmd(SI_WR, I2CCR, &slvCmd);
 538   1      }
 539          
 540          /*
 541           *--------------------------------------------------------------------------------
 542           * static void i2c_SlaveRcvr(U8_T *rdData, U8_T slvCmd)
 543           * Purpose : Getting the receiving byte data in I2C slave mode.
 544           * Params  : *rdData - a pointer to store receiving data.
 545           *           slvCmd - slave command of the current byte data.
C51 COMPILER V9.00   I2C                                                                   05/08/2013 16:47:35 PAGE 10  

 546           * Returns : none
 547           * Note    : none
 548           *--------------------------------------------------------------------------------
 549           */
 550          static void i2c_SlaveRcvr(U8_T *rdData, U8_T slvCmd)
 551          {
 552   1              /* Record the globe flag of command condition */
 553   1              i2cActF = slvCmd;
 554   1              /* After ACK, read data from I2CRR */
 555   1              I2C_Cmd(SI_RD, I2CRR, rdData);
 556   1              /* Then, reply ACK to slave */
 557   1              I2C_Cmd(SI_WR, I2CCR, &slvCmd);
 558   1      }
 559          
 560          
 561          /* EXPORTED SUBPROGRAM BODIES */
 562          
 563          /*
 564           *--------------------------------------------------------------------------------
 565           * void I2C_Setup(U8_T ctrlCmd, U16_T preClk, U16_T axIdAddr)
 566           * Purpose : This function is used to setup the I2C module and
 567           *           to initial the globe values in this module.
 568           * Params  : ctrlCmd - control register value.
 569           *           preClk - a pre-scale parameter calculates the bus speed.
 570           *           axIdAddr - a device address of local AX11000 I2C module.
 571           * Returns : none
 572           * Note    : none
 573           *--------------------------------------------------------------------------------
 574           */
 575          void I2C_Setup(U8_T ctrlCmd, U16_T preClk, U16_T axIdAddr)
 576          {
 577   1              U16_T   i;
 578   1              /* Values initial */
 579   1              i2cCtrl = 0;
 580   1              i2cEndCond = 0;
 581   1              i2cActF = 0;
 582   1              i2cDataLen = 0;
 583   1              i2cDataLenCnt = 0;
 584   1              i2cPktDir = 0;
 585   1              ptI2cTxBuf = NULL;
 586   1              ptI2cRxBuf = NULL;
 587   1              i2cState = 0;
 588   1              for (i=0 ; i<SLV_MAX_PKT_NUM ; i++)
 589   1              {
 590   2                      i2cSlvRxPkt[i] = 0;
 591   2                      i2cSlvTxPkt[i] = 0;
 592   2              }
 593   1      
 594   1              /* Pre-scale Clock */
 595   1              I2CDR = (U8_T)(0x00FF & preClk);
 596   1              I2CDR = (U8_T)((0xFF00 & preClk) >> 8);
 597   1              I2CCIR = I2CCPR;
 598   1              /* Flipper device address for slave mode */
 599   1              I2CDR = (U8_T)(axIdAddr & 0x00FF);
 600   1              I2CDR = (U8_T)((axIdAddr & 0xFF00) >> 8);
 601   1              I2CCIR = I2CSDAR;
 602   1              /* Setup I2C mode */
 603   1              I2C_Cmd(SI_WR, I2CCTL, &ctrlCmd);
 604   1      }
 605          
 606          /*
 607           *--------------------------------------------------------------------------------
C51 COMPILER V9.00   I2C                                                                   05/08/2013 16:47:35 PAGE 11  

 608           * void I2C_Func(void)
 609           * Purpose : Handling serial interface I2C interrupt function.
 610           * Params  : none
 611           * Returns : none
 612           * Note    : The I2C_RLE_ING (reloading I2C EEPROM) bit and
 613           *           the I2C_BL_DONE (Bootloader done) bit must always be checked,
 614           *           whichever in master mode or slave mode.
 615           *--------------------------------------------------------------------------------
 616           */
 617          void I2C_Func(void)
 618          {
 619   1              U8_T    i2cStatus;
 620   1      
 621   1              I2C_Cmd(SI_RD, I2CCTL, &i2cCtrl);
 622   1      
 623   1              if (i2cCtrl & I2C_MASTER_MODE)
 624   1              {
 625   2                      EA = 0;
 626   2                      I2C_Cmd(SI_RD, I2CMSR, &i2cStatus);
 627   2                      EA = 1;
 628   2                      if (!(i2cStatus & I2C_RLE_ING) && (i2cStatus & I2C_BL_DONE))
 629   2                      {
 630   3                              if (i2cCtrl & I2C_MST_IE)
 631   3                              {
 632   4                                      if (i2cStatus & I2C_INTR_FLAG)
 633   4                                      {
 634   5                                              i2c_MstStatus(i2cStatus);
 635   5                                      }
 636   4                              }
 637   3                              else
 638   3                              {
 639   4                                      if (!(i2cStatus & I2C_TIP))
 640   4                                      {
 641   5                                              i2c_MstStatus(i2cStatus);
 642   5                                      }
 643   4                              }
 644   3                      }
 645   2              }
 646   1              else
 647   1              {
 648   2                      EA = 0;
 649   2                      I2C_Cmd(SI_RD, I2CMSR, &i2cStatus);
 650   2                      EA = 1;
 651   2      
 652   2                      if (!(i2cStatus & I2C_RLE_ING) && (i2cStatus & I2C_BL_DONE))
 653   2                      {
 654   3                              i2cStatus = 0;
 655   3                              EA = 0;
 656   3                              I2C_Cmd(SI_RD, I2CSSR, &i2cStatus);
 657   3                              EA = 1;
 658   3                              if (i2cCtrl & I2C_SLV_IE)
 659   3                              {
 660   4                                      if (i2cStatus & I2C_SLV_TXR_OK)
 661   4                                      {
 662   5                                              i2c_SlvStatus(i2cStatus);
 663   5                                      }
 664   4                              }
 665   3                              else
 666   3                              {
 667   4                                      if (i2cStatus & I2C_SLV_TXR_OK)
 668   4                                      {
 669   5                                              i2c_SlvStatus(i2cStatus);
C51 COMPILER V9.00   I2C                                                                   05/08/2013 16:47:35 PAGE 12  

 670   5                                      }
 671   4                              }
 672   3                      }
 673   2              }
 674   1      }
 675          
 676          /*
 677           *--------------------------------------------------------------------------------
 678           * void I2C_PktBuf(I2C_BUF *ptI2cBuf)
 679           * Purpose : Packeting a packet and transmitting the first byte
 680           * Params  : ptI2cBuf - a pointer stores the packet.
 681           * Returns : none
 682           * Note    : none
 683           *--------------------------------------------------------------------------------
 684           */
 685          void I2C_PktBuf(I2C_BUF *ptI2cBuf)
 686          {
 687   1              U8_T    firstAddr;
 688   1      
 689   1              I2C_Cmd(SI_RD, I2CCTL, &i2cCtrl); 
 690   1              if (i2cCtrl & I2C_MASTER_MODE) // I2C Master Mode
 691   1              {
 692   2                      i2cDataLenCnt = 0;
 693   2                      i2cEndCond = ptI2cBuf->I2cEnd;
 694   2                      i2cPktDir = ptI2cBuf->I2cDir;
 695   2                      i2cDataLen = ptI2cBuf->DataLen;
 696   2                                      
 697   2                              if (i2cCtrl & I2C_10BIT)
 698   2                              {
 699   3                                      firstAddr = ((U8_T)((ptI2cBuf->I2cAddr.TenBitAddr & 0x0300) >> 7) | 0xF0);
 700   3                                      if (i2cPktDir & I2C_XMIT)
 701   3                                      {
 702   4                                              ptI2cTxBuf = ptI2cBuf;
 703   4                                              i2c_MasterXmit(firstAddr & ~BIT0, I2C_MASTER_GO | I2C_CMD_WRITE | I2C_START_COND);
 704   4                                      }
 705   3                                      else
 706   3                                      {
 707   4                                              ptI2cRxBuf = ptI2cBuf;
 708   4                                              i2c_MasterXmit(firstAddr | BIT0, I2C_MASTER_GO | I2C_CMD_WRITE | I2C_START_COND);
 709   4                                      }
 710   3                              }
 711   2                              else
 712   2                              {
 713   3                                      firstAddr = ptI2cBuf->I2cAddr.SevenBitAddr << 1;
 714   3                                      if (i2cPktDir & I2C_XMIT)
 715   3                                      {
 716   4                                              ptI2cTxBuf = ptI2cBuf;
 717   4                                              i2c_MasterXmit(firstAddr & ~BIT0, I2C_MASTER_GO | I2C_CMD_WRITE | I2C_START_COND);
 718   4                                      }
 719   3                                      else
 720   3                                      {
 721   4                                              ptI2cRxBuf = ptI2cBuf;
 722   4                                              i2c_MasterXmit(firstAddr | BIT0, I2C_MASTER_GO | I2C_CMD_WRITE | I2C_START_COND);
 723   4                                      }
 724   3                              }
 725   2              }
 726   1              else // I2C Slave Mode
 727   1              {
 728   2                      if (ptI2cBuf->I2cDir & I2C_XMIT)
 729   2                      {
 730   3                              /* Get the slave data to transmit */
 731   3                              //ptI2cTxBuf->ptI2c = ??;
C51 COMPILER V9.00   I2C                                                                   05/08/2013 16:47:35 PAGE 13  

 732   3                              ptI2cBuf->DataLen = i2cDataLen;
 733   3                      }
 734   2                      else
 735   2                      {
 736   3                              /* packet the received data to upper layer */
 737   3                              ptI2cBuf->DataLen = i2cDataLen;
 738   3                      }
 739   2              }
 740   1      }
 741          
 742          /*
 743           *--------------------------------------------------------------------------------
 744           * BOOL I2C_FlagChk(U8_T chkBit)
 745           * Purpose : Checking the current state in I2C driver.
 746           * Params  : chkBit - the state bit to be checked.
 747           * Returns : TRUE - the state value meets the chkBit.
 748           * Note    : none
 749           *--------------------------------------------------------------------------------
 750           */
 751          BOOL I2C_FlagChk(U8_T chkBit)
 752          {
 753   1              if (i2cState & chkBit)
 754   1                      return TRUE;
 755   1              else
 756   1                      return FALSE;
 757   1      }
 758          
 759          /*
 760           *--------------------------------------------------------------------------------
 761           * void I2C_FlagEnb(U8_T enbBit)
 762           * Purpose : Setting the current state in I2C driver.
 763           * Params  : enbBit - the state bit to be set.
 764           * Returns : none
 765           * Note    : none
 766           *--------------------------------------------------------------------------------
 767           */
 768          void I2C_FlagEnb(U8_T enbBit)
 769          {
 770   1              i2cState = i2cState | enbBit;
 771   1      }
 772          
 773          /*
 774           *--------------------------------------------------------------------------------
 775           * void I2C_FlagClr(U8_T clrBit)
 776           * Purpose : Clearing the current state in I2C driver.
 777           * Params  : clrBit - the state bit to be cleared.
 778           * Returns : none
 779           * Note    : none
 780           *--------------------------------------------------------------------------------
 781           */
 782          void I2C_FlagClr(U8_T clrBit)
 783          {
 784   1              i2cState = i2cState & ~clrBit;
 785   1      }
 786          
 787          /*
 788           *--------------------------------------------------------------------------------
 789           * void I2C_Cmd(U8_T cmdType, U8_T i2cCmdIndex, U8_T *i2cData)
 790           * Purpose : Accessing the I2C interface indirectly through I2C's SFR.
 791           * Params  : cmdType - command type of writing or reading.
 792           *           i2cCmdIndex - I2C register address.
 793           *           *i2cData - a pointer store the data.
C51 COMPILER V9.00   I2C                                                                   05/08/2013 16:47:35 PAGE 14  

 794           * Returns : none
 795           * Note    : none
 796           *--------------------------------------------------------------------------------
 797           */
 798          void I2C_Cmd(U8_T cmdType, U8_T i2cCmdIndex, U8_T *i2cData)
 799          {
 800   1              if (cmdType == SI_WR)
 801   1              {
 802   2                      I2CDR = *i2cData;
 803   2                      I2CCIR = i2cCmdIndex;
 804   2              }
 805   1              else if (cmdType == SI_RD)
 806   1              {
 807   2                      I2CCIR = i2cCmdIndex;
 808   2                      *i2cData = I2CDR;
 809   2              }
 810   1      }
 811          
 812          /*
 813           *--------------------------------------------------------------------------------
 814           * void I2C_Post(void)
 815           * Purpose :
 816           * Params  :
 817           * Returns :
 818           * Note    :
 819           *--------------------------------------------------------------------------------
 820           */
 821          void I2C_Post(void)
 822          {
 823   1      }
 824          
 825          
 826          /* End of i2c.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2076    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    143      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
