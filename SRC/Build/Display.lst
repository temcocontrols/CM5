C51 COMPILER V9.00   DISPLAY                                                               05/08/2013 16:47:36 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE DISPLAY
OBJECT MODULE PLACED IN .\Build\Display.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE display\Display.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\S
                    -RC\FreeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\SR
                    -C\UART\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;.
                    -.\SRC\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management\
                    -;..\SRC\dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule;..\SRC\program;..\SRC\Sca
                    -n) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\Display.lst) OBJECT(.\Build\Display.obj)

line level    source

   1          #include "LCD.h"
   2          #include "font.h"
   3          #include "string.h"
   4          #include "display.h"
   5          #include "main.h"
   6          #include <ctype.h> 
   7          #include "font.h"         
   8          #include "key.h"
   9          #include "serial.h"
  10          #include "commsub.h"
  11          
  12          
  13          #define DisProcess_STACK_SIZE   ((unsigned portSHORT)1024)
  14          #define UpdateSta_STACK_SIZE    ((unsigned portSHORT)1024)
  15          
  16          
  17          #define         MENU_NUM                8
  18          
  19          #define         IDLE_LEN                4
  20          #define         MAIN_MENU_LEN   3
  21          #define         MAX_OUT_LEN     10
  22          #define         MAX_IN_LEN          26
  23          //#define       SEN_MENU_LEN    10
  24          #define         TST_MENU_LEN    13
  25          #define         MAX_SUB_NUM             8    
  26          //xTaskHandle xKeyTask;
  27          extern xQueueHandle xKeyQueue;
  28          extern unsigned int temperature[10];
  29          extern bit flag_control_by_button;
  30          
  31          xTaskHandle xDisplayTask;               /* handle for display task */
  32          xTaskHandle xDisplayCheckTask;  /* handle for check display status task */
  33          
  34          xSemaphoreHandle xSemaphore_Display;  /* protect "Display_Check_Status" roution */
  35          xQueueHandle xBtnQueue;                           /* trasmit button value when displaying ITEM */
  36          xSemaphoreHandle xSemaphore_LCD;          /* protect "LCD" roution */
  37          
  38          static U16_T count_status = 0; /* count for going back to idle mode, 1 min */
  39          U8_T far LcdStr[5][21]; /* buffer for display */
  40          U8_T data by_Status = 0;
  41          unsigned char data by_tstat_index = 0;
  42          unsigned char far by_Idle_index = 0;
  43          unsigned char far by_menu_index = 0;
  44          unsigned char far by_submenu_index = 0;
  45          unsigned char far by_set_index = 0;
  46          
  47          unsigned char far sub_menu_len = 0;
  48          unsigned char far Value_Range[36] = 0;
  49          unsigned char far Set_Value = 0;
  50          unsigned char far by_Cur_sub = 0;
C51 COMPILER V9.00   DISPLAY                                                               05/08/2013 16:47:36 PAGE 2   

  51          char* menu = NULL;
  52          
  53          U8_T temp_value = 0;
  54          bit flag_set = 0;
  55          bit flag_enter_set = 0;
  56          bit flag_send = 0;
  57          
  58          char Comm_Register = 0;
  59          //extern unsigned int data temperature[10];
  60                          // control Tstat using T3000 or CM5's button
  61          
  62          
  63          void Display_Save_Value(unsigned char sub,unsigned char index);
  64          void Display_SubMenu(unsigned char sub,unsigned char index);
  65          
  66          
  67          const char* Main_Menu[MAIN_MENU_LEN] = 
  68          {
  69                  " Output",
  70                  " Input",
  71                  " Tstat info"
  72          };
  73          
  74          char far In_Menu[MAX_IN_LEN][14];
  75          char far Out_Menu[MAX_OUT_LEN][14];
  76          
  77          
  78          typedef enum 
  79          {
  80                  E_MODBUS_ID,
  81                  E_TEMPER,
  82                  E_MODE,
  83                  E_SET_POINT,
  84                  E_COOL_SP,
  85                  E_HEAT_SP,
  86                  E_OCC,
  87                  E_OUT_STATUS,
  88                  E_NIGHT_HEAT_DB,
  89                  E_NIGHT_COOL_DB,
  90                  E_NIGHT_HEAT_SP,
  91                  E_NIGHT_COOL_SP,
  92                  E_OVER_RIDE_TIME,       
  93          }Tst_Menu_index;
  94          
  95          const char TST_Menu[TST_MENU_LEN][15] =
  96          {
  97                  "Modbus ID Addr",
  98                  "Temperature   ",
  99                  "Mode          ",
 100                  "Set Point     ",
 101                  "Cool Set Point",
 102                  "Heat Set Point",
 103                  "Occupied      ",
 104                  "Output Status ",
 105                  "Night Heat DB ",
 106                  "Night Cool DB ",
 107                  "Night Heat SP ",
 108                  "Night Cool SP ",
 109          //      "Product Model ",
 110                  "Over Ride Time",
 111          
 112          }; 
C51 COMPILER V9.00   DISPLAY                                                               05/08/2013 16:47:36 PAGE 3   

 113          
 114          typedef enum
 115          {
 116                  /*D_START = 0,*/D_IDLE = 0,D_MENU,D_SUBMENU/*,D_ITEMD_OUTPUT,D_INPUT,D_SENSOR,D_TSTAT_TEMP,D_TSTAT_MODE,D
             -_TSTAT_SETPOINT,D_SET_MODE,D_SET_PRI,*/
 117          };
 118          
 119          
 120          
 121          
 122          void vStartDisplayTasks(U8_T uxPriority)
 123          {
 124   1              sTaskCreate(Display_Process, (const signed portCHAR * const)"display_task",DisProcess_STACK_SIZE, NULL, u
             -xPriority, (xTaskHandle *)&xDisplayTask);
 125   1              sTaskCreate(Display_Check_Task, (const signed portCHAR * const)"display_check",UpdateSta_STACK_SIZE, NULL
             -, uxPriority + 1, (xTaskHandle *)&xDisplayCheckTask);
 126   1              vSemaphoreCreateBinary(xSemaphore_Display);
 127   1              xBtnQueue = xQueueCreate(3,sizeof(U8_T));
 128   1              vSemaphoreCreateBinary(xSemaphore_LCD);
 129   1              menu = *menu_name;
 130   1      }
 131          
 132          
 133          void Display_Initial_Data(void)
 134          { 
 135   1              by_Status = D_IDLE;
 136   1              
 137   1              Display_Clear_Screen();
 138   1      
 139   1              Lcd_Show_String(1,1,"CM5",NORMAL,3);
 140   1              Lcd_Show_String(2,1,"TEMCO LTD.,",NORMAL,10);
 141   1              by_submenu_index = 0;
 142   1      //      DELAY_Us(5000);         DELAY_Us(5000); DELAY_Us(5000); DELAY_Us(5000); 
 143   1      }
 144          
 145          
 146          
 147          /*
 148           *--------------------------------------------------------------------------------
 149           * void Display_Clear_Screen(void)
 150           * Purpose : clear the display buffer
 151           * Params  : none
 152           * Returns : none
 153           * Note    :
 154           *--------------------------------------------------------------------------------
 155           */      
 156          void Display_Clear_Screen(void)
 157          {
 158   1      /*      U8_T i,j;
 159   1              for(i = 0;i < 5;i++)            
 160   1                      for(j = 0;j < 21;j++)
 161   1                              LcdStr[i][j] = ' ';     */ 
 162   1      //      for( i = 0;i < 5;i++)   ptrLcdStr[i] = &LcdStr[i];      
 163   1              Display_Clear_Space();
 164   1      //      Display_Refresh();
 165   1              Lcd_All_Off();
 166   1      }
 167          
 168          
 169          
 170          /*
 171           *--------------------------------------------------------------------------------
C51 COMPILER V9.00   DISPLAY                                                               05/08/2013 16:47:36 PAGE 4   

 172           * void Display_Clear_Space(void)
 173           * Purpose : clear the left space 
 174           * Params  : 
 175           * Returns : 
 176           * Note    : none
 177           *--------------------------------------------------------------------------------
 178           */     
 179          void Display_Clear_Space(void)
 180          {
 181   1              U8_T loop,line;
 182   1              /* the lcd have a left frame, clear it to avoid srambled display */
 183   1              for(line = 0; line < 5;line++)
 184   1              {
 185   2                      Lcd_Set_X_Addr(0);
 186   2                      Lcd_Set_Y_Addr(line * 2); 
 187   2                      for(loop = 0;loop < 6;loop++) Lcd_Write_Byte(0); 
 188   2                      Lcd_Set_X_Addr(0);
 189   2                      Lcd_Set_Y_Addr(line * 2+1);
 190   2                      for(loop = 0;loop < 6;loop++) Lcd_Write_Byte(0); 
 191   2              }
 192   1      }
 193          
 194          #if 0
              /*
               *--------------------------------------------------------------------------------
               * char* Display_Format(U16_T number)
               * Purpose : tranfer num to string
               * Params  : number - the source data  (range:0 - 9999)
               * Returns : return string
               * Note    : none
               *--------------------------------------------------------------------------------
               */      
              char* Display_Format(U16_T number)
              {
                      char loop = 0;
                      char num[5];
                      char length;
                      //number = number / div;
                      for(loop = 0;loop < 5;loop++)   num[loop] = 0;
              
                      if(number >= 1000)      length = 4;
                      else if(number >= 100)  length = 3;
                      else if(number >= 10)   length = 2;
                      else length = 1;
              
                      /* using num[] buffer to store the every num */
                      
                      num[0] = number / 1000;                 number = number % 1000;
                      num[1] = number / 100;          number = number % 100;
                      num[2] = number / 10;           number = number % 10;
                      num[3] = number;
              
                      /* check num[], put correct character to every posion */
              
                      if(num[0] > 0)  /* if number is bigger than 999 */
                      {
                              for(loop = 1;loop < 4;loop++)   num[loop] = num[loop] + 0x30;
                      }
                      else if(num[1] > 0)  /* if number is bigger than 99 */
                      {
                              num[0] = ' ';
                              for(loop = 1;loop < 4;loop++)   num[loop] = num[loop] + 0x30;           
C51 COMPILER V9.00   DISPLAY                                                               05/08/2013 16:47:36 PAGE 5   

                      }
                      else if(num[2] > 0)      /* if number is bigger than 9 */
                      {
                              num[0] = ' ';
                              num[1] = ' ';
                              for(loop = 2;loop < 4;loop++)   num[loop] = num[loop] + 0x30;
                      }
                      else if(num[3] > 0)   /* if number is less than 10 */
                      {
                              num[0] = ' ';
                              num[1] = ' ';
                              num[2] = ' ';
                              for(loop = 3;loop < 4;loop++)   num[loop] = num[loop] + 0x30;
                      }
                      num[4] = '\0';
                      return num;
              }
              
              #endif
 253          
 254          void Display_Check_Status(void)
 255          {
 256   1              U8_T loop;
 257   1              if(by_Key != 0) count_status = 0; /* if press any key,count_Status is 0 */
 258   1              if(by_Status == D_IDLE) 
 259   1              {       
 260   2                      if(by_Key == K_PROGRAM)         {by_Status = D_MENU; by_Idle_index = 0;stop_scrolling();}
 261   2                      if(by_Key == K_SELECT)          
 262   2                      {       
 263   3                              
 264   3                              if(by_Idle_index < IDLE_LEN - 1)  /* idle menu have 2 pages now , press this button to enter next page 
             -*/
 265   3                                      by_Idle_index++;
 266   3                              else by_Idle_index = 0;                          
 267   3                      }
 268   2              }
 269   1              else if(by_Status == D_MENU) 
 270   1              {
 271   2                      if(by_Key == K_PROGRAM)         {       by_Status = D_IDLE; by_menu_index = 0;Lcd_All_Off(); start_scrolling();}
 272   2                      if(by_Key == K_SELECT)          /* enter sub-menu */
 273   2                      {       
 274   3                              by_Status = D_SUBMENU; 
 275   3                              flag_enter_set = 0;
 276   3                              by_Cur_sub = 0;
 277   3                              by_submenu_index = 0;
 278   3                      }
 279   2                      if(by_Key == K_UP)      {       if(by_menu_index < MAIN_MENU_LEN - 1)           by_menu_index++; else by_menu_index = 0; }
 280   2                      if(by_Key == K_DOWN)    {       if(by_menu_index > 0)           by_menu_index--; else by_menu_index = MAIN_MENU_LEN - 1; }
 281   2              }
 282   1              else if(by_Status == D_SUBMENU) 
 283   1              {
 284   2                      if(by_Key == K_PROGRAM)         {       by_Status = D_MENU; by_submenu_index = 0;Display_Save_Value(by_menu_index,by_
             -submenu_index);}      // tbd:
 285   2                      if(by_Key == K_SELECT)          /* enter sub-menu */
 286   2                      {       
 287   3                              if(sub_menu_len > 0)
 288   3                              {
 289   4                                      if(by_submenu_index < sub_menu_len - 1)         by_submenu_index++; 
 290   4                                      else by_submenu_index = 0;
 291   4                              }
 292   3                      }
 293   2                      if(by_Key == K_UP && (Value_Range[by_submenu_index] > 0))       
C51 COMPILER V9.00   DISPLAY                                                               05/08/2013 16:47:36 PAGE 6   

 294   2                      {
 295   3                              if((by_menu_index == 2) && (by_submenu_index == 0))    // sub tstat 
 296   3                              {
 297   4                                      if(Set_Value < sub_no - 1)
 298   4                                              Set_Value++;    
 299   4                              }
 300   3                              else
 301   3                              /*if(Set_Value < Value_Range[by_submenu_index])*/ 
 302   3                              Set_Value++; /*else Set_Value = 0;*/ 
 303   3                              Display_Save_Value(by_menu_index,by_submenu_index);     
 304   3                      }
 305   2                      if(by_Key == K_DOWN && (Value_Range[by_submenu_index] > 0))     
 306   2                      { 
 307   3                              if(Set_Value > 0)               Set_Value--; /*else Set_Value = Value_Range;*/ 
 308   3                              Display_Save_Value(by_menu_index,by_submenu_index);
 309   3                      }
 310   2              }
 311   1      }
*** WARNING C280 IN LINE 256 OF DISPLAY\DISPLAY.C: 'loop': unreferenced local variable
 312                  
 313          
 314          
 315          void Display_Check_Task(void) reentrant
 316          {
 317   1              portTickType xDelayPeriod = ( portTickType ) 50 / portTICK_RATE_MS; //  100 
 318   1              for (;;)
 319   1              {
 320   2                      Test[9]++;
 321   2                      vTaskDelay(xDelayPeriod);       
 322   2      
 323   2                      #if 1
 324   2      
 325   2                      while( ucQueueMessagesWaiting( xKeyQueue ) )
 326   2                      {
 327   3                              
 328   3                              if( cQueueReceive( xKeyQueue, &by_Key, ( portTickType ) 0 ) == pdPASS )
 329   3                              { /* any button is pressed */
 330   4                                      if(cSemaphoreTake( xSemaphore_Display, ( portTickType ) 10 ) == pdTRUE)
 331   4                                      {       
 332   5                                              Display_Check_Status(); 
 333   5                                              cSemaphoreGive( xSemaphore_Display );
 334   5                                      }
 335   4                              }
 336   3                              
 337   3                      } 
 338   2                      #endif
 339   2      
 340   2              }
 341   1      }
 342          
 343          
 344          
 345          void Update_AI(void);
 346          /* run this roution per 100ms */
 347          U8_T count_task = 0;
 348          extern U8_T flag_protect_lcd;
 349          void Display_Process(void) reentrant
 350          {
 351   1              portTickType xDelayPeriod = ( portTickType ) 100 / portTICK_RATE_MS; //  100 
 352   1      //    portTickType xLastWakeTime = xTaskGetTickCount();
 353   1              U8_T first_Status,second_Status;
 354   1      
C51 COMPILER V9.00   DISPLAY                                                               05/08/2013 16:47:36 PAGE 7   

 355   1              for (;;)
 356   1              {       
 357   2                      char loop;
 358   2                      static char pre_Status = 0;
 359   2                      vTaskDelay(xDelayPeriod);
 360   2      
 361   2                      #if 1
 362   2                      if(count_task == 0)
 363   2                      {
 364   3                      #if 1
 365   3                              second_Status = by_Status;
 366   3                              /* if change status, clear screen and initial lcd again to avoid messed display */
 367   3                              if(first_Status != second_Status)       
 368   3                              {
 369   4                                      Lcd_Initial();  
 370   4                                      Display_Clear_Screen();  //  clear display
 371   4                                      first_Status = second_Status;
 372   4                                      count_status = 0;
 373   4                              }
 374   3                              else  
 375   3                              {/* keep status for 1 min, go to idle mode */
 376   4                              
 377   4                                      count_status++;
 378   4                                      if(count_status >= 1200) //1200 * 50 1min
 379   4                                      {       
 380   5                                      /* if current display is IDLE, initial lcd to avoid messed display */
 381   5                                              if(by_Status == D_IDLE) {/*Lcd_Initial();Lcd_All_Off();*/}
 382   5                                              else if(by_Status == D_SUBMENU || by_Status == D_MENU)
 383   5                                              {
 384   6                                                      by_Status = D_IDLE;                                     
 385   6                                              } 
 386   5                                              start_scrolling();
 387   5                                              count_status = 0;
 388   5                                      }
 389   4                              }
 390   3                      update_message_context();
 391   3                      scrolling_message();  
 392   3                      
 393   3                      Test[8]++;
 394   3      
 395   3                      if(by_Status == D_IDLE)         Display_Idle(by_Idle_index);
 396   3                      else if(by_Status == D_MENU)            Display_Menu(by_menu_index);
 397   3                      else if(by_Status == D_SUBMENU)         //Lcd_Show_String(3,1,"sub menu ,",NORMAL,10); 
 398   3                              Display_SubMenu(by_menu_index,by_submenu_index); 
 399   3                      
 400   3                      #endif
 401   3                      
 402   3              
 403   3                      
 404   3                      count_task = 1;
 405   3      
 406   3      
 407   3                      }
 408   2                      else if(count_task == 1)
 409   2                      {       
 410   3                              Test[4]++;
 411   3                              //flag_protect_lcd = 1;         
 412   3                              Update_AI();  //flag_protect_lcd = 0;
 413   3                              count_task = 0;
 414   3                              
 415   3                      }
 416   2                      #endif
C51 COMPILER V9.00   DISPLAY                                                               05/08/2013 16:47:36 PAGE 8   

 417   2      
 418   2              }
 419   1      
 420   1      }
*** WARNING C280 IN LINE 357 OF DISPLAY\DISPLAY.C: 'loop': unreferenced local variable
*** WARNING C280 IN LINE 358 OF DISPLAY\DISPLAY.C: 'pre_Status': unreferenced local variable
 421          
 422          void Display_Save_Value(unsigned char sub,unsigned char index)
 423          {
 424   1              switch(sub) 
 425   1              {
 426   2                      case 0:  
 427   2                              if(Set_Value)   
 428   2                                      DO_Value |= (0x01 << index);
 429   2                              else     
 430   2                                      DO_Value &= ~(0x01 << index);
 431   2                              break;
 432   2                      case 1:  
 433   2                      /* input menu - sub DI DI*/
 434   2                              DI2_Value |= Set_Value << (index - sub_no);
 435   2                              break;
 436   2                      case 2:  
 437   2                              if(index == E_MODBUS_ID)          
 438   2                                      by_Cur_sub = Set_Value;
 439   2                              else if(index == E_SET_POINT)
 440   2                              {
 441   3                                      tstat_setpoint[by_Cur_sub] = Set_Value;
 442   3                                      
 443   3                                      flag_control_by_button = 1;     
 444   3                                      WRT_Tst_Reg = WRITE_ROOM_SETPOINT;
 445   3                                      WRT_Tst_ID = sub_addr[by_Cur_sub];
 446   3                              //      Com_Tstat(WRITE_ROOM_SETPOINT,sub_addr[by_Cur_sub]);
 447   3                              //      flag_control_by_button = 0;
 448   3                              }
 449   2                              else if(index == E_COOL_SP)
 450   2                              {
 451   3                                      tstat_cool_setpoint[by_Cur_sub] = Set_Value;
 452   3                                      WRT_Tst_Reg = WRITE_COOLING_SETPOINT;
 453   3                                      WRT_Tst_ID = sub_addr[by_Cur_sub];
 454   3                                      flag_control_by_button = 1;
 455   3                              //      Com_Tstat(WRITE_COOLING_SETPOINT,sub_addr[by_Cur_sub]);
 456   3                              //      flag_control_by_button = 0;
 457   3                              }
 458   2                              else if(index == E_HEAT_SP)
 459   2                              {
 460   3                                      tstat_heat_setpoint[by_Cur_sub] = Set_Value;
 461   3                                      WRT_Tst_Reg = WRITE_HEATTING_SETPOINT;
 462   3                                      WRT_Tst_ID = sub_addr[by_Cur_sub];
 463   3                                      flag_control_by_button = 1;
 464   3                              //      Com_Tstat(WRITE_HEATTING_SETPOINT,sub_addr[by_Cur_sub]);
 465   3                              //      flag_control_by_button = 0;
 466   3                              } 
 467   2                              else if(index == E_NIGHT_HEAT_DB)
 468   2                              {
 469   3                                      tstat_night_heat_db[by_Cur_sub] = Set_Value;
 470   3                                      WRT_Tst_Reg = WRITE_NIGHT_HEAT_DB;
 471   3                                      WRT_Tst_ID = sub_addr[by_Cur_sub];
 472   3                                      flag_control_by_button = 1;
 473   3                              //      Com_Tstat(WRITE_NIGHT_HEAT_DB,sub_addr[by_Cur_sub]);
 474   3                              //      flag_control_by_button = 0;
 475   3                              }
 476   2                              else if(index == E_NIGHT_COOL_DB)
C51 COMPILER V9.00   DISPLAY                                                               05/08/2013 16:47:36 PAGE 9   

 477   2                              {
 478   3                                      tstat_night_cool_db[by_Cur_sub] = Set_Value;
 479   3                                      flag_control_by_button = 1;
 480   3                                      WRT_Tst_Reg = WRITE_NIGHT_COOL_DB;
 481   3                                      WRT_Tst_ID = sub_addr[by_Cur_sub];
 482   3                              //      Com_Tstat(WRITE_NIGHT_COOL_DB,sub_addr[by_Cur_sub]);
 483   3                              //      flag_control_by_button = 0;
 484   3                              }
 485   2                              else if(index == E_NIGHT_HEAT_SP) 
 486   2                              {
 487   3                                      tstat_night_heat_sp[by_Cur_sub] = Set_Value;
 488   3                                      flag_control_by_button = 1;
 489   3                                      WRT_Tst_Reg = WRITE_NIGHT_HEAT_SP;
 490   3                                      WRT_Tst_ID = sub_addr[by_Cur_sub];
 491   3                              //      Com_Tstat(WRITE_NIGHT_HEAT_SP,sub_addr[by_Cur_sub]);
 492   3                              //      flag_control_by_button = 0;
 493   3                              }
 494   2                              else if(index == E_NIGHT_COOL_SP)
 495   2                              {
 496   3                                      tstat_night_cool_sp[by_Cur_sub] = Set_Value;
 497   3                                      flag_control_by_button = 1;
 498   3                                      WRT_Tst_Reg = WRITE_NIGHT_COOL_SP;
 499   3                                      WRT_Tst_ID = sub_addr[by_Cur_sub];
 500   3                              //      Com_Tstat(WRITE_NIGHT_COOL_SP,sub_addr[by_Cur_sub]);
 501   3                              //      flag_control_by_button = 0;
 502   3                              }
 503   2                              else if(index == E_OVER_RIDE_TIME)
 504   2                              {
 505   3                                      tstat_over_ride[by_Cur_sub] = Set_Value;
 506   3                                      flag_control_by_button = 1;
 507   3                                      WRT_Tst_Reg = WRITE_HEATTING_SETPOINT;
 508   3                                      WRT_Tst_ID = sub_addr[by_Cur_sub];
 509   3                              //      Com_Tstat(WRITE_HEATTING_SETPOINT,sub_addr[by_Cur_sub]);
 510   3                              //      flag_control_by_button = 0;
 511   3                              }
 512   2                              break;
 513   2                      default: break;
 514   2              }
 515   1      
 516   1      }
 517          
 518          void Display_Idle(U8_T index)
 519          {
 520   1              static char pre_status = 0;
 521   1              static char count = 0;
 522   1              static char i = 0;
 523   1      
 524   1              if(pre_status != index)
 525   1              {       
 526   2                      Display_Clear_Screen();
 527   2                      pre_status = index;
 528   2              }
 529   1              if(index == 0)
 530   1              {
 531   2                      if(count < dis_temp_interval) 
 532   2                              count++;
 533   2                      else 
 534   2                      {
 535   3                              count = 0;
 536   3                              Lcd_Show_String(0,0,menu_name[dis_temp_seq[i] + 26] ,NORMAL,10);
 537   3                              if(unit == 0)   
 538   3                              {
C51 COMPILER V9.00   DISPLAY                                                               05/08/2013 16:47:36 PAGE 10  

 539   4                                      Lcd_Show_String(1,18,"~",NORMAL,3);
 540   4                                      print_number(temperature[dis_temp_seq[i]], 1);
 541   4                              }
 542   3                              else//(Modbus_Data.unit == UNIT_F)
 543   3                              {
 544   4                                      Lcd_Show_String(1,18,"|",NORMAL,3);
 545   4                                      print_number(temperature[dis_temp_seq[i]] * 9 / 5 + 320, 1);
 546   4                              }
 547   3      
 548   3                              if(i < dis_temp_num - 1)                        
 549   3                                      i++;
 550   3                              else 
 551   3                                      i = 0;  
 552   3                      
 553   3                      }
 554   2      
 555   2              }
 556   1              else if(index == 1)
 557   1              {
 558   2                      Lcd_Show_String(0,5,"CM5 DEMO  ",NORMAL,21);
 559   2                      Lcd_Show_String(1,1,"MOD  ",NORMAL,5);  
 560   2                      if(DO_SoftSwitch == OFF)
 561   2                              Lcd_Show_String(1,5,"OFF  ",NORMAL,5);  //Display_Str(0,4,"OFF ",4);
 562   2                      else if(DO_SoftSwitch == ON)
 563   2                              Lcd_Show_String(1,5,"ON  ",NORMAL,5);//Display_Str(0,4,"ON  ",4);
 564   2                      else if(DO_SoftSwitch == TIMER)
 565   2                              Lcd_Show_String(1,5,"TIMER  ",NORMAL,5);//Display_Str(0,4,"TIME",4);
 566   2      
 567   2                      Lcd_Show_String(2,1,"PRI  ",NORMAL,5); 
 568   2                      Lcd_Show_Data (2,6,Priority,0,1);
 569   2                      
 570   2                       
 571   2                      Lcd_Show_String(3,1,"TIME      :",NORMAL,12); 
 572   2                      Lcd_Show_Data (3,6,(Priority * 60 - count_priority) / 60,0,1);
 573   2                      Lcd_Show_Data (3,12,(Priority * 60 - count_priority) % 60,0,1);
 574   2              }
 575   1              else if(index == 2) // relay value  
 576   1              {        
 577   2                      
 578   2                      Lcd_Show_String(0,1,"RELAY Value  ",NORMAL,20);         
 579   2                      Lcd_Show_String(1,0," OUT1",(DO_Value & (0x01 << 0)) >> 0,5);
 580   2                      Lcd_Show_String(1,6,"OUT2",(DO_Value & (0x01 << 1)) >> 1,4);
 581   2                      Lcd_Show_String(1,11,"OUT3",(DO_Value & (0x01 << 2)) >> 2,4);
 582   2                      Lcd_Show_String(1,16,"OUT4",(DO_Value & (0x01 << 3)) >> 3,4);           
 583   2                      Lcd_Show_String(2,0," OUT5",(DO_Value & (0x01 << 4)) >> 4,5);
 584   2                      Lcd_Show_String(2,6,"OUT6",(DO_Value & (0x01 << 5)) >> 5,4);
 585   2                      Lcd_Show_String(2,11,"OUT7",(DO_Value & (0x01 << 6)) >> 6,4);
 586   2                      Lcd_Show_String(2,16,"OUT8",(DO_Value & (0x01 << 7)) >> 7,4);
 587   2                      Lcd_Show_String(3,0," OUT9",(DO_Value & (0x01 << 8)) >> 8,5);
 588   2                      Lcd_Show_String(3,6,"OUT10",(DO_Value & (0x01 << 9)) >> 9,5);
 589   2              }
 590   1              else if(index == 3)      // di input value
 591   1              {
 592   2                      Lcd_Show_String(0,1,"DI Input  ",NORMAL,20);
 593   2                      Lcd_Show_String(1,0," DI1", (DI2_Value & (0x01 << 0)) >> 0,5);
 594   2                      Lcd_Show_String(1,6,"DI2",(DI2_Value & (0x01 << 0)) >> 0,4);
 595   2                      Lcd_Show_String(1,11,"DI3",(DI2_Value & (0x01 << 0)) >> 0,4);
 596   2                      Lcd_Show_String(1,16,"DI4",(DI2_Value & (0x01 << 0)) >> 0,4);           
 597   2                      Lcd_Show_String(2,0," DI5", (DI2_Value & (0x01 << 0)) >> 0,5);
 598   2                      Lcd_Show_String(2,6,"DI6",(DI2_Value & (0x01 << 0)) >> 0,4);
 599   2                      Lcd_Show_String(2,11,"DI7",(DI2_Value & (0x01 << 0)) >> 0,4);
 600   2                      Lcd_Show_String(2,16,"DI8",(DI2_Value & (0x01 << 0)) >> 0,4);
C51 COMPILER V9.00   DISPLAY                                                               05/08/2013 16:47:36 PAGE 11  

 601   2                      Lcd_Show_String(3,0," ", NORMAL,21);
 602   2              }
 603   1      }
 604          
 605          
 606          void Display_SubMenu(unsigned char sub,unsigned char index)
 607          {
 608   1              unsigned int PTRtemp[26];
 609   1      
 610   1              unsigned char  flag_high_light; 
 611   1              unsigned char  start_line;
 612   1              unsigned char  loop1;
 613   1              unsigned int tempValue;
 614   1              unsigned char str_len;
 615   1              unsigned char i;
 616   1      
 617   1              Lcd_Show_String(0,0,"MAIN BOARD MENU  ",NORMAL,21);
 618   1              if(sub == 2 && sub_no == 0) 
 619   1              {
 620   2                      Lcd_Show_String(1,0,"                    ",NORMAL,21);
 621   2                      Lcd_Show_String(2,0,"                    ",NORMAL,21);
 622   2                      Lcd_Show_String(3,0," No TSTAT CONNECTED ",NORMAL,21);
 623   2                      Lcd_Show_String(4,0,"                    ",NORMAL,21);
 624   2                      return;
 625   2              }
 626   1              
 627   1              if(sub == 0)
 628   1              {                       
 629   2                      str_len = 14;
 630   2                      sub_menu_len = 0;
 631   2                              
 632   2                      for(i = 0;i < 10;i++)   
 633   2                      {                               
 634   3                              memcpy(In_Menu[sub_menu_len],menu_name[sub_menu_len],10);
 635   3                              PTRtemp[sub_menu_len] = (DO_Value & (0x01 << i)) >> i;
 636   3                              Value_Range[sub_menu_len] = 1;
 637   3                              sub_menu_len++;
 638   3                      }
 639   2                      menu = *In_Menu; 
 640   2      
 641   2              }
 642   1              
 643   1              else if(sub == 1)
 644   1              {
 645   2                      U8_T loop = 0;
 646   2                      sub_menu_len = 0;
 647   2                       
 648   2                      for(i = 0;i < sub_no;i++)       
 649   2                      {
 650   3                              PTRtemp[sub_menu_len] = sub_addr[i];
 651   3                              Value_Range[sub_menu_len] = 0;
 652   3      
 653   3                              memcpy(In_Menu[sub_menu_len],menu_name[i + 10],14);
 654   3                              sub_menu_len++;
 655   3                              loop++;
 656   3      
 657   3                      }
 658   2      
 659   2                      loop = 0; 
 660   2                      for(i = 0;i < 8;i++)
 661   2                              if(DI_Enable & (0x01 << i))
 662   2                              {
C51 COMPILER V9.00   DISPLAY                                                               05/08/2013 16:47:36 PAGE 12  

 663   3                                      PTRtemp[sub_menu_len] =  (DI2_Value & (0x01 << i)) >> i;
 664   3                                      Value_Range[sub_menu_len] = 1;
 665   3                                      memcpy(In_Menu[sub_menu_len],menu_name[i + 18],14);
 666   3                                      sub_menu_len++;
 667   3                                      loop++;
 668   3                              }
 669   2                      loop = 0; 
 670   2                      for(i = 0;i < 10;i++)
 671   2                              if(AI_Enable & (0x01 << i))     
 672   2                              {
 673   3                                      PTRtemp[sub_menu_len] =  temperature[i];
 674   3                                      Value_Range[sub_menu_len] = 0;
 675   3      
 676   3                                      memcpy(In_Menu[sub_menu_len],menu_name[i + 26],14); 
 677   3                                      sub_menu_len++; 
 678   3                                      loop++;
 679   3                              }
 680   2                      str_len = 14;
 681   2                      //tempValue = DI2_Value;        //      Set_Value = (tempValue & (0x01 << index)) >> index;
 682   2                      //Value_Range = 1;
 683   2                      if(sub_menu_len > 0)
 684   2                              menu = *In_Menu;
 685   2      //              Test[30] = sub_menu_len;        
 686   2              
 687   2              }
 688   1              else if(sub == 2)
 689   1              {       
 690   2                      menu = *TST_Menu; 
 691   2                      sub_menu_len = 13;  
 692   2                      str_len = 15;
 693   2                      PTRtemp[0] = sub_addr[by_Cur_sub];        Value_Range[0] = sub_no - 1;
 694   2                      PTRtemp[1] = tstat_temperature[by_Cur_sub];        Value_Range[1] = 0;
 695   2                      PTRtemp[2] = tstat_mode[by_Cur_sub];               Value_Range[2] = 1;
 696   2                      PTRtemp[3] = tstat_setpoint[by_Cur_sub];           Value_Range[3] = 1;
 697   2                      PTRtemp[4] = tstat_cool_setpoint[by_Cur_sub];  Value_Range[4] = 1;
 698   2                      PTRtemp[5] = tstat_heat_setpoint[by_Cur_sub];  Value_Range[5] = 1;
 699   2                      PTRtemp[6] = (tstat_occupied & (0x01 << by_Cur_sub)) >> by_Cur_sub;   Value_Range[6] = 0;
 700   2                      PTRtemp[7] = tstat_output_state[by_Cur_sub];   Value_Range[7] = 0;
 701   2                      PTRtemp[8] = tstat_night_heat_db[by_Cur_sub];  Value_Range[8] = 1;
 702   2                      PTRtemp[9] = tstat_night_cool_db[by_Cur_sub];  Value_Range[9] = 1;
 703   2                      PTRtemp[10] = tstat_night_heat_sp[by_Cur_sub]; Value_Range[10] = 1;
 704   2                      PTRtemp[11] = tstat_night_cool_sp[by_Cur_sub]; Value_Range[11] = 1;
 705   2                      PTRtemp[12] = tstat_over_ride[by_Cur_sub];         Value_Range[12] = 1;
 706   2              }
 707   1      
 708   1              if(Value_Range[index] > 0)
 709   1              {
 710   2                      if(sub == 2 && index == 0)
 711   2                              Set_Value = by_Cur_sub;
 712   2                      else
 713   2                              Set_Value = PTRtemp[index];//tempValue;
 714   2              } 
 715   1      
 716   1              if(index < 4)
 717   1              {
 718   2                      start_line = 0;
 719   2                      flag_high_light = index;
 720   2              }
 721   1              else
 722   1              {
 723   2                      start_line = index - 3;
 724   2                      flag_high_light = 3;
C51 COMPILER V9.00   DISPLAY                                                               05/08/2013 16:47:36 PAGE 13  

 725   2              }
 726   1      
 727   1              if(sub_menu_len == 0 && sub == 1)
 728   1              {
 729   2                      Lcd_Show_String(2,0,"NO INPUT",NORMAL,21);
 730   2                      return; 
 731   2              }
 732   1              else
 733   1              {
 734   2                      U8_T max_row;
 735   2                      if(sub_menu_len < 4)
 736   2                      {
 737   3                              max_row = sub_menu_len;
 738   3                              for(loop1 = sub_menu_len;loop1 < 4;loop1++)
 739   3                                      Lcd_Show_String(loop1 + 1,0,"                     ",NORMAL,21);
 740   3                      }
 741   2                      else 
 742   2                              max_row = 4;
 743   2                      for(loop1 = 0;loop1 < max_row;loop1++)
 744   2                      {
 745   3                              //if(sub_menu_len > loop1)      
 746   3                              {
 747   4                                      Test[40] = menu[str_len *(start_line + loop1)];
 748   4                                      Test[40 + 1] = menu[str_len *(start_line + loop1) + 1];
 749   4                                      Test[40 + 2] = menu[str_len *(start_line + loop1) + 2];
 750   4                                      Test[40 + 3] = menu[str_len *(start_line + loop1) + 3];
 751   4                                      Test[40 + 4] = menu[str_len *(start_line + loop1) + 4];
 752   4                                      Test[40 + 5] = menu[str_len *(start_line + loop1) + 5];
 753   4                                      Test[40 + 6] = menu[str_len *(start_line + loop1) + 6];
 754   4                                      Test[40 + 7] = menu[str_len *(start_line + loop1) + 7];
 755   4                                      Test[48] = menu[str_len *(start_line + loop1) + 8];
 756   4                                      Test[40 + 9] = menu[str_len *(start_line + loop1) + 9];
 757   4                                              Test[35] = menu[str_len *(start_line + loop1) + 10];
 758   4                                      Test[36] = menu[str_len *(start_line + loop1) + 11];
 759   4                                              Test[37] = menu[str_len *(start_line + loop1) + 12];
 760   4                                      Test[38] = menu[str_len *(start_line + loop1) + 13];
 761   4      
 762   4                                      Lcd_Show_String(loop1 + 1,0,&(menu + str_len *(start_line + loop1)),NORMAL,10);
*** WARNING C182 IN LINE 762 OF DISPLAY\DISPLAY.C: pointer to different objects
 763   4                                      
 764   4                                      if(loop1 == flag_high_light)
 765   4                                      {
 766   5                                              if(sub == 0)     // output menu
 767   5                                              {
 768   6                                                      if(PTRtemp[start_line+ loop1] == 1)
 769   6                                                              Lcd_Show_String(loop1 + 1,16,"ON",INVERSE,5);
 770   6                                                      else
 771   6                                                              Lcd_Show_String(loop1 + 1,16,"OFF",INVERSE,5);
 772   6                                              }
 773   5                                              else  if(sub == 1)        // input menu
 774   5                                              {
 775   6                                                      if(Value_Range[start_line+ loop1] == 0)   // read only , sub_tst and temperature
 776   6                                                               Lcd_Show_Data (loop1 + 1,16,PTRtemp[start_line+ loop1],0,INVERSE);
 777   6                                                      else if(Value_Range[index] > 0) // DI
 778   6                                                      {
 779   7                                                              if(PTRtemp[start_line+ loop1] == 1)
 780   7                                                                      Lcd_Show_String(loop1 + 1,16,"ON",INVERSE,5);
 781   7                                                              else
 782   7                                                                      Lcd_Show_String(loop1 + 1,16,"OFF",INVERSE,5);
 783   7                                                      }       
 784   6                                              }
 785   5                                              else  if(sub == 2)         // tst menu
C51 COMPILER V9.00   DISPLAY                                                               05/08/2013 16:47:36 PAGE 14  

 786   5                                                      Lcd_Show_Data (loop1 + 1,16,PTRtemp[start_line+ loop1],0,INVERSE);
 787   5                                      }
 788   4                                      else 
 789   4                                      { 
 790   5                                              if(sub == 0)
 791   5                                              {
 792   6                                                      if(PTRtemp[start_line+ loop1] == 1)
 793   6                                                              Lcd_Show_String(loop1 + 1,16,"ON",NORMAL,5);
 794   6                                                      else
 795   6                                                              Lcd_Show_String(loop1 + 1,16,"OFF",NORMAL,5);
 796   6                                              }
 797   5                                              else  if(sub == 1)
 798   5                                              {
 799   6                                                      if(Value_Range[start_line+ loop1] == 0)   // read only , sub_tst and temperature
 800   6                                                               Lcd_Show_Data (loop1 + 1,16,PTRtemp[start_line+ loop1],0,NORMAL);
 801   6                                                      else if(Value_Range[start_line+ loop1] > 0) // DI
 802   6                                                      {
 803   7                                                              if(PTRtemp[start_line+ loop1] == 1)
 804   7                                                                      Lcd_Show_String(loop1 + 1,16,"ON",NORMAL,5);
 805   7                                                              else
 806   7                                                                      Lcd_Show_String(loop1 + 1,16,"OFF",NORMAL,5);
 807   7                                                      }       
 808   6                                              }
 809   5                                              else  if(sub == 2)      
 810   5                                                      Lcd_Show_Data (loop1 + 1,16,PTRtemp[start_line+ loop1],0,NORMAL);
 811   5                                      }       
 812   4                              } 
 813   3                      } 
 814   2              }
 815   1      } 
*** WARNING C280 IN LINE 613 OF DISPLAY\DISPLAY.C: 'tempValue': unreferenced local variable
 816          
 817          void Display_Menu(unsigned char index)
 818          {
 819   1              unsigned char  flag_high_light; 
 820   1              unsigned char  start_line;
 821   1              unsigned char  loop1;
 822   1      
 823   1              Lcd_Show_String(0,0,"MAIN BOARD MENU  ",NORMAL,21);
 824   1              if(index < 4)
 825   1              {
 826   2                      start_line = 0;
 827   2                      flag_high_light = index;
 828   2              }
 829   1              else
 830   1              {
 831   2                      start_line = index - 3;
 832   2                      flag_high_light = 3;
 833   2              }
 834   1              for(loop1= 0;loop1 < 4;loop1++)
 835   1              {
 836   2                      if(loop1 == flag_high_light)
 837   2                              Lcd_Show_String(loop1 + 1,0,*(Main_Menu + start_line+ loop1),INVERSE,21);
 838   2                      else  
 839   2                              Lcd_Show_String(loop1 + 1,0,*(Main_Menu + start_line + loop1),NORMAL,21);       
 840   2              }
 841   1              Lcd_Show_String(4,0,"                 ",NORMAL,21);
 842   1      
 843   1      } 
 844          
 845          

C51 COMPILER V9.00   DISPLAY                                                               05/08/2013 16:47:36 PAGE 15  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6934    ----
   CONSTANT SIZE    =    359    ----
   XDATA SIZE       =    231      72
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =    652    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)
