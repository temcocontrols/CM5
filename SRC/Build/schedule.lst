C51 COMPILER V9.00   SCHEDULE                                                              05/08/2013 16:47:37 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SCHEDULE
OBJECT MODULE PLACED IN .\Build\schedule.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE schedule\schedule.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..
                    -\SRC\FreeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\
                    -SRC\UART\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\
                    -;..\SRC\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\managemen
                    -t\;..\SRC\dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule;..\SRC\program;..\SRC\S
                    -can) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\schedule.lst) OBJECT(.\Build\schedule.obj)

line level    source

   1          #include "main.h"
   2          #include "clock.h"
   3          
   4          STR_WR far      WR_Roution[MAX_WR];
   5          STR_AR far AR_Roution[MAX_AR];
   6          UN_ID  far ID_Config[MAX_ID];
   7          
   8          bit BIT_FLAG;  // 0 -- run schedule 
   9          unsigned char idata current_hour;
  10          unsigned char idata current_minute;
  11          unsigned char idata dayofweek;
  12          unsigned char idata previous_dayofweek=10;
  13          unsigned int  idata dayofyear;
  14          
  15          unsigned char xdata ar_state_index[2] = 0;
  16          unsigned char xdata wr_state_index[3] = 0;
  17          unsigned char xdata holiday1_state_index[3] = 0;
  18          unsigned char xdata holiday2_state_index[3] = 0;
  19          
  20          unsigned char xdata output_state_index[32];
  21          unsigned char xdata schedual1_state_index[32];
  22          unsigned char xdata schedual2_state_index[32];
  23          unsigned char xdata first_time_schedual[32];
  24          
  25          unsigned char xdata send_schedual[8];
  26          bit received_schedual_data;
  27          bit success_write_schedual;
  28          bit receiving_schedual_byte;
  29          struct time_per_day {
  30                                                          unsigned char hours;
  31                                                          unsigned char minutes;
  32                                                  };
  33           
  34          unsigned char bdata  REFRESH_STATUS = 0;
  35          sbit WEEKLY_CHANGED                             = REFRESH_STATUS ^ 0;
  36          sbit ANNUAL_CHANGED                             = REFRESH_STATUS ^ 1;
  37          sbit ID_CHANGED                         = REFRESH_STATUS ^ 2;
  38          
  39          extern unsigned char T;
  40          unsigned char xdata daylight_enable;
  41          unsigned char xdata daylight_flag;
  42          bit calibrated_time = 0;
  43          bit cycle_minutes_timeout;
  44          
  45          bit flag_send_schedual = 0;
  46                
  47          unsigned char bdata               WR_FLAG = 0 ;
  48          sbit            WR_A_M                          = WR_FLAG^7 ; 
  49          sbit            WR_VALUE                        = WR_FLAG^6 ;  
  50          sbit            WR_STATE1                       = WR_FLAG^5 ;
C51 COMPILER V9.00   SCHEDULE                                                              05/08/2013 16:47:37 PAGE 2   

  51          sbit            WR_STATE2                       = WR_FLAG^4 ;
  52          
  53          unsigned char bdata               AR_FLAG = 0 ;
  54          sbit            AR_A_M                          = AR_FLAG^7 ; 
  55          sbit            AR_VALUE                        = AR_FLAG^6 ;  
  56           
  57          unsigned char bdata               ID_FLAG = 0 ;
  58          sbit            ID_A_M                          = ID_FLAG^7 ; 
  59          sbit            ID_OUTPUT                       = ID_FLAG^6 ;  
  60          sbit            ID_STATE1                       = ID_FLAG^5 ;
  61          sbit            ID_STATE2                       = ID_FLAG^4 ;
  62          
  63          
  64          
  65          unsigned int CRC16(unsigned char *puchMsg, unsigned char usDataLen);
  66          void SendRelayDataToSub(unsigned char num, unsigned char *data_buffer);
  67          
  68          
  69          void SetBit(unsigned char bit_number,unsigned char *byte)
  70          {
  71   1              unsigned char mask; 
  72   1              mask = 0x01;
  73   1              mask = mask << bit_number;
  74   1              *byte = *byte | mask;
  75   1      }
  76          void ClearBit(unsigned char bit_number,unsigned char *byte)
  77          {
  78   1              unsigned char mask; 
  79   1              mask = 0x01;
  80   1              mask = mask << bit_number;
  81   1              mask = ~mask;
  82   1              *byte = *byte & mask;
  83   1      }
  84          bit GetBit(unsigned char bit_number,unsigned char *value)
  85          {
  86   1              unsigned char mask;
  87   1              unsigned char octet_index;
  88   1              mask = 0x01;
  89   1              octet_index = bit_number >> 3;
  90   1              mask = mask << (bit_number & 0x07);
  91   1              return (bit)(*(value + octet_index) & mask);
  92   1      }
  93          
  94          
  95          
  96          void SendSchedualData(unsigned char number,bit flag)
  97          {
  98   1              union {
  99   1                              unsigned int  word;
 100   1                              unsigned char byte[2];
 101   1                        }crc;
 102   1              
 103   1              unsigned char success = 3;
 104   1              bit receive_success = 0;
 105   1              unsigned char output_value;
 106   1              U8_T ort_num = 0;
 107   1              number++;
 108   1              while(success--)
 109   1              {                
 110   2                      if(flag)
 111   2                      {
 112   3                              output_value = 1;
C51 COMPILER V9.00   SCHEDULE                                                              05/08/2013 16:47:37 PAGE 3   

 113   3                      }
 114   2                      else
 115   2                      {       
 116   3                              output_value = 0;
 117   3                      }                
 118   2                      
 119   2                      send_schedual[0] = number;
 120   2                      send_schedual[1] = 0x06;
 121   2                      send_schedual[2] = 0;
 122   2                      send_schedual[3] = 184;
 123   2                      send_schedual[4] = 0;
 124   2                      send_schedual[5] = output_value;
 125   2                      crc.word = CRC16(send_schedual,0x06);
 126   2                      send_schedual[6] = crc.byte[0];
 127   2                      send_schedual[7] = crc.byte[1];
 128   2      
 129   2                      flag_send_schedual = 1;
 130   2                      Test[49] = output_value;
 131   2      
 132   2      
 133   2              //      flag_send_schedual = 0;
 134   2              }       
 135   1              
 136   1       
 137   1              if(success ==255 && receive_success == 0)
 138   1              {
 139   2                      number--;
 140   2                      if(flag) 
 141   2                      {
 142   3                              if(GetBit(number,output_state_index) == 0)
 143   3                              {
 144   4                                      SetBit( number & 0x07,&output_state_index[ number >> 3 ]);
 145   4                                      ID_CHANGED = 0;
 146   4                              }
 147   3                      }
 148   2                      else 
 149   2                      {
 150   3                              if(GetBit(number,output_state_index) == 1)
 151   3                              {
 152   4                                      ClearBit( number & 0x07,&output_state_index[ number >> 3 ]);
 153   4                                      ID_CHANGED = 0;
 154   4                              }
 155   3                      }
 156   2              }
 157   1      
 158   1      }
 159           
 160          /* implement per 500ms */
 161          void CaculateTime(void)
 162          {
 163   1              unsigned int temp_year;
 164   1              unsigned char temp_month;
 165   1              unsigned char temp_day;
 166   1      
 167   1      
 168   1              current_minute =  RTC.Clk.min;
 169   1              current_hour =  RTC.Clk.hour;
 170   1              temp_day =  RTC.Clk.day;
 171   1              dayofweek =  RTC.Clk.week - 1;
 172   1              temp_month =  RTC.Clk.mon;
 173   1              temp_year =      RTC.Clk.year;
 174   1              
C51 COMPILER V9.00   SCHEDULE                                                              05/08/2013 16:47:37 PAGE 4   

 175   1              if(temp_month & 0x80)
 176   1              temp_year = 1900+temp_day ;
 177   1              else
 178   1              temp_year = 2000+temp_day ;
 179   1              temp_month&=0x1f;
 180   1              
 181   1              if(daylight_flag == 1)
 182   1              {
 183   2                      if(current_hour >= 2)
 184   2                      {
 185   3                              current_hour++;
 186   3                              Set_Clock(PCF_HOUR,current_hour);
 187   3                              daylight_flag = 0; 
 188   3              //              write_eeprom(EEP_DAYLIGHT_STATUS, daylight_flag);                       
 189   3                      }
 190   2              }
 191   1              else if(daylight_flag == 2)
 192   1              {
 193   2                      if(current_hour >= 2)
 194   2                      {
 195   3                              current_hour--;
 196   3                      //      SetPCF8563(0x04,HexToBcd(current_hour));        //hour]
 197   3                              Set_Clock(PCF_HOUR,current_hour);
 198   3                              daylight_flag = 0; 
 199   3              //              write_eeprom(EEP_DAYLIGHT_STATUS, daylight_flag);                       
 200   3                      }
 201   2              }
 202   1      
 203   1              if(dayofweek != previous_dayofweek || calibrated_time == 1)
 204   1              {
 205   2                      previous_dayofweek = dayofweek;
 206   2                      calibrated_time = 0;             
 207   2                      switch(temp_month)
 208   2                      {
 209   3                              case 1:
 210   3                                      dayofyear = temp_day;
 211   3                                      break;
 212   3                              case 2:
 213   3                                      dayofyear = 0x1f + temp_day;
 214   3                                      break;
 215   3                              case 3:
 216   3                                      if((temp_year & 0x03 ) == 0x0 )
 217   3                                              dayofyear = 0x3c + temp_day;
 218   3                                      else
 219   3                                              dayofyear = 0x3b + temp_day;
 220   3                                      if(daylight_enable == 1 && temp_year >= 2007)
 221   3                                      {
 222   4                                              if(temp_day >= 8 && temp_day <= 14 && dayofweek == 6)   
 223   4                                              {
 224   5                                                      daylight_flag = 1; 
 225   5                              //                      write_eeprom(EEP_DAYLIGHT_STATUS, daylight_flag);                       
 226   5                                              }
 227   4                                      }                               
 228   3                                      break;
 229   3                              case 4:
 230   3                                      if( ( temp_year & 0x03 ) == 0x0 )
 231   3                                              dayofyear = 0x5b+temp_day;
 232   3                                      else
 233   3                                              dayofyear = 0x5a+temp_day;      
 234   3                                      if(daylight_enable == 1 && temp_year < 2007)
 235   3                                      {
 236   4                                              if(temp_day <= 7 && dayofweek == 6)     
C51 COMPILER V9.00   SCHEDULE                                                              05/08/2013 16:47:37 PAGE 5   

 237   4                                              {
 238   5                                                      daylight_flag = 1; 
 239   5                              //                      write_eeprom(EEP_DAYLIGHT_STATUS, daylight_flag);                       
 240   5                                              }
 241   4                                      }       
 242   3                                      break;
 243   3                              case 5:
 244   3                                      if( ( temp_year & 0x03 ) == 0x0 )
 245   3                                              dayofyear=0x79+temp_day;
 246   3                                      else
 247   3                                              dayofyear=0x78+temp_day;                        
 248   3                                      break;
 249   3                              case 6:
 250   3                                      if( ( temp_year & 0x03 ) == 0x0 )
 251   3                                              dayofyear=0x98+temp_day;
 252   3                                      else
 253   3                                              dayofyear=0x97+temp_day;                        
 254   3                                      break;
 255   3                              case 7:
 256   3                                      if( ( temp_year & 0x03 ) == 0x0 )
 257   3                                              dayofyear=0xb6+temp_day;
 258   3                                      else
 259   3                                              dayofyear=0xb5+temp_day;                        
 260   3                                      break;
 261   3                              case 8:
 262   3                                      if( ( temp_year & 0x03 ) == 0x0 )
 263   3                                              dayofyear=0xd5+temp_day;
 264   3                                      else
 265   3                                              dayofyear=0xd4+temp_day;                        
 266   3                                      break;
 267   3                              case 9:
 268   3                                      if( ( temp_year & 0x03 ) == 0x0 )
 269   3                                              dayofyear=0xf4+temp_day;
 270   3                                      else
 271   3                                              dayofyear=0xf3+temp_day;                        
 272   3                                      break;
 273   3                              case 10:
 274   3                                      if( ( temp_year & 0x03 ) == 0x0 )
 275   3                                              dayofyear = 0x112 + temp_day;
 276   3                                      else
 277   3                                              dayofyear = 0x111 + temp_day;
 278   3                                      if(daylight_enable == 1 && temp_year < 2007)
 279   3                                      {
 280   4                                              if((31 - temp_day <= 6) && dayofweek == 6)      
 281   4                                              {
 282   5                                                      daylight_flag = 2; 
 283   5                              //                      write_eeprom(EEP_DAYLIGHT_STATUS, daylight_flag);               
 284   5                                              }
 285   4                                      }       
 286   3                                      break;
 287   3                              case 11:
 288   3                                      if( ( temp_year & 0x03 ) == 0x0 )
 289   3                                              dayofyear=0x131+temp_day;
 290   3                                      else
 291   3                                              dayofyear=0x130+temp_day;       
 292   3                                      if(daylight_enable == 1 && temp_year >= 2007)
 293   3                                      {
 294   4                                              if(temp_day <= 7 && dayofweek == 6)     
 295   4                                              {
 296   5                                                      daylight_flag = 2; 
 297   5                      //                              write_eeprom(EEP_DAYLIGHT_STATUS, daylight_flag);                       
 298   5                                              }
C51 COMPILER V9.00   SCHEDULE                                                              05/08/2013 16:47:37 PAGE 6   

 299   4                                      }                       
 300   3                                      break;
 301   3                              case 12:
 302   3                                      if( ( temp_year & 0x03 ) == 0x0 )
 303   3                                              dayofyear=0x14f+temp_day;
 304   3                                      else
 305   3                                              dayofyear=0x14e+temp_day;                       
 306   3                                      break;
 307   3                              default:
 308   3                              break;
 309   3                      }
 310   2                      
 311   2                      dayofyear -= 1;
 312   2              }
 313   1              
 314   1      }
 315                                          
 316          
 317          void CheckAnnualRoutines( void )
 318          {
 319   1              unsigned char  i;
 320   1              unsigned char  mask;
 321   1      //    unsigned char  mask_r;
 322   1              unsigned char  octet_index;
 323   1       //   unsigned char code *base_address;
 324   1              for( i=0; i<MAX_AR; i++ )
 325   1              {
 326   2                      AR_FLAG = AR_Roution[i].UN.Desc.flag;
 327   2                      if( !AR_A_M )  // auto 
 328   2                       {
 329   3                              mask = 0x01;
 330   3                              /* Assume bit0 from octet0 = Jan 1st */
 331   3                              /* octet_index = ora_current.day_of_year / 8;*/
 332   3                              octet_index = dayofyear >> 3;
 333   3                              /* bit_index = ora_current.day_of_year % 8;*/
 334   3                              /* bit_index = ora_current.day_of_year & 0x07;*/
 335   3                              mask = mask << ( dayofyear & 0x07 );
 336   3                              
 337   3                      //      base_address = AR_Roution[i].Time;//ttt[i];
 338   3                      if(AR_Roution[i].Time[11]!=0xff && AR_Roution[i].Time[38]!=0xff)
 339   3                              { 
 340   4                                      if( AR_Roution[i].Time[octet_index] & mask )
 341   4                                      {
 342   5                                              if(GetBit(i,ar_state_index) == 0)
 343   5                                              {                                
 344   6                                                      SetBit(i & 0x07,&ar_state_index[ i >> 3 ]);
 345   6                                                      ANNUAL_CHANGED = 0;
 346   6                                              }
 347   5                                      }       
 348   4                                      else
 349   4                                      {
 350   5                                              if(GetBit(i,ar_state_index) == 1)
 351   5                                              {                                       
 352   6                                                      ClearBit(i & 0x07 , &ar_state_index[ i >> 3 ]); 
 353   6                                                      ANNUAL_CHANGED = 0;
 354   6                                              }
 355   5                                      }
 356   4                              }
 357   3                              else
 358   3                              {                                        
 359   4                                      ClearBit(i & 0x07 , &ar_state_index[ i >> 3 ]); 
 360   4                              }
C51 COMPILER V9.00   SCHEDULE                                                              05/08/2013 16:47:37 PAGE 7   

 361   3                      }
 362   2                      else  // mannual
 363   2                      {
 364   3                      //if(*base_address!=0xff && *(base_address+1)!=0xff)
 365   3                              if(AR_FLAG != 0xff)
 366   3                              {
 367   4                                      if(AR_VALUE)
 368   4                                      {
 369   5                                              if(GetBit(i,ar_state_index) == 0)
 370   5                                              {                                
 371   6                                                      SetBit(i & 0x07,&ar_state_index[ i >> 3 ]);
 372   6                                                      ANNUAL_CHANGED = 0;
 373   6                                              }                                
 374   5                                      }
 375   4                                      else
 376   4                                      {
 377   5                                              if(GetBit(i,ar_state_index) == 1)
 378   5                                              {                                
 379   6                                                      ClearBit(i & 0x07,&ar_state_index[ i >> 3 ]);
 380   6                                                      ANNUAL_CHANGED = 0;
 381   6                                              }                                       
 382   5                                      }
 383   4                              }
 384   3                      }
 385   2      
 386   2              }
 387   1         
 388   1      }
 389          
 390          
 391          
 392          void CheckWeeklyRoutines(void)
 393          { 
 394   1              unsigned char w, i;
 395   1              signed char j,timeout = 0;
 396   1              unsigned char mask;
 397   1              //unsigned char mask_r;
 398   1              for( i=0; i<MAX_WR; i++ )
 399   1              {
 400   2                      w =  dayofweek;
 401   2      
 402   2                      
 403   2                      if( w < 0 ) w = 6;
 404   2                      
 405   2                      WR_FLAG = WR_Roution[i].UN.Desc.flag;
 406   2      
 407   2                      //Para[11] = w;
 408   2      
 409   2                      j = WR_Roution[i].UN.Desc.holiday2;     
 410   2              
 411   2                      if(j > 0 && j <= MAX_AR)
 412   2                      {
 413   3                              WR_FLAG |= 0x10;
 414   3                              j -= 1;
 415   3                              mask = 0x01;
 416   3                              mask = mask << (j & 0x07);               
 417   3                              if( ar_state_index[ j >> 3] & mask )
 418   3                              {
 419   4                                      
 420   4                                      if(GetBit(i,holiday2_state_index) == 0)
 421   4                                      {                        
 422   5                                              SetBit( i & 0x07,&holiday2_state_index[ i >> 3 ]);
C51 COMPILER V9.00   SCHEDULE                                                              05/08/2013 16:47:37 PAGE 8   

 423   5                                              WEEKLY_CHANGED = 0;
 424   5                                      }
 425   4                                      w = 8; 
 426   4                              
 427   4                              }
 428   3                      else
 429   3                              {       
 430   4                                      if(GetBit(i,holiday2_state_index) == 1)
 431   4                                      {                        
 432   5                                              ClearBit( i & 0x07 , &holiday2_state_index[ i >> 3 ] );
 433   5                                              WEEKLY_CHANGED = 0;
 434   5                                      }
 435   4                              }
 436   3                      }
 437   2                      else
 438   2                              ClearBit( i & 0x07 , &holiday2_state_index[ i >> 3 ] );
 439   2      
 440   2                      j = WR_Roution[i].UN.Desc.holiday1;
 441   2                      if(j > 0 && j<=MAX_AR)
 442   2                      {
 443   3                              j -= 1;
 444   3                              mask = 0x01;
 445   3                              mask = mask << (j & 0x07);
 446   3                              WR_FLAG |= 0x20;                 
 447   3                              if( ar_state_index[ j >> 3] & mask )
 448   3                              { 
 449   4                                      
 450   4                                      if(GetBit(i,holiday1_state_index) == 0)
 451   4                                      {
 452   5                                              SetBit( i & 0x07,&holiday1_state_index[ i >> 3 ]);
 453   5                                              WEEKLY_CHANGED = 0;
 454   5                                      }
 455   4                                      w = 7;
 456   4                                      
 457   4                              }
 458   3                      else
 459   3                              {
 460   4                                      if(GetBit(i,holiday1_state_index) == 1)
 461   4                                      {
 462   5                                              ClearBit( i & 0x07 , &holiday1_state_index[ i >> 3 ] );
 463   5                                              WEEKLY_CHANGED = 0;
 464   5                                      }
 465   4                              }
 466   3                      }
 467   2                      else
 468   2                              ClearBit( i & 0x07 , &holiday1_state_index[ i >> 3 ] );
 469   2      
 470   2              
 471   2      
 472   2                      if( !WR_A_M ) // auto 
 473   2                      {
 474   3      
 475   3                              for(j = 7;j >= 0 ;j--)
 476   3                              {
 477   4                                      if(j % 2 == 0)  // check ontime j = 0,2,4,6
 478   4                                      {
 479   5                                              if( WR_Roution[i].OnTime[w * 8 + j ] || WR_Roution[i].OnTime[w * 8 + j + 1])
 480   5                                              {
 481   6                                                      if( current_hour > WR_Roution[i].OnTime[w * 8 + j] )            break;
 482   6                                                      if( current_hour == WR_Roution[i].OnTime[w * 8 + j] )                                           
 483   6                                                              if(current_minute >=WR_Roution[i].OnTime[w * 8 + j + 1])                                                
 484   6                                                                      break;
C51 COMPILER V9.00   SCHEDULE                                                              05/08/2013 16:47:37 PAGE 9   

 485   6                                                              
 486   6                                              }       
 487   5                                      }
 488   4                                      else                    // check offtime  j = 1,3,5,7
 489   4                                      {
 490   5                                              if(WR_Roution[i].OffTime[w * 8 + j - 1] || WR_Roution[i].OffTime[w * 8 + j])
 491   5                                              {
 492   6                                                      if( current_hour > WR_Roution[i].OffTime[w * 8 + j - 1])        break;
 493   6                                                      if( current_hour == WR_Roution[i].OffTime[w * 8 + j - 1])
 494   6                                                              if( current_minute >= WR_Roution[i].OffTime[w * 8 + j] )                
 495   6                                                                      break;
 496   6                                              }               
 497   5                                      }                                                       
 498   4                              }
 499   3      
 500   3                              if( j < 0) //if( j == 0)  current time is not in Ontime or Offtime
 501   3                              {
 502   4                                      if(GetBit(i,wr_state_index) == 1)
 503   4                                      {        
 504   5                                              ClearBit( i & 0x07 , &wr_state_index[ i >> 3 ] );
 505   5                                              WEEKLY_CHANGED = 0;                                                                     
 506   5                                      }
 507   4                              }
 508   3                              else
 509   3                              {
 510   4                                      if( j % 2) /* current time is  off time*/
 511   4                                      {
 512   5                                              if(GetBit(i,wr_state_index) == 1)
 513   5                                              {                
 514   6                                                      ClearBit( i & 0x07 , &wr_state_index[ i >> 3 ] );
 515   6                                                      WEEKLY_CHANGED = 0;
 516   6                                              } 
 517   5                                      }
 518   4                                               
 519   4                                      else   /* current time is on time*/
 520   4                                      {
 521   5                                              if(GetBit(i,wr_state_index) == 0)
 522   5                                              {                
 523   6                                                      SetBit( i & 0x07,&wr_state_index[ i >> 3 ]);
 524   6                                                      WEEKLY_CHANGED = 0;
 525   6                                              }
 526   5               
 527   5                                      }
 528   4                              }
 529   3      
 530   3                      }
 531   2                      else   // manual
 532   2                      {
 533   3                              if(WR_FLAG != 0xff)
 534   3                              {
 535   4                                      if(WR_VALUE)
 536   4                                      {
 537   5                                              if(GetBit(i,wr_state_index) == 0)
 538   5                                              {        
 539   6                                                      SetBit( i & 0x07,&wr_state_index[ i >> 3 ]);
 540   6                                                      WEEKLY_CHANGED = 0;
 541   6                                              }
 542   5                                      }
 543   4                                      else
 544   4                                      {
 545   5                                              if(GetBit(i,wr_state_index) == 1)
 546   5                                              {        
C51 COMPILER V9.00   SCHEDULE                                                              05/08/2013 16:47:37 PAGE 10  

 547   6                                                      ClearBit( i & 0x07 ,&wr_state_index[ i >> 3 ]);
 548   6                                                      WEEKLY_CHANGED = 0;
 549   6                                              }
 550   5                                      }
 551   4                              }
 552   3                      }
 553   2              }       
 554   1      }
 555          
 556          
 557          
 558          void CheckIdRoutines(void)
 559          {
 560   1              unsigned char i;
 561   1      //    unsigned char code *base_address;
 562   1          bit wr1_value=0;
 563   1          bit wr2_value=0;
 564   1              bit output_value=0;
 565   1              bit temp_bit;
 566   1              bit wr1_valid;
 567   1              bit wr2_valid;
 568   1              for(i = 0;i < MAX_ID;i++)
 569   1              {
 570   2                      if(ID_Config[i].all != NO_DEFINE_ADDRESS)
 571   2                      {
 572   3                              ID_FLAG = ID_Config[i].Str.flag;
 573   3                              wr1_valid = 0;
 574   3                              wr2_valid = 0;
 575   3                      //      test0 = ID_Config[i].Str.schedule1;
 576   3                              if(ID_Config[i].Str.schedule1 > 0 && ID_Config[i].Str.schedule1 <= MAX_WR)
 577   3                              {
 578   4                                      if(GetBit(ID_Config[i].Str.schedule1 - 1,wr_state_index))
 579   4                                      { 
 580   5                                              wr1_value=1;
 581   5                                              if(GetBit(i,schedual1_state_index) == 0)
 582   5                                              {
 583   6                                                      SetBit( i & 0x07,&schedual1_state_index[ i >> 3 ]);
 584   6                                                      ID_CHANGED = 0;
 585   6                                              }
 586   5                                      }
 587   4                                      else
 588   4                                      {
 589   5                                              wr1_value=0;
 590   5                                              if(GetBit(i,schedual1_state_index) == 1)
 591   5                                              {
 592   6                                                      ClearBit(i & 0x07 ,&schedual1_state_index[ i >> 3 ]);
 593   6                                                      ID_CHANGED = 0;
 594   6                                              }
 595   5                                      }
 596   4                                      wr1_valid = 1;
 597   4                              }
 598   3                              else
 599   3                                      ClearBit(i & 0x07 ,&schedual1_state_index[ i >> 3 ]);
 600   3      
 601   3                              if(ID_Config[i].Str.schedule2 > 0 && ID_Config[i].Str.schedule2 <= MAX_WR)
 602   3                              {
 603   4                                      if(GetBit(ID_Config[i].Str.schedule2 - 1,wr_state_index))
 604   4                                      { 
 605   5                                              wr2_value = 1;
 606   5                                              if(GetBit(i,schedual2_state_index) == 0)
 607   5                                              {
 608   6                                                      SetBit(i & 0x07,&schedual2_state_index[ i >> 3 ]);
C51 COMPILER V9.00   SCHEDULE                                                              05/08/2013 16:47:37 PAGE 11  

 609   6                                                      ID_CHANGED = 0;
 610   6                                              }
 611   5                                      }
 612   4                                      else
 613   4                                      {
 614   5                                              wr2_value = 0;
 615   5                                              if(GetBit(i,schedual2_state_index) == 1)
 616   5                                              {
 617   6                                                      ClearBit(i & 0x07 ,&schedual2_state_index[ i >> 3 ]);
 618   6                                                      ID_CHANGED = 0;
 619   6                                              }
 620   5                                      }
 621   4                                      wr2_valid = 1;
 622   4                              }
 623   3                              else
 624   3                                      ClearBit(i & 0x07 ,&schedual2_state_index[ i >> 3 ]);
 625   3      
 626   3      
 627   3                              if(!ID_A_M)  // AUTO
 628   3                              {
 629   4                                      if(wr1_valid || wr2_valid )
 630   4                                      {
 631   5                                      //      test0 = 5;
 632   5                                      //      SendSchedualData(i,wr1_value | wr2_value);  
 633   5                              #if 1
 634   5                                              output_value = GetBit(i,output_state_index); 
 635   5                                              temp_bit = GetBit(i,first_time_schedual);
 636   5                                              if(output_value != (wr1_value | wr2_value) || temp_bit == 0 )
 637   5                                              { 
 638   6                                                      if(temp_bit == 0)
 639   6                                                      SetBit(i & 0x07 ,&first_time_schedual[ i >> 3 ]);                                        
 640   6                                                      
 641   6                                                      SendSchedualData(i,wr1_value | wr2_value);  
 642   6                                              }
 643   5                                              else if(cycle_minutes_timeout == 1)
 644   5                                              {
 645   6                                                      SendSchedualData(i,wr1_value | wr2_value);  
 646   6                                                      if(i == MAX_ID - 1)
 647   6                                                      cycle_minutes_timeout = 0;
 648   6                                              }
 649   5                              #endif
 650   5                                      }
 651   4                              }
 652   3                              else  // MAN
 653   3                              {
 654   4                                      if(ID_FLAG != 0xff)
 655   4                                      {
 656   5                                      //      SendSchedualData(i,ID_OUTPUT);  
 657   5                                      //      test0 = 7;
 658   5                                              #if 1
 659   5                                              temp_bit = GetBit(i,first_time_schedual);
 660   5                                              if(ID_OUTPUT != GetBit(i,output_state_index) || temp_bit == 0)
 661   5                                              { 
 662   6                                              //      test0 = 8;
 663   6                                                      if(temp_bit == 0)
 664   6                                                      SetBit(i & 0x07 ,&first_time_schedual[ i >> 3 ]);                                        
 665   6                                                      SendSchedualData(i,ID_OUTPUT);
 666   6                                              }
 667   5                                              else if(cycle_minutes_timeout == 1)
 668   5                                              {
 669   6                                              //      test0 = 9;
 670   6                                                      SendSchedualData(i,ID_OUTPUT);
C51 COMPILER V9.00   SCHEDULE                                                              05/08/2013 16:47:37 PAGE 12  

 671   6                                                      if(i == MAX_ID -1)
 672   6                                                      cycle_minutes_timeout = 0;
 673   6                                              }
 674   5                                              #endif
 675   5                                      }
 676   4                              }
 677   3                      }//check if the correspond ID has been used
 678   2              }//for 
 679   1      }//main function
 680          
 681          
 682          
 683          
 684          
 685          void Schedule_task(void) reentrant
 686          {
 687   1              static U8_T     count = 0;
 688   1              portTickType xDelayPeriod = ( portTickType ) 500 / portTICK_RATE_MS;//500
 689   1      //    U8_T i;           
 690   1              for (;;)
 691   1              {       
 692   2                      Test[1]++;                      
 693   2                      if(b_Master_Slave != TSTAT)      
 694   2                      {
 695   3      /* implement CaculateTime rution  per 500ms */
 696   3                      CaculateTime();
 697   3      /* implement CheckWeeklyRoutines rution  per 1s */
 698   3                      if(count % 2 == 0)  // 1s
 699   3                      {
 700   4                              //Para[1]++;
 701   4                              CheckWeeklyRoutines();
 702   4                      }
 703   3      /* implement CheckAnnualRoutines rution  per 3s */
 704   3      /* implement CheckIdRoutines rution  per 3s */  
 705   3                      if(count % 6 == 0)  // 3s
 706   3                      {
 707   4                              //Para[3]++;
 708   4                              CheckAnnualRoutines();
 709   4                              CheckIdRoutines();
 710   4                      }
 711   3      
 712   3                      if(count < 6) count++;
 713   3                      else count = 0;
 714   3                      }
 715   2                      vTaskDelay(xDelayPeriod);
 716   2              }
 717   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3611    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    150      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =      6    ----
   BIT SIZE         =      7       8
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   5462    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.00   SCHEDULE                                                              05/08/2013 16:47:37 PAGE 13  


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
