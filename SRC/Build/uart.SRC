; .\Build\uart.SRC generated from: ..\SRC\UART\uart.c
; COMPILER INVOKED BY:
;        C:\Keil\C51\BIN\C51.EXE ..\SRC\UART\uart.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\FreeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\SRC\UART\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;..\SRC\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management\;..\SRC\dhcp\;..\SRC\pppoe\;..\SRC\MINI_262\;..\SRC\flash;..\SRC\SNTP) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\uart.lst) SRC(.\Build\uart.SRC)

$MOD_CONT
$NOMOD51

NAME	UART

TB08	BIT	098H.3
TB18	BIT	0C0H.3
P0	DATA	080H
SM00	BIT	098H.7
P1	DATA	090H
SM10	BIT	0C0H.7
SM01	BIT	098H.6
P2	DATA	0A0H
SM11	BIT	0C0H.6
SM02	BIT	098H.5
P3	DATA	0B0H
AC	BIT	0D0H.6
SM12	BIT	0C0H.5
T0	BIT	0B0H.4
SPIDR	DATA	0CFH
T1	BIT	0B0H.5
EA	BIT	0A8H.7
OWCIR	DATA	0D6H
CH	DATA	0C5H
DPH0	DATA	083H
IE	DATA	0A8H
DPH1	DATA	085H
CL	DATA	0C4H
P0_0	BIT	080H.0
P1_0	BIT	090H.0
P0_1	BIT	080H.1
CCAPH0	DATA	0B9H
DPL0	DATA	082H
P2_0	BIT	0A0H.0
P1_1	BIT	090H.1
P0_2	BIT	080H.2
CCAPH1	DATA	0BAH
DPL1	DATA	084H
P3_0	BIT	0B0H.0
P2_1	BIT	0A0H.1
P1_2	BIT	090H.2
P0_3	BIT	080H.3
UR2_DLH	DATA	0E2H
CCAPH2	DATA	0BBH
XMRHR	DATA	0A7H
P3_1	BIT	0B0H.1
P2_2	BIT	0A0H.2
P1_3	BIT	090H.3
P0_4	BIT	080H.4
CCAPH3	DATA	0BCH
P3_2	BIT	0B0H.2
P2_3	BIT	0A0H.3
P1_4	BIT	090H.4
P0_5	BIT	080H.5
TA	DATA	0EBH
CCAPH4	DATA	0BDH
CCAPL0	DATA	0B1H
EXF2	BIT	0C8H.6
RD	BIT	0B0H.7
P3_3	BIT	0B0H.3
P2_4	BIT	0A0H.4
REN0	BIT	098H.4
P1_5	BIT	090H.5
P0_6	BIT	080H.6
UR2_FCR	DATA	0E3H
CCAPM0	DATA	0D1H
T2IF	DATA	0C9H
CCAPL1	DATA	0B2H
REN1	BIT	0C0H.4
P3_4	BIT	0B0H.4
P2_5	BIT	0A0H.5
P1_6	BIT	090H.6
P0_7	BIT	080H.7
UR2_DLL	DATA	0E1H
CCAPM1	DATA	0D2H
CCAPL2	DATA	0B3H
XMRLR	DATA	0A6H
P3_5	BIT	0B0H.5
P2_6	BIT	0A0H.6
P1_7	BIT	090H.7
CCAPM2	DATA	0D3H
CCAPL3	DATA	0B4H
XMWHR	DATA	0A5H
P3_6	BIT	0B0H.6
P2_7	BIT	0A0H.7
CCAPM3	DATA	0D4H
IP	DATA	0B8H
CCAPL4	DATA	0B5H
P3_7	BIT	0B0H.7
CCAPM4	DATA	0D5H
DBAR	DATA	09AH
UR2_IER	DATA	0E2H
CY	BIT	0D0H.7
INT0	BIT	0B0H.2
UR2_LCR	DATA	0E4H
XMWLR	DATA	0A4H
INT1	BIT	0B0H.3
UR2_MCR	DATA	0E5H
DPX0	DATA	093H
I2CCIR	DATA	096H
DPX1	DATA	095H
UR2_IIR	DATA	0E3H
UR2_RBR	DATA	0E1H
ACON	DATA	09DH
DCIR	DATA	09BH
SP	DATA	081H
CCON	DATA	0C3H
CMOD	DATA	0C2H
OV	BIT	0D0H.2
WR	BIT	0B0H.6
UR2_THR	DATA	0E1H
EWDI	BIT	0E8H.5
WDIF	BIT	0D8H.3
RLDH	DATA	0CBH
EPCR	DATA	0BEH
LDHR	DATA	0AAH
UR2_LSR	DATA	0E6H
EPDR	DATA	0BFH
MCIR	DATA	0B6H
RCLK	BIT	0C8H.5
UR2_MSR	DATA	0E7H
TCLK	BIT	0C8H.4
RLDL	DATA	0CAH
LDLR	DATA	0A9H
PCON	DATA	087H
CANCIR	DATA	0DEH
TCIR	DATA	0AEH
PWDI	BIT	0F8H.5
LSCR	DATA	0A2H
TMOD	DATA	089H
TCON	DATA	088H
OWDR	DATA	0D7H
IE0	BIT	088H.1
IE1	BIT	088H.3
MXAX	DATA	0EAH
LMSR	DATA	0A1H
MD0	DATA	0F9H
B	DATA	0F0H
MD1	DATA	0FAH
LSAIER	DATA	0A1H
MD2	DATA	0FBH
WTRF	BIT	0D8H.2
MD3	DATA	0FCH
PISSR1	DATA	09EH
MD4	DATA	0FDH
LSSR	DATA	0A3H
PISSR2	DATA	09FH
MD5	DATA	0FEH
ACC	DATA	0E0H
ES0	BIT	0A8H.4
CT2	BIT	0C8H.1
ES1	BIT	0A8H.6
ET0	BIT	0A8H.1
ET1	BIT	0A8H.3
TF0	BIT	088H.5
ET2	BIT	0A8H.5
RI0	BIT	098H.0
TF1	BIT	088H.7
TF2	BIT	0C8H.7
RI1	BIT	0C0H.0
SPICIR	DATA	0CEH
TH0	DATA	08CH
EX0	BIT	0A8H.0
TI0	BIT	098H.1
IT0	BIT	088H.0
TH1	DATA	08DH
TI1	BIT	0C0H.1
EX1	BIT	0A8H.2
IT1	BIT	088H.2
TH2	DATA	0CDH
P	BIT	0D0H.0
TL0	DATA	08AH
CSREPR	DATA	08FH
TL1	DATA	08BH
TL2	DATA	0CCH
PS0	BIT	0B8H.4
EIE	DATA	0E8H
WTST	DATA	092H
PS1	BIT	0B8H.6
PT0	BIT	0B8H.1
EIF	DATA	091H
RS0	BIT	0D0H.3
PT1	BIT	0B8H.3
I2CDR	DATA	097H
RS1	BIT	0D0H.4
PT2	BIT	0B8H.5
TR0	BIT	088H.4
TR1	BIT	088H.6
TR2	BIT	0C8H.2
PX0	BIT	0B8H.0
PX1	BIT	0B8H.2
DDR	DATA	09CH
DPH	DATA	083H
EIP	DATA	0F8H
DPL	DATA	082H
LCR	DATA	0A2H
SBUF0	DATA	099H
SBUF1	DATA	0C1H
EINT2	BIT	0E8H.0
EXEN2	BIT	0C8H.3
MDR	DATA	0B7H
EINT3	BIT	0E8H.1
CPRL2	BIT	0C8H.0
SCON0	DATA	098H
EINT4	BIT	0E8H.2
SCON1	DATA	0C0H
SDSTSR	DATA	094H
EINT5	BIT	0E8H.3
STATUS	DATA	0E9H
EINT6	BIT	0E8H.4
T2CON	DATA	0C8H
DPS	DATA	086H
CANDR	DATA	0DFH
TDR	DATA	0AFH
LDAHR	DATA	0A5H
DPX	DATA	093H
DMAHR	DATA	0ADH
PINT2	BIT	0F8H.0
RXD	BIT	0B0H.0
PINT3	BIT	0F8H.1
CKCON	DATA	08EH
PINT4	BIT	0F8H.2
EWT	BIT	0D8H.1
TXD	BIT	0B0H.1
LDALR	DATA	0A4H
PINT5	BIT	0F8H.3
DMALR	DATA	0ABH
LSR	DATA	0A3H
PINT6	BIT	0F8H.4
DMAMR	DATA	0ACH
ARCON	DATA	0FFH
F0	BIT	0D0H.5
F1	BIT	0D0H.1
LDCSR	DATA	0A6H
PSW	DATA	0D0H
RB08	BIT	098H.2
WDCON	DATA	0D8H
RWT	BIT	0D8H.0
RB18	BIT	0C0H.2
?PR?UART0_ISR?UART   SEGMENT ECODE INSEG 
?PR?uart0_Init?UART  SEGMENT ECODE INSEG 
?PR?_uart0_PutChar?UART                  SEGMENT ECODE INSEG 
?PR?uart0_GetKey?UART                    SEGMENT ECODE INSEG 
?PR?UART0_NoBlockGetkey?UART             SEGMENT ECODE INSEG 
?PR?uart1_Init?UART  SEGMENT ECODE INSEG 
?PR?_uart1_PutChar?UART                  SEGMENT ECODE INSEG 
?PR?uart1_GetKey?UART                    SEGMENT ECODE INSEG 
?PR?uart1_NoBlockGetkey?UART             SEGMENT ECODE INSEG 
?PR?_getkey?UART     SEGMENT ECODE INSEG 
?PR?_putchar?UART    SEGMENT ECODE INSEG 
?XD?_putchar?UART    SEGMENT XDATA OVERLAYABLE
?PR?_UART_Init?UART  SEGMENT ECODE INSEG 
?XD?_UART_Init?UART  SEGMENT XDATA OVERLAYABLE
?PR?NOBLK_getkey?UART                    SEGMENT ECODE INSEG 
?PR?_UART_ParityChk?UART                 SEGMENT ECODE INSEG 
?XD?_UART_ParityChk?UART                 SEGMENT XDATA OVERLAYABLE
?PR?_UART0_SetMode?UART                  SEGMENT ECODE INSEG 
?PR?_UART1_SetMode?UART                  SEGMENT ECODE INSEG 
?PR?_UART_SetPort?UART                   SEGMENT ECODE INSEG 
?PR?UART_GetRxBufCount?UART              SEGMENT ECODE INSEG 
?C_INITSEG           SEGMENT CODE 
?XD?UART             SEGMENT XDATA 
	EXTRN	NUMBER (?C?XDATASEG)
	PUBLIC	uart1_RxCount
	PUBLIC	uart0_RxCount
	PUBLIC	UART_GetRxBufCount
	PUBLIC	_UART_SetPort
	PUBLIC	_UART1_SetMode
	PUBLIC	_UART0_SetMode
	PUBLIC	_UART_ParityChk
	PUBLIC	NOBLK_getkey
	PUBLIC	_UART_Init
	PUBLIC	_putchar
	PUBLIC	_getkey
	PUBLIC	uart1_NoBlockGetkey
	PUBLIC	uart1_GetKey
	PUBLIC	_uart1_PutChar
	PUBLIC	uart0_GetKey
	PUBLIC	_uart0_PutChar

	RSEG  ?XD?_UART_ParityChk?UART
?_UART_ParityChk?BYTE:
 checkByte?1359:   DS   1

	RSEG  ?XD?_UART_Init?UART
?_UART_Init?BYTE:
baudRateDiv?1157:   DS   2

	RSEG  ?XD?_putchar?UART
?_putchar?BYTE:
         c?1054:   DS   1

	RSEG  ?XD?UART
   uart0_RxHead:   DS   2
   uart1_RxHead:   DS   2
   uart0_TxHead:   DS   2
   uart1_TxHead:   DS   2
   uart0_TxFlag:   DS   1
   uart1_TxFlag:   DS   1
   uart0_RxTail:   DS   2
  uart0_RxCount:   DS   2
   uart1_RxTail:   DS   2
  uart1_RxCount:   DS   2
  uart0_TxCount:   DS   2
   uart0_TxTail:   DS   2
  uart1_TxCount:   DS   2
   uart1_TxTail:   DS   2
    uart0_RxBuf:   DS   512
    uart1_RxBuf:   DS   512
    uart0_TxBuf:   DS   512
    uart1_TxBuf:   DS   512
     uart0_Mode:   DS   1
     uart1_Mode:   DS   1
       uartPort:   DS   1

	RSEG  ?C_INITSEG
	DB	042H
	DW	uart0_TxHead
	DW	00000H

	DB	042H
	DW	uart0_TxTail
	DW	00000H

	DB	042H
	DW	uart0_TxCount
	DW	00000H

	DB	041H
	DW	uart0_TxFlag
	DB	000H

	DB	042H
	DW	uart0_RxHead
	DW	00000H

	DB	042H
	DW	uart0_RxTail
	DW	00000H

	DB	041H
	DW	uart0_Mode
	DB	000H

	DB	042H
	DW	uart0_RxCount
	DW	00000H

	DB	042H
	DW	uart1_TxHead
	DW	00000H

	DB	042H
	DW	uart1_TxTail
	DW	00000H

	DB	042H
	DW	uart1_TxCount
	DW	00000H

	DB	041H
	DW	uart1_TxFlag
	DB	000H

	DB	042H
	DW	uart1_RxHead
	DW	00000H

	DB	042H
	DW	uart1_RxTail
	DW	00000H

	DB	041H
	DW	uart1_Mode
	DB	000H

	DB	042H
	DW	uart1_RxCount
	DW	00000H

	DB	041H
	DW	uartPort
	DB	000H

; /*
;  *********************************************************************************
;  *     Copyright (c) 2005	ASIX Electronic Corporation      All rights reserved.
;  *
;  *     This is unpublished proprietary source code of ASIX Electronic Corporation
;  *
;  *     The copyright notice above does not evidence any actual or intended
;  *     publication of such source code.
;  *********************************************************************************
;  */
; /*================================================================================
;  * Module Name : uart.c
;  * Purpose     : The UART module driver. It manages the character
;  *               buffer and handles the ISR. This driver includes UART0 and UART1.
;  * Author      : Robin Lee
;  * Date        : 2006-01-10
;  * Notes       : None.
;  * $Log: uart.c,v $
;  * Revision 1.3  2006/05/18 02:15:34  robin6633
;  * 1.Add UART1 disable definition.
;  *
;  * Revision 1.2  2006/05/17 08:31:32  robin6633
;  * 1. Changed the default baudrate to 115200.
;  *
;  * Revision 1.1  2006/05/12 14:24:47  robin6633
;  * no message
;  *
;  * Revision 1.3  2006/05/03 02:45:55  robin6633
;  * Changed the the function name UART_GetBufCount()
;  * to UART_GetRxBufCount() .
;  *
;  * Revision 1.2  2006/05/02 01:43:40  robin6633
;  * Add an expanding function to get the counter value of UART software buffer.
;  *
;  * Revision 1.1  2006/04/07 11:39:14  robin6633
;  * no message
;  *
;  *================================================================================
;  */
; 
; /* INCLUDE FILE DECLARATIONS */
; #include	"reg80390.h"
; #include	"types.h"
; #include	"uart.h"
; #include	"ax11000_cfg.h"
; #if HSUR_ENABLE
; #include	"hsuart.h"
; #endif
; #include	"adapter_cfg.h"
; 
; 
; /* STATIC VARIABLE DECLARATIONS */
; #if UART0_ENABLE
; static U8_T		uart0_TxBuf[MAX_TX_UART0_BUF_SIZE];
; static U16_T	uart0_TxHead = 0;
; static U16_T	uart0_TxTail = 0;
; static U16_T	uart0_TxCount = 0;
; static U8_T		uart0_TxFlag = 0;
; static U8_T		uart0_RxBuf[MAX_RX_UART0_BUF_SIZE];
; static U16_T	uart0_RxHead = 0;
; static U16_T	uart0_RxTail = 0;
; static U8_T		uart0_Mode = 0;
; U16_T			uart0_RxCount = 0;
; #endif
; 
; #if UART1_ENABLE
; static U8_T		uart1_TxBuf[MAX_TX_UART1_BUF_SIZE];
; static U16_T	uart1_TxHead = 0;
; static U16_T	uart1_TxTail = 0;
; static U16_T	uart1_TxCount = 0;
; static U8_T		uart1_TxFlag = 0;
; static U8_T		uart1_RxBuf[MAX_RX_UART1_BUF_SIZE];
; static U16_T	uart1_RxHead = 0;
; static U16_T	uart1_RxTail = 0;
; static U8_T		uart1_Mode = 0;
; U16_T			uart1_RxCount = 0;
; #endif
; static U8_T		uartPort = 0;
; 
; 
; /* LOCAL SUBPROGRAM DECLARATIONS */
; #if UART0_ENABLE
; static void		uart0_ISR(void);
;  void		uart0_Init(void);
; static S8_T		uart0_PutChar(S8_T c);
; static S8_T		uart0_GetKey(void);
; static S8_T		UART0_NoBlockGetkey(void);
; #endif
; #if UART1_ENABLE
; static void		uart1_ISR(void);
; static void		uart1_Init(void);
; static S8_T		uart1_PutChar(S8_T c);
; static S8_T		uart1_GetKey(void);
; static S8_T		uart1_NoBlockGetkey(void);
; #endif
; 
; 
; 
; 
; /* LOCAL SUBPROGRAM BODIES */
; #if UART0_ENABLE
; /*
;  * ----------------------------------------------------------------------------
;  * static void UART0_ISR(void)
;  * Purpose : UART0 interrupt service routine. For sending out, it puts data
;  *           from software buffer into hardware serial buffer register (SBUF0).
;  *           For receiving, it gets data from hardware serial buffer register
;  *           (SBUF0) and stores into software buffer.
;  * Params  : none
;  * Returns : none
;  * Note    : none
;  * ----------------------------------------------------------------------------
;  */
; #if 1
CSEG	AT	06043H
	LJMP	UART0_ISR

; static void UART0_ISR(void) interrupt 4

	RSEG  ?PR?UART0_ISR?UART
	USING	0
UART0_ISR:
	PUSH 	ACC
	PUSH 	B
	PUSH 	DPX
	PUSH 	DPH
	PUSH 	DPL
	PUSH 	PSW
	MOV  	PSW,#00H
	PUSH 	AR0
	PUSH 	AR1
	PUSH 	AR2
	PUSH 	AR3
	PUSH 	AR4
	PUSH 	AR5
	PUSH 	AR6
	PUSH 	AR7
	USING	0
			; SOURCE LINE # 115
; {
; 	U8_T	parity = 0;
			; SOURCE LINE # 117
;---- Variable 'parity?040' assigned to Register 'R6' ----
	CLR  	A
	MOV  	R6,A
; 
; 	if (RI0)
			; SOURCE LINE # 119
	JNB  	RI0,?C0001
; 	{
			; SOURCE LINE # 120
; 		EA = 0;
			; SOURCE LINE # 121
	CLR  	EA
; 		if (uart0_RxCount != MAX_RX_UART0_BUF_SIZE) 
			; SOURCE LINE # 122
	MOV  	DPTR,#uart0_RxCount
	MOVX 	A,@DPTR
	XRL  	A,#02H
	JNZ  	?C0086
	INC  	DPTR
	MOVX 	A,@DPTR
?C0086:
	JZ   	?C0002
; 		{
			; SOURCE LINE # 123
; 			uart0_RxBuf[uart0_RxHead] = SBUF0;
			; SOURCE LINE # 124
	MOV  	DPTR,#uart0_RxHead
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	ADD  	A,#LOW (uart0_RxBuf)
	MOV  	DPL,A
	MOV  	A,#HIGH (uart0_RxBuf)
	ADDC 	A,R4
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,SBUF0
	MOVX 	@DPTR,A
; 			
; 			if (uart0_Mode & BIT1)
			; SOURCE LINE # 126
	MOV  	DPTR,#uart0_Mode
	MOVX 	A,@DPTR
	JNB  	ACC.1,?C0003
; 			{
			; SOURCE LINE # 127
; 				parity = UART_ParityChk((U8_T)uart0_RxBuf[uart0_RxHead]);
			; SOURCE LINE # 128
	MOV  	A,#LOW (uart0_RxBuf)
	ADD  	A,R5
	MOV  	DPL,A
	MOV  	A,#HIGH (uart0_RxBuf)
	ADDC 	A,R4
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R7,A
	LCALL	_UART_ParityChk
	MOV  	R6,AR7
; 				if (RB08 != parity)
			; SOURCE LINE # 129
	MOV  	C,RB08
	CLR  	A
	RLC  	A
	XRL  	A,R6
	JZ   	?C0003
; 					P3 = 0xE7;
			; SOURCE LINE # 130
	MOV  	P3,#0E7H
; 			}
			; SOURCE LINE # 131
?C0003:
; 
; 			uart0_RxCount++;
			; SOURCE LINE # 133
	MOV  	DPTR,#uart0_RxCount+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0087
	MOV  	DPTR,#uart0_RxCount
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0087:
; 			uart0_RxHead++;
			; SOURCE LINE # 134
	MOV  	DPTR,#uart0_RxHead+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0088
	MOV  	DPTR,#uart0_RxHead
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0088:
; 			uart0_RxHead &= MAX_RX_UART0_MASK;
			; SOURCE LINE # 135
	MOV  	DPTR,#uart0_RxHead
	MOVX 	A,@DPTR
	ANL  	A,#01H
	MOVX 	@DPTR,A
; 	    }
			; SOURCE LINE # 136
?C0002:
; 		RI0 = 0;
			; SOURCE LINE # 137
	CLR  	RI0
; 		EA = 1;
			; SOURCE LINE # 138
	SETB 	EA
; 	}
			; SOURCE LINE # 139
?C0001:
; 
; 	if (TI0)
			; SOURCE LINE # 141
	JNB  	TI0,?C0011
; 	{
			; SOURCE LINE # 142
; 		EA = 0;
			; SOURCE LINE # 143
	CLR  	EA
; 
; 		uart0_TxTail++;
			; SOURCE LINE # 145
	MOV  	DPTR,#uart0_TxTail+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0089
	MOV  	DPTR,#uart0_TxTail
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0089:
; 		uart0_TxTail &= MAX_TX_UART0_MASK;
			; SOURCE LINE # 146
	MOV  	DPTR,#uart0_TxTail
	MOVX 	A,@DPTR
	ANL  	A,#01H
	MOVX 	@DPTR,A
; 		uart0_TxCount--;
			; SOURCE LINE # 147
	MOV  	DPTR,#uart0_TxCount+01H
	MOVX 	A,@DPTR
	ADD  	A,#0FFH
	MOVX 	@DPTR,A
	MOV  	DPTR,#uart0_TxCount
	MOVX 	A,@DPTR
	ADDC 	A,#0FFH
	MOVX 	@DPTR,A
; 		if (uart0_TxCount > 0)
			; SOURCE LINE # 148
	SETB 	C
	INC  	DPTR
	MOVX 	A,@DPTR
	SUBB 	A,#00H
	MOV  	DPTR,#uart0_TxCount
	MOVX 	A,@DPTR
	SUBB 	A,#00H
	JC   	?C0006
; 		{
			; SOURCE LINE # 149
; 			SBUF0 = uart0_TxBuf[uart0_TxTail];
			; SOURCE LINE # 150
	MOV  	DPTR,#uart0_TxTail
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#LOW (uart0_TxBuf)
	MOV  	DPL,A
	MOV  	A,#HIGH (uart0_TxBuf)
	ADDC 	A,R4
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	SBUF0,A
; 
; 			if (uart0_Mode & BIT1)
			; SOURCE LINE # 152
	MOV  	DPTR,#uart0_Mode
	MOVX 	A,@DPTR
	JNB  	ACC.1,?C0010
; 			{
			; SOURCE LINE # 153
; 				parity = UART_ParityChk((U8_T)uart0_TxBuf[uart0_TxTail]);
			; SOURCE LINE # 154
	LCALL	_UART_ParityChk
; 				if (parity)
			; SOURCE LINE # 155
	MOV  	A,R7
	JZ   	?C0008
; 					TB08 = 1;
			; SOURCE LINE # 156
	SETB 	TB08
	SJMP 	?C0010
?C0008:
; 				else
; 					TB08 = 0;
			; SOURCE LINE # 158
	CLR  	TB08
; 			}
			; SOURCE LINE # 159
; 		}
			; SOURCE LINE # 160
	SJMP 	?C0010
?C0006:
; 		else
; 			uart0_TxFlag = 0;
			; SOURCE LINE # 162
	MOV  	DPTR,#uart0_TxFlag
	CLR  	A
	MOVX 	@DPTR,A
?C0010:
; 
; 		TI0 = 0;
			; SOURCE LINE # 164
	CLR  	TI0
; 		EA = 1;
			; SOURCE LINE # 165
	SETB 	EA
; 
; 	} /* End of if(TI0) */
			; SOURCE LINE # 167
; 
; } /* End of UART_Int */
			; SOURCE LINE # 169
?C0011:
	POP  	AR7
	POP  	AR6
	POP  	AR5
	POP  	AR4
	POP  	AR3
	POP  	AR2
	POP  	AR1
	POP  	AR0
	POP  	PSW
	POP  	DPL
	POP  	DPH
	POP  	DPX
	POP  	B
	POP  	ACC
	RETI 	
; END OF UART0_ISR

; 
; #endif
; 
; /*
;  * ----------------------------------------------------------------------------
;  * static void uart0_Init(void)
;  * Purpose : Setting operation mode of UART0 and initiating the global values.
;  * Params  : none
;  * Returns : none
;  * Note    : none
;  * ----------------------------------------------------------------------------
;  */
; static void uart0_Init(void)

	RSEG  ?PR?uart0_Init?UART
uart0_Init:
	USING	0
			; SOURCE LINE # 182
; {
			; SOURCE LINE # 183
; 	U8_T	sysClk = 0;
			; SOURCE LINE # 184
;---- Variable 'sysClk?141' assigned to Register 'R7' ----
	CLR  	A
	MOV  	R7,A
; 	U16_T	i;
; 
; 	uart0_TxHead = 0;
			; SOURCE LINE # 187
	MOV  	DPTR,#uart0_TxHead
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	uart0_TxTail = 0;
			; SOURCE LINE # 188
	MOV  	DPTR,#uart0_TxTail
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	uart0_TxCount = 0;
			; SOURCE LINE # 189
	MOV  	DPTR,#uart0_TxCount
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	uart0_TxFlag = 0;
			; SOURCE LINE # 190
	MOV  	DPTR,#uart0_TxFlag
	MOVX 	@DPTR,A
; 	uart0_RxHead = 0;
			; SOURCE LINE # 191
	MOV  	DPTR,#uart0_RxHead
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	uart0_RxTail = 0;
			; SOURCE LINE # 192
	MOV  	DPTR,#uart0_RxTail
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	uart0_RxCount = 0;
			; SOURCE LINE # 193
	INC  	DPTR
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	for (i=0 ; i<MAX_TX_UART0_BUF_SIZE ; i++)
			; SOURCE LINE # 194
;---- Variable 'i?142' assigned to Register 'R4/R5' ----
?C0012:
; 		uart0_TxBuf[i] = 0;
			; SOURCE LINE # 195
	MOV  	R4,#02H
	MOV  	R5,#00H
	MOV  	DPTR,#uart0_TxBuf
	CLR  	A
?C0090:
	MOVX 	@DPTR,A
	INC  	DPTR
	DJNZ 	R5,?C0090
	DJNZ 	R4,?C0090
?C0013:
; 	for (i=0 ; i<MAX_RX_UART0_BUF_SIZE ; i++)
			; SOURCE LINE # 196
?C0015:
; 		uart0_RxBuf[i] = 0;
			; SOURCE LINE # 197
	MOV  	R4,#02H
	MOV  	R5,#00H
	MOV  	DPTR,#uart0_RxBuf
	CLR  	A
?C0091:
	MOVX 	@DPTR,A
	INC  	DPTR
	DJNZ 	R5,?C0091
	DJNZ 	R4,?C0091
?C0016:
; 
; 	// Initialize TIMER1 for standard 8051 UART clock
; 	PCON = 0; /*|= 0x80;*/			// Disable BaudRate doubler.
			; SOURCE LINE # 200
	CLR  	A
	MOV  	PCON,A
; 	SM01  = 1;			// Use serial port 0 in mode 1 with 8-bits data.
			; SOURCE LINE # 201
	SETB 	SM01
; 	REN0  = 1;			// Enable UART0 receiver.
			; SOURCE LINE # 202
	SETB 	REN0
; 	TMOD  = 0x20;		// Use timer 1 in mode 2, 8-bit counter with auto-reload.
			; SOURCE LINE # 203
	MOV  	TMOD,#020H
; 	uart0_Mode = 1;
			; SOURCE LINE # 204
	MOV  	DPTR,#uart0_Mode
	INC  	A
	MOVX 	@DPTR,A
; 
; 	sysClk = CSREPR & 0xC0;
			; SOURCE LINE # 206
	MOV  	A,CSREPR
	ANL  	A,#0C0H
; 	switch (sysClk)
			; SOURCE LINE # 207
	JZ   	?C0022
	ADD  	A,#0C0H
	JZ   	?C0020
	ADD  	A,#080H
	JNZ  	?C0022
; 	{
			; SOURCE LINE # 208
; 		case SCS_100M :
			; SOURCE LINE # 209
?C0019:
; 			AX_DBG_LED(0x10);
			; SOURCE LINE # 210
; 			TH1 = 0xE4;		// Baud rate = 9600 @ 100MHz.
			; SOURCE LINE # 211
	MOV  	TH1,#0E4H
; 			break;
			; SOURCE LINE # 212
	SJMP 	?C0018
; 		case SCS_50M :
			; SOURCE LINE # 213
?C0020:
; 			AX_DBG_LED(0x50);
			; SOURCE LINE # 214
; 			TH1 = 0xF2;		// Baud rate = 9600 @ 50MHz.
			; SOURCE LINE # 215
	MOV  	TH1,#0F2H
; 			break;
			; SOURCE LINE # 216
	SJMP 	?C0018
; 		case SCS_25M :
			; SOURCE LINE # 217
; 			AX_DBG_LED(0x25);
; 			TH1 = 0xF9;		// Baud rate = 9600 @ 25MHz.
; 			break;
; 		default :
			; SOURCE LINE # 221
?C0022:
; 			AX_DBG_LED(0xAA);
			; SOURCE LINE # 222
; 			TH1 = 0xF9;		// Baud rate = 9600 @ 25MHz.
			; SOURCE LINE # 223
?C0117:
	MOV  	TH1,#0F9H
; 			break;
			; SOURCE LINE # 224
; 	}
			; SOURCE LINE # 225
?C0018:
; 
; 	ES0	= 1;				// Enable serial port Interrupt request
			; SOURCE LINE # 227
	SETB 	ES0
; 	TR1 = 1;				// Run Timer 1
			; SOURCE LINE # 228
	SETB 	TR1
; 	TI0 = 0;
			; SOURCE LINE # 229
	CLR  	TI0
; 
; } /* End of UART_Init */
			; SOURCE LINE # 231
	RET  	
; END OF uart0_Init

; 
; /*
;  * ----------------------------------------------------------------------------
;  * static S8_T uart0_PutChar(S8_T c)
;  * Purpose : UART0 output function. This function puts one byte data into the
;  *           software character buffer.
;  * Params  : c - one byte character.
;  * Returns : c - one byte character.
;  * Note    : none
;  * ----------------------------------------------------------------------------
;  */
; S8_T uart0_PutChar (S8_T c)

	RSEG  ?PR?_uart0_PutChar?UART
_uart0_PutChar:
	USING	0
			; SOURCE LINE # 243
;---- Variable 'c?243' assigned to Register 'R1' ----
	MOV  	R1,AR7
; {
			; SOURCE LINE # 244
; 	U16_T	count = 0;
			; SOURCE LINE # 245
;---- Variable 'count?244' assigned to Register 'R4/R5' ----
; 
; 	if (c == 0xa)
			; SOURCE LINE # 247
	MOV  	A,R7
	XRL  	A,#0AH
	JNZ  	?C0030
; 	{
			; SOURCE LINE # 248
?C0027:
; 		do
; 		{
			; SOURCE LINE # 250
; 			EA = 0;
			; SOURCE LINE # 251
	CLR  	EA
; 			count = uart0_TxCount; 
			; SOURCE LINE # 252
	MOV  	DPTR,#uart0_TxCount
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
; 			EA = 1;
			; SOURCE LINE # 253
	SETB 	EA
; 		} while (count == MAX_TX_UART0_BUF_SIZE);
			; SOURCE LINE # 254
	JNZ  	?C0092
	MOV  	A,R4
	XRL  	A,#02H
?C0092:
	JZ   	?C0027
; 		uart0_TxBuf[uart0_TxHead] = 0xd;
			; SOURCE LINE # 255
	MOV  	DPTR,#uart0_TxHead
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#LOW (uart0_TxBuf)
	MOV  	DPL,A
	MOV  	A,#HIGH (uart0_TxBuf)
	ADDC 	A,R2
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,#0DH
	MOVX 	@DPTR,A
; 		EA = 0;
			; SOURCE LINE # 256
	CLR  	EA
; 		uart0_TxCount++;
			; SOURCE LINE # 257
	MOV  	DPTR,#uart0_TxCount+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0093
	MOV  	DPTR,#uart0_TxCount
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0093:
; 		EA = 1;
			; SOURCE LINE # 258
	SETB 	EA
; 		uart0_TxHead++;
			; SOURCE LINE # 259
	MOV  	DPTR,#uart0_TxHead+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0094
	MOV  	DPTR,#uart0_TxHead
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0094:
; 		uart0_TxHead &= MAX_TX_UART0_MASK;
			; SOURCE LINE # 260
	MOV  	DPTR,#uart0_TxHead
	MOVX 	A,@DPTR
	ANL  	A,#01H
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 261
?C0030:
; 	do
; 	{
			; SOURCE LINE # 263
; 		EA = 0;
			; SOURCE LINE # 264
	CLR  	EA
; 		count = uart0_TxCount; 
			; SOURCE LINE # 265
	MOV  	DPTR,#uart0_TxCount
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
; 		EA = 1;
			; SOURCE LINE # 266
	SETB 	EA
; 	} while (count == MAX_TX_UART0_BUF_SIZE);
			; SOURCE LINE # 267
	JNZ  	?C0095
	MOV  	A,R4
	XRL  	A,#02H
?C0095:
	JZ   	?C0030
; 	uart0_TxBuf[uart0_TxHead] = c;
			; SOURCE LINE # 268
	MOV  	DPTR,#uart0_TxHead
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#LOW (uart0_TxBuf)
	MOV  	DPL,A
	MOV  	A,#HIGH (uart0_TxBuf)
	ADDC 	A,R6
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,R1
	MOVX 	@DPTR,A
; 	EA = 0;
			; SOURCE LINE # 269
	CLR  	EA
; 	uart0_TxCount++;
			; SOURCE LINE # 270
	MOV  	DPTR,#uart0_TxCount+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0096
	MOV  	DPTR,#uart0_TxCount
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0096:
; 	EA = 1;
			; SOURCE LINE # 271
	SETB 	EA
; 	uart0_TxHead++;
			; SOURCE LINE # 272
	MOV  	DPTR,#uart0_TxHead+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0097
	MOV  	DPTR,#uart0_TxHead
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0097:
; 	uart0_TxHead &= MAX_TX_UART0_MASK;
			; SOURCE LINE # 273
	MOV  	DPTR,#uart0_TxHead
	MOVX 	A,@DPTR
	ANL  	A,#01H
	MOVX 	@DPTR,A
; 
; 	if (!uart0_TxFlag)
			; SOURCE LINE # 275
	MOV  	DPTR,#uart0_TxFlag
	MOVX 	A,@DPTR
	JNZ  	?C0031
; 	{
			; SOURCE LINE # 276
; 		uart0_TxFlag = 1;
			; SOURCE LINE # 277
	INC  	A
	MOVX 	@DPTR,A
; 		SBUF0 = uart0_TxBuf[uart0_TxTail];
			; SOURCE LINE # 278
	MOV  	DPTR,#uart0_TxTail
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#LOW (uart0_TxBuf)
	MOV  	DPL,A
	MOV  	A,#HIGH (uart0_TxBuf)
	ADDC 	A,R6
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	SBUF0,A
; 	}
			; SOURCE LINE # 279
?C0031:
; 
; 	
; 	return c;
			; SOURCE LINE # 282
	MOV  	R7,AR1
; 
; }
			; SOURCE LINE # 284
?C0032:
	RET  	
; END OF _uart0_PutChar

; 
; /*
;  * ----------------------------------------------------------------------------
;  * static S8_T uart0_GetKey(void)
;  * Purpose : UART0 input function. This function replies one byte data from the
;  *           software character buffer.
;  * Params  : none
;  * Returns : c - one byte character.
;  * Note    : none
;  * ----------------------------------------------------------------------------
;  */
; S8_T uart0_GetKey (void)

	RSEG  ?PR?uart0_GetKey?UART
uart0_GetKey:
	USING	0
			; SOURCE LINE # 296
; {
			; SOURCE LINE # 297
;     /* NAMING CONSTANT DECLARATIONS */
; 
;     /* LOCAL VARIABLE DECLARATIONS */
;     S8_T	c = 0;
			; SOURCE LINE # 301
;---- Variable 'c?345' assigned to Register 'R5' ----
	CLR  	A
	MOV  	R5,A
?C0033:
;     /* BODY */
; 	while(uart0_RxCount == 0);
			; SOURCE LINE # 303
	MOV  	DPTR,#uart0_RxCount
	MOVX 	A,@DPTR
	JNZ  	?C0098
	INC  	DPTR
	MOVX 	A,@DPTR
?C0098:
	JZ   	?C0033
?C0034:
; 	EA = 0;
			; SOURCE LINE # 304
	CLR  	EA
; 	uart0_RxCount--;
			; SOURCE LINE # 305
	MOV  	DPTR,#uart0_RxCount+01H
	MOVX 	A,@DPTR
	ADD  	A,#0FFH
	MOVX 	@DPTR,A
	MOV  	DPTR,#uart0_RxCount
	MOVX 	A,@DPTR
	ADDC 	A,#0FFH
	MOVX 	@DPTR,A
; 	EA = 1;
			; SOURCE LINE # 306
	SETB 	EA
; 	c = uart0_RxBuf[uart0_RxTail];
			; SOURCE LINE # 307
	MOV  	DPTR,#uart0_RxTail
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#LOW (uart0_RxBuf)
	MOV  	DPL,A
	MOV  	A,#HIGH (uart0_RxBuf)
	ADDC 	A,R6
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R5,A
; 	uart0_RxTail++;
			; SOURCE LINE # 308
	MOV  	DPTR,#uart0_RxTail+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0099
	MOV  	DPTR,#uart0_RxTail
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0099:
; 	uart0_RxTail &= MAX_RX_UART0_MASK;
			; SOURCE LINE # 309
	MOV  	DPTR,#uart0_RxTail
	MOVX 	A,@DPTR
	ANL  	A,#01H
	MOVX 	@DPTR,A
; 	return c;
			; SOURCE LINE # 310
	MOV  	R7,AR5
; }
			; SOURCE LINE # 311
?C0035:
	RET  	
; END OF uart0_GetKey

; 
; /*
;  * ----------------------------------------------------------------------------
;  * static S8_T uart0_NoBlockGetkey(void)
;  * Purpose : UART0 input function. This function replies one byte data from the
;  *           software character buffer. But it only check the buffer one time.
;  *           If no data, it will reply a FALSE condition.
;  * Params  : none
;  * Returns : c - one byte character.
;  * Note    : none
;  * ----------------------------------------------------------------------------
;  */
; static S8_T UART0_NoBlockGetkey (void)

	RSEG  ?PR?UART0_NoBlockGetkey?UART
UART0_NoBlockGetkey:
	USING	0
			; SOURCE LINE # 324
; {
			; SOURCE LINE # 325
;     char c = 0;
			; SOURCE LINE # 326
;---- Variable 'c?446' assigned to Register 'R5' ----
; 
; 	if (uart0_RxCount !=0 )
			; SOURCE LINE # 328
	MOV  	DPTR,#uart0_RxCount
	MOVX 	A,@DPTR
	JNZ  	?C0100
	INC  	DPTR
	MOVX 	A,@DPTR
?C0100:
	JZ   	?C0036
; 	{
			; SOURCE LINE # 329
; 		EA = 0;
			; SOURCE LINE # 330
	CLR  	EA
; 		uart0_RxCount--;
			; SOURCE LINE # 331
	MOV  	DPTR,#uart0_RxCount+01H
	MOVX 	A,@DPTR
	ADD  	A,#0FFH
	MOVX 	@DPTR,A
	MOV  	DPTR,#uart0_RxCount
	MOVX 	A,@DPTR
	ADDC 	A,#0FFH
	MOVX 	@DPTR,A
; 		EA = 1;
			; SOURCE LINE # 332
	SETB 	EA
; 		c = uart0_RxBuf[uart0_RxTail];
			; SOURCE LINE # 333
	MOV  	DPTR,#uart0_RxTail
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#LOW (uart0_RxBuf)
	MOV  	DPL,A
	MOV  	A,#HIGH (uart0_RxBuf)
	ADDC 	A,R6
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R5,A
; 		uart0_RxTail++;
			; SOURCE LINE # 334
	MOV  	DPTR,#uart0_RxTail+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0101
	MOV  	DPTR,#uart0_RxTail
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0101:
; 		uart0_RxTail &= MAX_RX_UART0_MASK;
			; SOURCE LINE # 335
	MOV  	DPTR,#uart0_RxTail
	MOVX 	A,@DPTR
	ANL  	A,#01H
	MOVX 	@DPTR,A
; 		return c;
			; SOURCE LINE # 336
	MOV  	R7,AR5
	RET  	
; 	}
			; SOURCE LINE # 337
?C0036:
; 	else
; 	{
			; SOURCE LINE # 339
; 		return FALSE;
			; SOURCE LINE # 340
	MOV  	R7,#00H
; 	}
			; SOURCE LINE # 341
; }
			; SOURCE LINE # 342
?C0037:
	RET  	
; END OF UART0_NoBlockGetkey

; #endif
; 
; 
; #if UART1_ENABLE
; ////////////////////////////////////////////////////////////////////////////////
; /*
;  * ----------------------------------------------------------------------------
;  * static void UART1_ISR(void)
;  * Purpose : UART1 interrupt service routine. For sending out, it puts data
;  *           from software buffer into hardware serial buffer register (SBUF1).
;  *           For receiving, it gets data from hardware serial buffer register
;  *           (SBUF1) and stores into software buffer.
;  * Params  : none
;  * Returns : none
;  * Note    : none
;  * ----------------------------------------------------------------------------
;  */
; #if 0 
; static void uart1_ISR(void) interrupt 6
; {
; 	U8_T	parity = 0;
; 
; 	if (RI1)
; 	{
; 		EA = 0;
; 		if (uart1_RxCount != MAX_RX_UART1_BUF_SIZE) 
; 		{
; 			uart1_RxBuf[uart1_RxHead] = SBUF1;
; 
; 			if (uart1_Mode & BIT1)
; 			{
; 				parity = UART_ParityChk((U8_T)uart1_RxBuf[uart1_RxHead]);
; 				if (RB18 != parity)
; 					P3 = 0xE7;
; 			}
; 
; 			uart1_RxCount++;
; 			uart1_RxHead++;
; 			uart1_RxHead &= MAX_RX_UART1_MASK;
; 	    }
; 		RI1 = 0;
; 		EA = 1;
; 	} /* End of if(RI0) */
; 
; 	if (TI1)
; 	{
; 		EA = 0;
; 
; 		uart1_TxTail++;
; 		uart1_TxTail &= MAX_TX_UART1_MASK;
; 		uart1_TxCount--;
; 		if (uart1_TxCount > 0)
; 		{
; 			SBUF1 = uart1_TxBuf[uart1_TxTail];
; 			
; 			if (uart1_Mode & BIT1)
; 			{
; 				parity = UART_ParityChk((U8_T)uart1_TxBuf[uart1_TxTail]);
; 				if (parity)
; 					TB18 = 1;
; 				else
; 					TB18 = 0;
; 			}
; 		}
; 		else
; 			uart1_TxFlag = 0;
; 
; 		TI1 = 0;
; 		EA = 1;
; 
; 	} /* End of if(TI0) */
; 
; }
; #endif
; 
; /*
;  * ----------------------------------------------------------------------------
;  * static void uart1_Init(void)
;  * Purpose : Setting operation mode of UART1 and initiating the global values.
;  * Params  : none
;  * Returns : none
;  * Note    : none
;  * ----------------------------------------------------------------------------
;  */
; static void uart1_Init(void)

	RSEG  ?PR?uart1_Init?UART
uart1_Init:
	USING	0
			; SOURCE LINE # 427
; {
			; SOURCE LINE # 428
; 	U8_T	sysClk = 0;
			; SOURCE LINE # 429
;---- Variable 'sysClk?547' assigned to Register 'R7' ----
	CLR  	A
	MOV  	R7,A
; 	U16_T	i;
; 
; 	uart1_TxHead = 0;
			; SOURCE LINE # 432
	MOV  	DPTR,#uart1_TxHead
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	uart1_TxTail = 0;
			; SOURCE LINE # 433
	MOV  	DPTR,#uart1_TxTail
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	uart1_TxCount = 0;
			; SOURCE LINE # 434
	MOV  	DPTR,#uart1_TxCount
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	uart1_TxFlag = 0;
			; SOURCE LINE # 435
	MOV  	DPTR,#uart1_TxFlag
	MOVX 	@DPTR,A
; 	uart1_RxHead = 0;
			; SOURCE LINE # 436
	MOV  	DPTR,#uart1_RxHead
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	uart1_RxTail = 0;
			; SOURCE LINE # 437
	MOV  	DPTR,#uart1_RxTail
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	uart1_RxCount = 0;
			; SOURCE LINE # 438
	INC  	DPTR
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	for (i=0 ; i<MAX_TX_UART1_BUF_SIZE ; i++)
			; SOURCE LINE # 439
;---- Variable 'i?548' assigned to Register 'R4/R5' ----
?C0039:
; 		uart1_TxBuf[i] = 0;
			; SOURCE LINE # 440
	MOV  	R4,#02H
	MOV  	R5,#00H
	MOV  	DPTR,#uart1_TxBuf
	CLR  	A
?C0102:
	MOVX 	@DPTR,A
	INC  	DPTR
	DJNZ 	R5,?C0102
	DJNZ 	R4,?C0102
?C0040:
; 	for (i=0 ; i<MAX_RX_UART1_BUF_SIZE ; i++)
			; SOURCE LINE # 441
?C0042:
; 		uart1_RxBuf[i] = 0;
			; SOURCE LINE # 442
	MOV  	R4,#02H
	MOV  	R5,#00H
	MOV  	DPTR,#uart1_RxBuf
	CLR  	A
?C0103:
	MOVX 	@DPTR,A
	INC  	DPTR
	DJNZ 	R5,?C0103
	DJNZ 	R4,?C0103
?C0043:
; 
; 	// Initialize TIMER1 for standard 8051 UART clock
; 	PCON  = 0/*|= 0x40*/;			// Disable BaudRate doubler.
			; SOURCE LINE # 445
	CLR  	A
	MOV  	PCON,A
; 	SM10  = 0;
			; SOURCE LINE # 446
	CLR  	SM10
; 	SM11  = 1;			// Use serial port 1 in mode 1 with 8-bits data.
			; SOURCE LINE # 447
	SETB 	SM11
; 	REN1  = 1;			// Enable UART1 receiver.
			; SOURCE LINE # 448
	SETB 	REN1
; 	TMOD  = 0x20;		// Use timer 1 in mode 2, 8-bit counter with auto-reload.
			; SOURCE LINE # 449
	MOV  	TMOD,#020H
; 	uart1_Mode = 1;
			; SOURCE LINE # 450
	MOV  	DPTR,#uart1_Mode
	INC  	A
	MOVX 	@DPTR,A
; 
; 	sysClk = CSREPR & 0xC0;
			; SOURCE LINE # 452
	MOV  	A,CSREPR
	ANL  	A,#0C0H
; 	switch (sysClk)
			; SOURCE LINE # 453
	JZ   	?C0049
	ADD  	A,#0C0H
	JZ   	?C0047
	ADD  	A,#080H
	JNZ  	?C0049
; 	{
			; SOURCE LINE # 454
; 		case SCS_100M :
			; SOURCE LINE # 455
?C0046:
; 			AX_DBG_LED(0x10);
			; SOURCE LINE # 456
; 			TH1 = 0xE4;		// Baud rate = 9600 @ 100MHz.
			; SOURCE LINE # 457
	MOV  	TH1,#0E4H
; 			break;
			; SOURCE LINE # 458
	SJMP 	?C0045
; 		case SCS_50M :
			; SOURCE LINE # 459
?C0047:
; 			AX_DBG_LED(0x50);
			; SOURCE LINE # 460
; 			TH1 = 0xF2;		// Baud rate = 9600 @ 50MHz.
			; SOURCE LINE # 461
	MOV  	TH1,#0F2H
; 			break;
			; SOURCE LINE # 462
	SJMP 	?C0045
; 		case SCS_25M :
			; SOURCE LINE # 463
; 			AX_DBG_LED(0x25);
; 			TH1 = 0xF9;		// Baud rate = 9600 @ 25MHz.
; 			break;
; 		default :
			; SOURCE LINE # 467
?C0049:
; 			AX_DBG_LED(0xAA);
			; SOURCE LINE # 468
; 			TH1 = 0xF9;		// Baud rate = 9600 @ 25MHz.
			; SOURCE LINE # 469
?C0118:
	MOV  	TH1,#0F9H
; 			break;
			; SOURCE LINE # 470
; 	}
			; SOURCE LINE # 471
?C0045:
; 
; 	ES1	= 1;				// Enable serial port Interrupt request
			; SOURCE LINE # 473
	SETB 	ES1
; 	TR1 = 1;				// Run Timer 1
			; SOURCE LINE # 474
	SETB 	TR1
; 	TI1 = 0;
			; SOURCE LINE # 475
	CLR  	TI1
; 
; }
			; SOURCE LINE # 477
	RET  	
; END OF uart1_Init

; 
; /*
;  * ----------------------------------------------------------------------------
;  * static S8_T uart1_PutChar(S8_T c)
;  * Purpose : UART1 output function. This function puts one byte data into the
;  *           software character buffer.
;  * Params  : c - one byte character.
;  * Returns : c - one byte character.
;  * Note    : none
;  * ----------------------------------------------------------------------------
;  */
; S8_T uart1_PutChar(S8_T c)

	RSEG  ?PR?_uart1_PutChar?UART
_uart1_PutChar:
	USING	0
			; SOURCE LINE # 489
;---- Variable 'c?649' assigned to Register 'R1' ----
	MOV  	R1,AR7
; {
			; SOURCE LINE # 490
; 	U16_T	count = 0;
			; SOURCE LINE # 491
;---- Variable 'count?650' assigned to Register 'R4/R5' ----
; 
; 	if (c == 0xa)
			; SOURCE LINE # 493
	MOV  	A,R7
	XRL  	A,#0AH
	JNZ  	?C0057
; 	{
			; SOURCE LINE # 494
?C0054:
; 		do
; 		{
			; SOURCE LINE # 496
; 			EA = 0;
			; SOURCE LINE # 497
	CLR  	EA
; 			count = uart1_TxCount; 
			; SOURCE LINE # 498
	MOV  	DPTR,#uart1_TxCount
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
; 			EA = 1;
			; SOURCE LINE # 499
	SETB 	EA
; 		} while (count == MAX_TX_UART1_BUF_SIZE);
			; SOURCE LINE # 500
	JNZ  	?C0104
	MOV  	A,R4
	XRL  	A,#02H
?C0104:
	JZ   	?C0054
; 		uart1_TxBuf[uart1_TxHead] = 0xd;
			; SOURCE LINE # 501
	MOV  	DPTR,#uart1_TxHead
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#LOW (uart1_TxBuf)
	MOV  	DPL,A
	MOV  	A,#HIGH (uart1_TxBuf)
	ADDC 	A,R2
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,#0DH
	MOVX 	@DPTR,A
; 		EA = 0;
			; SOURCE LINE # 502
	CLR  	EA
; 		uart1_TxCount++;
			; SOURCE LINE # 503
	MOV  	DPTR,#uart1_TxCount+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0105
	MOV  	DPTR,#uart1_TxCount
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0105:
; 		EA = 1;
			; SOURCE LINE # 504
	SETB 	EA
; 		uart1_TxHead++;
			; SOURCE LINE # 505
	MOV  	DPTR,#uart1_TxHead+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0106
	MOV  	DPTR,#uart1_TxHead
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0106:
; 		uart1_TxHead &= MAX_TX_UART1_MASK;
			; SOURCE LINE # 506
	MOV  	DPTR,#uart1_TxHead
	MOVX 	A,@DPTR
	ANL  	A,#01H
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 507
?C0057:
; 	do
; 	{
			; SOURCE LINE # 509
; 		EA = 0;
			; SOURCE LINE # 510
	CLR  	EA
; 		count = uart1_TxCount; 
			; SOURCE LINE # 511
	MOV  	DPTR,#uart1_TxCount
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
; 		EA = 1;
			; SOURCE LINE # 512
	SETB 	EA
; 	} while (count == MAX_TX_UART1_BUF_SIZE);
			; SOURCE LINE # 513
	JNZ  	?C0107
	MOV  	A,R4
	XRL  	A,#02H
?C0107:
	JZ   	?C0057
; 	uart1_TxBuf[uart1_TxHead] = c;
			; SOURCE LINE # 514
	MOV  	DPTR,#uart1_TxHead
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#LOW (uart1_TxBuf)
	MOV  	DPL,A
	MOV  	A,#HIGH (uart1_TxBuf)
	ADDC 	A,R6
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,R1
	MOVX 	@DPTR,A
; 	EA = 0;
			; SOURCE LINE # 515
	CLR  	EA
; 	uart1_TxCount++;
			; SOURCE LINE # 516
	MOV  	DPTR,#uart1_TxCount+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0108
	MOV  	DPTR,#uart1_TxCount
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0108:
; 	EA = 1;
			; SOURCE LINE # 517
	SETB 	EA
; 	uart1_TxHead++;
			; SOURCE LINE # 518
	MOV  	DPTR,#uart1_TxHead+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0109
	MOV  	DPTR,#uart1_TxHead
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0109:
; 	uart1_TxHead &= MAX_TX_UART1_MASK;
			; SOURCE LINE # 519
	MOV  	DPTR,#uart1_TxHead
	MOVX 	A,@DPTR
	ANL  	A,#01H
	MOVX 	@DPTR,A
; 
; 	if (!uart1_TxFlag)
			; SOURCE LINE # 521
	MOV  	DPTR,#uart1_TxFlag
	MOVX 	A,@DPTR
	JNZ  	?C0058
; 	{
			; SOURCE LINE # 522
; 		uart1_TxFlag = 1;
			; SOURCE LINE # 523
	INC  	A
	MOVX 	@DPTR,A
; 		SBUF1 = uart1_TxBuf[uart1_TxTail];
			; SOURCE LINE # 524
	MOV  	DPTR,#uart1_TxTail
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#LOW (uart1_TxBuf)
	MOV  	DPL,A
	MOV  	A,#HIGH (uart1_TxBuf)
	ADDC 	A,R6
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	SBUF1,A
; 	}
			; SOURCE LINE # 525
?C0058:
; 	
; 	return c;
			; SOURCE LINE # 527
	MOV  	R7,AR1
; 
; }
			; SOURCE LINE # 529
?C0059:
	RET  	
; END OF _uart1_PutChar

; 
; /*
;  * ----------------------------------------------------------------------------
;  * static S8_T uart1_GetKey(void)
;  * Purpose : UART1 input function. This function replies one byte data from the
;  *           software character buffer.
;  * Params  : none
;  * Returns : c - one byte character.
;  * Note    : none
;  * ----------------------------------------------------------------------------
;  */
;  S8_T uart1_GetKey (void)

	RSEG  ?PR?uart1_GetKey?UART
uart1_GetKey:
	USING	0
			; SOURCE LINE # 541
; {
			; SOURCE LINE # 542
?C0060:
;     /* NAMING CONSTANT DECLARATIONS */
; 
;     /* LOCAL VARIABLE DECLARATIONS */
;     S8_T c;
;     /* BODY */
; 	while(uart1_RxCount==0);
			; SOURCE LINE # 548
	MOV  	DPTR,#uart1_RxCount
	MOVX 	A,@DPTR
	JNZ  	?C0110
	INC  	DPTR
	MOVX 	A,@DPTR
?C0110:
	JZ   	?C0060
?C0061:
; 	EA = 0;
			; SOURCE LINE # 549
	CLR  	EA
; 	uart1_RxCount--;
			; SOURCE LINE # 550
	MOV  	DPTR,#uart1_RxCount+01H
	MOVX 	A,@DPTR
	ADD  	A,#0FFH
	MOVX 	@DPTR,A
	MOV  	DPTR,#uart1_RxCount
	MOVX 	A,@DPTR
	ADDC 	A,#0FFH
	MOVX 	@DPTR,A
; 	EA = 1;
			; SOURCE LINE # 551
	SETB 	EA
; 	c = uart1_RxBuf[uart1_RxTail];
			; SOURCE LINE # 552
	MOV  	DPTR,#uart1_RxTail
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#LOW (uart1_RxBuf)
	MOV  	DPL,A
	MOV  	A,#HIGH (uart1_RxBuf)
	ADDC 	A,R6
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
;---- Variable 'c?751' assigned to Register 'R5' ----
	MOV  	R5,A
; 	uart1_RxTail++;
			; SOURCE LINE # 553
	MOV  	DPTR,#uart1_RxTail+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0111
	MOV  	DPTR,#uart1_RxTail
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0111:
; 	uart1_RxTail &= MAX_RX_UART1_MASK;
			; SOURCE LINE # 554
	MOV  	DPTR,#uart1_RxTail
	MOVX 	A,@DPTR
	ANL  	A,#01H
	MOVX 	@DPTR,A
; 	return c;
			; SOURCE LINE # 555
	MOV  	R7,AR5
; }
			; SOURCE LINE # 556
?C0062:
	RET  	
; END OF uart1_GetKey

; 
; /*
;  * ----------------------------------------------------------------------------
;  * static S8_T uart1_NoBlockGetkey(void)
;  * Purpose : UART1 input function. This function replies one byte data from the
;  *           software character buffer. But it only check the buffer one time.
;  *           If no data, it will reply a FALSE condition.
;  * Params  : none
;  * Returns : c - one byte character.
;  * Note    : none
;  * ----------------------------------------------------------------------------
;  */
; S8_T uart1_NoBlockGetkey (void)

	RSEG  ?PR?uart1_NoBlockGetkey?UART
uart1_NoBlockGetkey:
	USING	0
			; SOURCE LINE # 569
; {
			; SOURCE LINE # 570
;     char c = 0;
			; SOURCE LINE # 571
;---- Variable 'c?852' assigned to Register 'R5' ----
; 
; 	if (uart1_RxCount !=0 )
			; SOURCE LINE # 573
	MOV  	DPTR,#uart1_RxCount
	MOVX 	A,@DPTR
	JNZ  	?C0112
	INC  	DPTR
	MOVX 	A,@DPTR
?C0112:
	JZ   	?C0063
; 	{
			; SOURCE LINE # 574
; 		EA = 0;
			; SOURCE LINE # 575
	CLR  	EA
; 		uart1_RxCount--;
			; SOURCE LINE # 576
	MOV  	DPTR,#uart1_RxCount+01H
	MOVX 	A,@DPTR
	ADD  	A,#0FFH
	MOVX 	@DPTR,A
	MOV  	DPTR,#uart1_RxCount
	MOVX 	A,@DPTR
	ADDC 	A,#0FFH
	MOVX 	@DPTR,A
; 		EA = 1;
			; SOURCE LINE # 577
	SETB 	EA
; 		c = uart1_RxBuf[uart1_RxTail];
			; SOURCE LINE # 578
	MOV  	DPTR,#uart1_RxTail
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#LOW (uart1_RxBuf)
	MOV  	DPL,A
	MOV  	A,#HIGH (uart1_RxBuf)
	ADDC 	A,R6
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R5,A
; 		uart1_RxTail++;
			; SOURCE LINE # 579
	MOV  	DPTR,#uart1_RxTail+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0113
	MOV  	DPTR,#uart1_RxTail
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0113:
; 		uart1_RxTail &= MAX_RX_UART1_MASK;
			; SOURCE LINE # 580
	MOV  	DPTR,#uart1_RxTail
	MOVX 	A,@DPTR
	ANL  	A,#01H
	MOVX 	@DPTR,A
; 		return c;
			; SOURCE LINE # 581
	MOV  	R7,AR5
	RET  	
; 	}
			; SOURCE LINE # 582
?C0063:
; 	else
; 	{
			; SOURCE LINE # 584
; 		return FALSE;
			; SOURCE LINE # 585
	MOV  	R7,#00H
; 	}
			; SOURCE LINE # 586
; }
			; SOURCE LINE # 587
?C0064:
	RET  	
; END OF uart1_NoBlockGetkey

; #endif
; 
; 
; /* EXPORTED SUBPROGRAM BODIES */
; 
; /*
;  * ----------------------------------------------------------------------------
;  * S8_T _getkey (void)
;  * Purpose : UART getkey function. This function is the entry of getting
;  *           characters from software buffer of system's UART ports,
;  *           UART0, UART1 and HSUR. 
;  * Params  : none
;  * Returns : ch - one byte character.
;  * Note    : The default UART port is UART0.
;  * ----------------------------------------------------------------------------
;  */
; S8_T _getkey (void)

	RSEG  ?PR?_getkey?UART
_getkey:
	USING	0
			; SOURCE LINE # 604
; {
			; SOURCE LINE # 605
; 	S8_T	ch = 0;
			; SOURCE LINE # 606
;---- Variable 'ch?953' assigned to Register 'R7' ----
	CLR  	A
	MOV  	R7,A
; #if HSUR_ENABLE
; 	ch = HSUR_GetChar();
; #endif
; 	return ch;
			; SOURCE LINE # 610
; }
			; SOURCE LINE # 611
?C0066:
	RET  	
; END OF _getkey

; 
; /*
;  * ----------------------------------------------------------------------------
;  * S8_T putchar(S8_T c)
;  * Purpose : UART putchar function. This function is the entry of putting
;  *           characters into software buffer of system's UART ports,
;  *           UART0, UART1 and HSUR. 
;  * Params  : c - one byte character to be put.
;  * Returns : ch - the same character to be replied.
;  * Note    : The default UART port is UART0.
;  * ----------------------------------------------------------------------------
;  */
; S8_T putchar(S8_T c)

	RSEG  ?PR?_putchar?UART
_putchar:
	USING	0
			; SOURCE LINE # 624
	MOV  	DPTR,#c?1054
	MOV  	A,R7
	MOVX 	@DPTR,A
; {
			; SOURCE LINE # 625
; 	S8_T	ch = 0;
			; SOURCE LINE # 626
;---- Variable 'ch?1055' assigned to Register 'R7' ----
	CLR  	A
	MOV  	R7,A
; #if HSUR_ENABLE
; 	ch = HSUR_PutChar(c);
; #endif
; 	return ch;
			; SOURCE LINE # 630
; }
			; SOURCE LINE # 631
?C0067:
	RET  	
; END OF _putchar

; 
; /*
;  * ----------------------------------------------------------------------------
;  * void UART_Init(void)
;  * Purpose : UART initial function. It will call a real initial function
;  *           corresponding to the used UART port.
;  * Params  : none
;  * Returns : none
;  * Note    : none
;  * ----------------------------------------------------------------------------
;  */
; void UART_Init(U8_T port)

	RSEG  ?PR?_UART_Init?UART
_UART_Init:
	USING	0
			; SOURCE LINE # 643
;---- Variable 'port?1156' assigned to Register 'R7' ----
; {
			; SOURCE LINE # 644
; 	U16_T baudRateDiv = 0;
			; SOURCE LINE # 645
	CLR  	A
	MOV  	DPTR,#baudRateDiv?1157
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	if (port == 0)
			; SOURCE LINE # 646
	MOV  	A,R7
	JNZ  	?C0068
; 	{
			; SOURCE LINE # 647
; 		uart0_Init();
			; SOURCE LINE # 648
	LJMP 	uart0_Init
; 	}
			; SOURCE LINE # 649
?C0068:
; 	else if (port == 1)
			; SOURCE LINE # 650
	MOV  	A,R7
	CJNE 	A,#01H,?C0070
; 	{
			; SOURCE LINE # 651
; 		uart1_Init();
			; SOURCE LINE # 652
	LCALL	uart1_Init
; 	}
			; SOURCE LINE # 653
?C0070:
; 	else if (port == 2)
			; SOURCE LINE # 654
; 	{
			; SOURCE LINE # 655
; #if HSUR_ENABLE
; 	/* modify by chelsea, for adjusting baudRate */
; 		HSUR_InitValue();
; 		switch (CSREPR & (BIT6|BIT7))
; 		{
; 		    case SCS_25M:
; 		 		baudRateDiv = UR2_BR25_19200;
; 				break;
; 			case SCS_50M:
; 				baudRateDiv = UR2_BR50_19200;
; 				break;
; 			case SCS_100M:
; 				baudRateDiv = UR2_BR100_19200;
; 				break;
; 		}
; 
; 		HSUR_Setup(baudRateDiv, (UR2_CHAR_8|UR2_STOP_10), (UR2_RDI_ENB|UR2_RLSI_ENB),
; 			(UR2_FIFO_MODE|UR2_RXFIFO_RST|UR2_TXFIFO_RST|UR2_TRIG_08), UR2_RTS);
; 
; 	
; 	/*	HSUR_Setup(0x0010, (UR2_CHAR_8|UR2_STOP_10), (UR2_RDI_ENB|UR2_RLSI_ENB|UR2_MSI_ENB),
; 		(UR2_FIFO_MODE|UR2_RXFIFO_RST|UR2_TXFIFO_RST|UR2_TRIG_08), UR2_DTR | UR2_RTS);*/
; #endif
; 	}
			; SOURCE LINE # 679
; }
			; SOURCE LINE # 680
?C0073:
	RET  	
; END OF _UART_Init

; /*
;  * ----------------------------------------------------------------------------
;  * S8_T NOBLK_getkey (void)
;  * Purpose : UART no blocking getkey function with one checked. This function
;  *           is the entry of getting characters from software buffer of
;  *           system's UART ports, UART0, UART1 and HSUR.
;  * Params  : none
;  * Returns : ch - one byte character.
;  * Note    : The default UART port is UART0.
;  * ----------------------------------------------------------------------------
;  */
; S8_T NOBLK_getkey (void)

	RSEG  ?PR?NOBLK_getkey?UART
NOBLK_getkey:
	USING	0
			; SOURCE LINE # 692
; {
			; SOURCE LINE # 693
;     S8_T	c = 0;
			; SOURCE LINE # 694
;---- Variable 'c?1258' assigned to Register 'R7' ----
	CLR  	A
	MOV  	R7,A
; #if HSUR_ENABLE
; 	c = HSUR_GetCharNb();
; #endif
; 	return c;
			; SOURCE LINE # 698
; }
			; SOURCE LINE # 699
?C0074:
	RET  	
; END OF NOBLK_getkey

; 
; /*
;  * ----------------------------------------------------------------------------
;  * BOOL UART_ParityChk(S8_T checkByte)
;  * Purpose : UART parity checked function in one byte transfer.
;  * Params  : checkByte - one byte character.
;  * Returns : TRUE - odd parity ; FALSE - even parity.
;  * Note    : none
;  * ----------------------------------------------------------------------------
;  */
; BOOL UART_ParityChk(S8_T checkByte)

	RSEG  ?PR?_UART_ParityChk?UART
_UART_ParityChk:
	USING	0
			; SOURCE LINE # 710
	MOV  	DPTR,#checkByte?1359
	MOV  	A,R7
	MOVX 	@DPTR,A
; {
			; SOURCE LINE # 711
; 	U8_T	oneNum = 0;
			; SOURCE LINE # 712
;---- Variable 'oneNum?1360' assigned to Register 'R1' ----
	CLR  	A
	MOV  	R1,A
; 	U16_T	i;
; 
; 	oneNum = 0;
			; SOURCE LINE # 715
; 	for (i=0 ; i<=7 ; i++)
			; SOURCE LINE # 716
;---- Variable 'i?1361' assigned to Register 'R4/R5' ----
	MOV  	R5,A
	MOV  	R4,A
?C0075:
; 	{
			; SOURCE LINE # 717
; 		if (checkByte & (BIT0<<i))
			; SOURCE LINE # 718
	MOV  	R7,AR5
	MOV  	A,#01H
	MOV  	R6,#00H
	MOV  	R0,AR7
	INC  	R0
	SJMP 	?C0115
?C0114:
	CLR  	C
	RLC  	A
	XCH  	A,R6
	RLC  	A
	XCH  	A,R6
?C0115:
	DJNZ 	R0,?C0114
	MOV  	R7,A
	MOV  	DPTR,#checkByte?1359
	MOVX 	A,@DPTR
	MOV  	R3,A
	RLC  	A
	SUBB 	A,ACC
	ANL  	A,R6
	MOV  	R6,A
	MOV  	A,R7
	ANL  	A,R3
	ORL  	A,R6
	JZ   	?C0077
; 		{
			; SOURCE LINE # 719
; 			oneNum ++;
			; SOURCE LINE # 720
	INC  	R1
; 		}
			; SOURCE LINE # 721
; 	}
			; SOURCE LINE # 722
?C0077:
	INC  	R5
	CJNE 	R5,#00H,?C0116
	INC  	R4
?C0116:
	MOV  	A,R5
	XRL  	A,#08H
	ORL  	A,R4
	JNZ  	?C0075
?C0076:
; 	if ((oneNum % 2) == 0)
			; SOURCE LINE # 723
	MOV  	A,R1
	JB   	ACC.0,?C0079
; 		return FALSE;		// if '1' number is even, return 0
			; SOURCE LINE # 724
	CLR  	A
	MOV  	R6,A
	MOV  	R7,A
	RET  	
?C0079:
; 	else
; 		return TRUE;		// if '1' number is odd, return 1
			; SOURCE LINE # 726
	MOV  	R6,#00H
	MOV  	R7,#01H
; }
			; SOURCE LINE # 727
?C0080:
	RET  	
; END OF _UART_ParityChk

; 
; #if UART0_ENABLE
; /*
;  * ----------------------------------------------------------------------------
;  * void UART0_SetMode(U8_T mode)
;  * Purpose : Setting operation mode of UART0.
;  * Params  : mode - operation mode (0~3).
;  * Returns : none
;  * Note    : none
;  * ----------------------------------------------------------------------------
;  */
; void UART0_SetMode(U8_T mode)

	RSEG  ?PR?_UART0_SetMode?UART
_UART0_SetMode:
	USING	0
			; SOURCE LINE # 739
;---- Variable 'mode?1462' assigned to Register 'R7' ----
; {
			; SOURCE LINE # 740
; 	uart0_Mode = mode;
			; SOURCE LINE # 741
	MOV  	DPTR,#uart0_Mode
	MOV  	A,R7
	MOVX 	@DPTR,A
; }
			; SOURCE LINE # 742
	RET  	
; END OF _UART0_SetMode

; #endif
; 
; #if UART1_ENABLE
; /*
;  * ----------------------------------------------------------------------------
;  * void UART1_SetMode(U8_T mode)
;  * Purpose : Setting operation mode of UART0.
;  * Params  : mode - operation mode (0~3).
;  * Returns : none
;  * Note    : none
;  * ----------------------------------------------------------------------------
;  */
; void UART1_SetMode(U8_T mode)

	RSEG  ?PR?_UART1_SetMode?UART
_UART1_SetMode:
	USING	0
			; SOURCE LINE # 755
;---- Variable 'mode?1563' assigned to Register 'R7' ----
; {
			; SOURCE LINE # 756
; 	uart1_Mode = mode;
			; SOURCE LINE # 757
	MOV  	DPTR,#uart1_Mode
	MOV  	A,R7
	MOVX 	@DPTR,A
; }
			; SOURCE LINE # 758
	RET  	
; END OF _UART1_SetMode

; #endif
; 
; /*
;  * ----------------------------------------------------------------------------
;  * BOOL UART_SetPort(U8_T portNum)
;  * Purpose : Setting which UART port will be used.
;  * Params  : portNum - uart port number (0~2).
;  * Returns : none
;  * Note    : none
;  * ----------------------------------------------------------------------------
;  */
; BOOL UART_SetPort(U8_T portNum)

	RSEG  ?PR?_UART_SetPort?UART
_UART_SetPort:
	USING	0
			; SOURCE LINE # 770
;---- Variable 'portNum?1664' assigned to Register 'R7' ----
; {
			; SOURCE LINE # 771
; 	uartPort = portNum & 0x03;
			; SOURCE LINE # 772
	MOV  	A,R7
	ANL  	A,#03H
	MOV  	DPTR,#uartPort
	MOVX 	@DPTR,A
; 	UART_Init(0);
			; SOURCE LINE # 773
	CLR  	A
	MOV  	R7,A
	LCALL	_UART_Init
; 	UART_Init(1);
			; SOURCE LINE # 774
	MOV  	R7,#01H
	LCALL	_UART_Init
; 	return TRUE;
			; SOURCE LINE # 775
	MOV  	R6,#00H
	MOV  	R7,#01H
; }
			; SOURCE LINE # 776
?C0084:
	RET  	
; END OF _UART_SetPort

; 
; /*
;  * ----------------------------------------------------------------------------
;  * U16_T UART_GetRxBufCount(void)
;  * Purpose : Getting the remain character number in UART Rx buffer.
;  * Params  : none
;  * Returns : bufCount - the number of remain character in UART software RX buffer.
;  * Note    : none
;  * ----------------------------------------------------------------------------
;  */
; U16_T UART_GetRxBufCount(void)

	RSEG  ?PR?UART_GetRxBufCount?UART
UART_GetRxBufCount:
	USING	0
			; SOURCE LINE # 787
; {
			; SOURCE LINE # 788
; 	U16_T	bufCount = 0;
			; SOURCE LINE # 789
;---- Variable 'bufCount?1765' assigned to Register 'R6/R7' ----
	CLR  	A
	MOV  	R7,A
	MOV  	R6,A
; #if HSUR_ENABLE
; 	bufCount = HSUR_GetRxBufCount();
; #endif
; 	return bufCount;
			; SOURCE LINE # 793
; }
			; SOURCE LINE # 794
?C0085:
	RET  	
; END OF UART_GetRxBufCount

	END
