C51 COMPILER V9.00   COMMSUB                                                               05/08/2013 16:47:37 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE COMMSUB
OBJECT MODULE PLACED IN .\Build\commsub.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Modbus\commsub.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SR
                    -C\FreeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\SRC
                    -\UART\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;..
                    -\SRC\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management\;
                    -..\SRC\dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule;..\SRC\program;..\SRC\Scan
                    -) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\commsub.lst) OBJECT(.\Build\commsub.obj)

line level    source

   1          #include "main.h"
   2          #include "serial.h"
   3          #include "commsub.h"
   4          #include "schedule.h"
   5          #include "scan.h"
   6          
   7          #include <stdio.h>
   8          #include <stdlib.h>
   9          #include <string.h>
  10          
  11          #define CommTst_STACK_SIZE      ((unsigned portSHORT)1024)
  12          
  13          
  14          xTaskHandle far xCommTstTask;
  15          xQueueHandle    xSubRevQueue;
  16          
  17          
  18          U8_T tst_addr_index = 0;
  19          U8_T tst_reg_index = 0; 
  20          
  21          U8_T flag_send_scan_table;  
  22          
  23          U8_T tstat_product_model[8];
  24          U16_T tstat_temperature[8] = 0;
  25          U16_T tstat_mode[8] = 0;
  26          U16_T tstat_setpoint[8] = 15;
  27          U16_T tstat_cool_setpoint[8] = 0;
  28          U16_T tstat_heat_setpoint[8] = 0;
  29          U8_T tstat_occupied = 0; // occupied is 1 bit, 8 BIT is S8_T
  30          U8_T tstat_output_state[8];
  31          U8_T tstat_night_heat_db[8];
  32          U8_T tstat_night_cool_db[8];
  33          U8_T tstat_night_heat_sp[8];
  34          U8_T tstat_night_cool_sp[8];
  35          U8_T tstat_over_ride[8];
  36          U8_T tstat_serial_number[8][4];
  37          U8_T tstat_address[8];
  38          U8_T tstat_type[8];
  39          
  40          U8_T schedule_data[254];
  41          U8_T schedule_id;
  42          
  43          U8_T WRT_Tst_Reg = 0;
  44          U8_T WRT_Tst_ID = 0;
  45          
  46          
  47          const U16_T Tst_Register[Tst_reg_num][3] =      // 0 : tstat5ABCDEFG  1: tstat6   2:TST5EH
  48          {
  49                  {7,7,7},                 // TSTAT_PRODUCT_MODEL
  50                  {184,109,184},   //     TSTAT_OCCUPIED
C51 COMPILER V9.00   COMMSUB                                                               05/08/2013 16:47:37 PAGE 2   

  51                  {380,695,522},   // TSTAT_COOL_SETPOINT
  52                  {136,639,136},   // TSTAT_HEAT_SETPOINT
  53                  {135,638,135},
  54                  {101,121,101},
  55                  {107,102,107},
  56                  {108,209,108},
  57                  {123,352,123},
  58                  {124,353,124},
  59                  {182,354,182},
  60                  {183,355,183},
  61                  {6,6,6},
  62                  {211,111,211},
  63                  {0,0,0},
  64                  {1,1,1},
  65                  {2,2,2},
  66                  {3,3,3}
  67          };
  68          
  69          
  70          
  71          BinSearch far binsearch_Table[129];  // 129 is tested, the max time
  72          
  73          U8_T test1;
  74          U8_T test_index = 0;
  75          extern U8_T  ttt[50];
  76          // if the current search item is i, then the next search item is (2i + 1 , 2(i + 1))
  77          void Comm_Tstat_Initial_Data(void)
  78          {
  79   1              tstat_occupied = 0;
  80   1              memset(tstat_product_model,0,8);
  81   1              memset(tstat_temperature,0,16);
  82   1              memset(tstat_mode,0,16);
  83   1              memset(tstat_setpoint,0,16);
  84   1              memset(tstat_cool_setpoint,0,16);
  85   1              memset(tstat_heat_setpoint,0,16);
  86   1              memset(tstat_output_state,0,8);
  87   1              memset(tstat_night_heat_db,0,8);
  88   1              memset(tstat_night_cool_db,0,8);
  89   1              memset(tstat_night_heat_sp,0,8);
  90   1              memset(tstat_night_cool_sp,0,8);
  91   1      
  92   1              memset(tstat_over_ride,0,8);
  93   1              memset(tstat_serial_number,0,32);
  94   1              memset(tstat_address,0,8);
  95   1      
  96   1              memset(schedule_data,0,254);
  97   1      
  98   1      
  99   1              memset(tstat_type,0xff,8);
 100   1      
 101   1      }
 102          
 103          
 104          void Com_Tstat(U8_T  types,U8_T addr)
 105          {
 106   1              U8_T data send_buffer[8];
 107   1              U8_T i;
 108   1              U8_T type = tstat_type[tst_addr_index]; 
 109   1      
 110   1              sub_init_send_com();
 111   1              sub_init_crc16();
 112   1      //      Test[32] = type;
C51 COMPILER V9.00   COMMSUB                                                               05/08/2013 16:47:37 PAGE 3   

 113   1              if(type == 0xff)
 114   1              {
 115   2                      if(types == READ_PRODUCT_MODLE)
 116   2                              type = 0;
 117   2                      else
 118   2                              return;
 119   2              }
 120   1      
 121   1              if(types == READ_ROOM_SETPOINT)
 122   1              {
 123   2                      send_buffer[0] = addr;
 124   2                      send_buffer[1] = READ_VARIABLES;
 125   2                      send_buffer[2] = Tst_Register[TST_ROOM_SETPOINT][type]>>8;
 126   2                      send_buffer[3] = Tst_Register[TST_ROOM_SETPOINT][type];
 127   2                      send_buffer[4] = 0;
 128   2                      send_buffer[5] = 1;             
 129   2                      sub_send_string(&send_buffer,6);
 130   2              }
 131   1              else if(types == WRITE_ROOM_SETPOINT)
 132   1              {
 133   2                      send_buffer[0] = addr;
 134   2                      send_buffer[1] = WRITE_VARIABLES;
 135   2                      send_buffer[2] = Tst_Register[TST_ROOM_SETPOINT][type] >> 8;
 136   2                      send_buffer[3] = Tst_Register[TST_ROOM_SETPOINT][type];
 137   2                      send_buffer[4] = 0;
 138   2                      send_buffer[5] = tstat_setpoint[by_tstat_index];
 139   2                      sub_send_string(&send_buffer,6);
 140   2              }
 141   1              else if(types == READ_HEATTING_SETPOINT)
 142   1              {        
 143   2                      send_buffer[0] = addr;
 144   2                      send_buffer[1] = READ_VARIABLES;
 145   2                      send_buffer[2] = Tst_Register[TST_HEAT_SETPOINT][type] >> 8;
 146   2                      send_buffer[3] = Tst_Register[TST_HEAT_SETPOINT][type];//136;
 147   2                      send_buffer[4] = 0;
 148   2                      send_buffer[5] = 1;             
 149   2                      sub_send_string(&send_buffer,6);
 150   2              }
 151   1              else if(types == WRITE_HEATTING_SETPOINT)
 152   1              {
 153   2                      send_buffer[0] = addr;
 154   2                      send_buffer[1] = WRITE_VARIABLES;       
 155   2                      send_buffer[2] = Tst_Register[TST_HEAT_SETPOINT][type] >> 8;
 156   2                      send_buffer[3] = Tst_Register[TST_HEAT_SETPOINT][type];                         
 157   2                      send_buffer[4] = 0;
 158   2                      send_buffer[5] = tstat_heat_setpoint[by_tstat_index];
 159   2                      sub_send_string(&send_buffer,6);
 160   2              }
 161   1              else if(types == READ_COOLING_SETPOINT)
 162   1              {
 163   2                      send_buffer[0] = addr;
 164   2                      send_buffer[1] = READ_VARIABLES;        
 165   2                      send_buffer[2] = Tst_Register[TST_COOL_SETPOINT][type] >> 8; //0x01;
 166   2                      send_buffer[3] = Tst_Register[TST_COOL_SETPOINT][type];//0x7c;//TSTAT_COOL_SETPOINT;//380 = 0x17c;      
 167   2                      send_buffer[4] = 0;
 168   2                      send_buffer[5] = 1;             
 169   2                      sub_send_string(&send_buffer,6);
 170   2              }
 171   1              else if(types == WRITE_COOLING_SETPOINT)
 172   1              {
 173   2                      send_buffer[0] = addr;
 174   2                      send_buffer[1] = WRITE_VARIABLES;       
C51 COMPILER V9.00   COMMSUB                                                               05/08/2013 16:47:37 PAGE 4   

 175   2                      send_buffer[2] = Tst_Register[TST_COOL_SETPOINT][type] >> 8;
 176   2                      send_buffer[3] = Tst_Register[TST_COOL_SETPOINT][type]; 
 177   2                      send_buffer[4] = 0;
 178   2                      send_buffer[5] = tstat_cool_setpoint[by_tstat_index];
 179   2                      sub_send_string(&send_buffer,6);
 180   2              }
 181   1              else if(types == READ_TEMPERAUTE)
 182   1              {
 183   2                      send_buffer[0] = addr;
 184   2                      send_buffer[1] = READ_VARIABLES;        
 185   2                      send_buffer[2] = Tst_Register[TST_ROOM_TEM][type] >> 8;
 186   2                      send_buffer[3] = Tst_Register[TST_ROOM_TEM][type];//TSTAT_ROOM_TEM;//101;
 187   2                      send_buffer[4] = 0;
 188   2                      send_buffer[5] = 1;
 189   2                      sub_send_string(&send_buffer,6);                
 190   2              }
 191   1              else if(types == READ_MODE_OPERATION)
 192   1              {
 193   2                      send_buffer[0] = addr;
 194   2                      send_buffer[1] = READ_VARIABLES;        
 195   2                      send_buffer[2] = Tst_Register[TST_MODE][type] >> 8;//0;
 196   2                      send_buffer[3] = Tst_Register[TST_MODE][type];//TSTAT_MODE;//107;
 197   2                      send_buffer[4] = 0;
 198   2                      send_buffer[5] = 1;
 199   2                      sub_send_string(&send_buffer,6);                
 200   2              }
 201   1              else if(types == READ_OUTPUT_STATE)
 202   1              {       
 203   2                      send_buffer[0] = addr;
 204   2                      send_buffer[1] = READ_VARIABLES;        
 205   2                      send_buffer[2] = Tst_Register[TST_OUTPUT_STATE][type] >> 8;
 206   2                      send_buffer[3] = Tst_Register[TST_OUTPUT_STATE][type];//108;
 207   2                      send_buffer[4] = 0;
 208   2                      send_buffer[5] = 1;
 209   2                      sub_send_string(&send_buffer,6);                
 210   2              }
 211   1              else if(types == READ_OCCUPIED_STATE)
 212   1              {   // 184.0   read 
 213   2                      send_buffer[0] = addr;
 214   2                      send_buffer[1] = READ_VARIABLES;        
 215   2                      send_buffer[2] = Tst_Register[TST_OCCUPIED][type] >> 8;
 216   2                      send_buffer[3] = Tst_Register[TST_OCCUPIED][type];
 217   2                      send_buffer[4] = 0;
 218   2                      send_buffer[5] = 1;
 219   2                      sub_send_string(&send_buffer,6);                
 220   2              }
 221   1              else if(types == READ_NIGHT_HEAT_DB)
 222   1              {
 223   2                      send_buffer[0] = addr;
 224   2                      send_buffer[1] = READ_VARIABLES;
 225   2                      send_buffer[2] = Tst_Register[TST_NIGHT_HEAT_DB][type] >> 8;
 226   2                      send_buffer[3] = Tst_Register[TST_NIGHT_HEAT_DB][type];//123;
 227   2                      send_buffer[4] = 0;
 228   2                      send_buffer[5] = 1;
 229   2                      sub_send_string(&send_buffer,6);                                
 230   2              }
 231   1              else if(types == WRITE_NIGHT_HEAT_DB)
 232   1              {
 233   2                      send_buffer[0] = addr;
 234   2                      send_buffer[1] = WRITE_VARIABLES;
 235   2                      send_buffer[2] = Tst_Register[TST_NIGHT_HEAT_DB][type] >> 8;
 236   2                      send_buffer[3] = Tst_Register[TST_NIGHT_HEAT_DB][type];//123;
C51 COMPILER V9.00   COMMSUB                                                               05/08/2013 16:47:37 PAGE 5   

 237   2                      send_buffer[4] = 0;
 238   2                      send_buffer[5] = tstat_night_heat_db[by_tstat_index];
 239   2                      sub_send_string(&send_buffer,6);                
 240   2              }
 241   1              else if(types == READ_NIGHT_COOL_DB)
 242   1              {                       
 243   2                      send_buffer[0] = addr;
 244   2                      send_buffer[1] = READ_VARIABLES;
 245   2                      send_buffer[2] = Tst_Register[TST_NIGHT_COOL_DB][type] >> 8;
 246   2                      send_buffer[3] = Tst_Register[TST_NIGHT_COOL_DB][type];//124;
 247   2                      send_buffer[4] = 0;
 248   2                      send_buffer[5] = 1;
 249   2                      sub_send_string(&send_buffer,6);                
 250   2              }               
 251   1              else if(types == WRITE_NIGHT_COOL_DB)
 252   1              {               
 253   2                      send_buffer[0] = addr;
 254   2                      send_buffer[1] = WRITE_VARIABLES;
 255   2                      send_buffer[2] = Tst_Register[TST_NIGHT_COOL_DB][type] >> 8;
 256   2                      send_buffer[3] = Tst_Register[TST_NIGHT_COOL_DB][type];//124;
 257   2                      send_buffer[4] = 0;
 258   2                      send_buffer[5] = tstat_night_cool_db[by_tstat_index];
 259   2                      sub_send_string(&send_buffer,6);                
 260   2              }                
 261   1              else if(types == READ_NIGHT_HEAT_SP)
 262   1              {                       
 263   2                      send_buffer[0] = addr;
 264   2                      send_buffer[1] = READ_VARIABLES;
 265   2                      send_buffer[2] = Tst_Register[TST_NIGHT_HEAT_SP][type] >> 8;
 266   2                      send_buffer[3] = Tst_Register[TST_NIGHT_HEAT_SP][type];//182;
 267   2                      send_buffer[4] = 0;
 268   2                      send_buffer[5] = 1;
 269   2                      sub_send_string(&send_buffer,6);        
 270   2              }               
 271   1              else if(types == WRITE_NIGHT_HEAT_SP)
 272   1              {
 273   2                      send_buffer[0] = addr;
 274   2                      send_buffer[1] = WRITE_VARIABLES;
 275   2                      send_buffer[2] = Tst_Register[TST_NIGHT_HEAT_SP][type] >> 8;
 276   2                      send_buffer[3] = Tst_Register[TST_NIGHT_HEAT_SP][type];//182;
 277   2                      send_buffer[4] = 0;
 278   2                      send_buffer[5] = tstat_night_heat_sp[by_tstat_index];
 279   2                      sub_send_string(&send_buffer,6);
 280   2              }               
 281   1              else if(types == READ_NIGHT_COOL_SP)
 282   1              {                       
 283   2                      send_buffer[0] = addr;
 284   2                      send_buffer[1] = READ_VARIABLES;
 285   2                      send_buffer[2] = Tst_Register[TST_NIGHT_COOL_SP][type] >> 8;
 286   2                      send_buffer[3] = Tst_Register[TST_NIGHT_COOL_SP][type];//183;
 287   2                      send_buffer[4] = 0;
 288   2                      send_buffer[5] = 1;
 289   2                      sub_send_string(&send_buffer,6);                
 290   2              }
 291   1              else if(types == WRITE_NIGHT_COOL_SP)
 292   1              {                       
 293   2                      send_buffer[0] = addr;
 294   2                      send_buffer[1] = WRITE_VARIABLES;
 295   2                      send_buffer[2] = Tst_Register[TST_NIGHT_COOL_SP][type] >> 8;
 296   2                      send_buffer[3] = Tst_Register[TST_NIGHT_COOL_SP][type];//183;           
 297   2                      send_buffer[4] = 0;
 298   2                      send_buffer[5] = tstat_night_cool_sp[by_tstat_index];
C51 COMPILER V9.00   COMMSUB                                                               05/08/2013 16:47:37 PAGE 6   

 299   2                      sub_send_string(&send_buffer,6);                
 300   2              }               
 301   1              else if(types == READ_PRODUCT_MODLE)
 302   1              {                       
 303   2                      send_buffer[0] = addr;
 304   2                      send_buffer[1] = READ_VARIABLES;
 305   2                      send_buffer[2] = Tst_Register[TST_PRODUCT_MODEL][type] >> 8;
 306   2                      send_buffer[3] = Tst_Register[TST_PRODUCT_MODEL][type];//7;             
 307   2                      send_buffer[4] = 0;
 308   2                      send_buffer[5] = 1;
 309   2                      sub_send_string(&send_buffer,6);                
 310   2              }               
 311   1              else if(types == READ_OVER_RIDE)
 312   1              {                       
 313   2                      send_buffer[0] = addr;
 314   2                      send_buffer[1] = READ_VARIABLES;
 315   2                      send_buffer[2] = Tst_Register[TST_OVER_RIDE][type] >> 8;
 316   2                      send_buffer[3] = Tst_Register[TST_OVER_RIDE][type];//TSTAT_OVER_RIDE;//211              
 317   2                      send_buffer[4] = 0;
 318   2                      send_buffer[5] = 1;
 319   2                      sub_send_string(&send_buffer,6);                
 320   2              }       /* tstat_over_ride have two bytes  */
 321   1              else if(types == WRITE_OVER_RIDE)
 322   1              {                       
 323   2                      send_buffer[0] = addr;
 324   2                      send_buffer[1] = WRITE_VARIABLES;
 325   2                      send_buffer[2] = Tst_Register[TST_OVER_RIDE][type] >> 8;
 326   2                      send_buffer[3] = Tst_Register[TST_OVER_RIDE][type];//211                
 327   2                      send_buffer[4] = tstat_over_ride[by_tstat_index] >> 8;
 328   2                      send_buffer[5] = (U8_T)tstat_over_ride[by_tstat_index];
 329   2                      sub_send_string(&send_buffer,6);                
 330   2              }       /*  serial number have 4 bytes */
 331   1              else if(types == READ_SERIAL_NUMBER_0)
 332   1              {                       
 333   2                      send_buffer[0] = addr;
 334   2                      send_buffer[1] = READ_VARIABLES;
 335   2                      send_buffer[2] = Tst_Register[TST_SERIAL_NUM_0][type] >> 8;
 336   2                      send_buffer[3] = Tst_Register[TST_SERIAL_NUM_0][type]; // the start address of tstat serial number 
 337   2                      send_buffer[4] = 0;
 338   2                      send_buffer[5] = 1;  
 339   2                      sub_send_string(&send_buffer,6);                
 340   2              }                       
 341   1              else if(types == READ_SERIAL_NUMBER_1)
 342   1              {                       
 343   2                      send_buffer[0] = addr;
 344   2                      send_buffer[1] = READ_VARIABLES;
 345   2                      send_buffer[2] = Tst_Register[TST_SERIAL_NUM_1][type] >> 8;
 346   2                      send_buffer[3] = Tst_Register[TST_SERIAL_NUM_1][type]; // the start address of tstat serial number 
 347   2                      send_buffer[4] = 0;
 348   2                      send_buffer[5] = 1;  
 349   2                      sub_send_string(&send_buffer,6);                
 350   2              }                       
 351   1              else if(types == READ_SERIAL_NUMBER_2)
 352   1              {                       
 353   2                      send_buffer[0] = addr;
 354   2                      send_buffer[1] = READ_VARIABLES;
 355   2                      send_buffer[2] = Tst_Register[TST_SERIAL_NUM_2][type] >> 8;
 356   2                      send_buffer[3] = Tst_Register[TST_SERIAL_NUM_2][type]; // the start address of tstat serial number 
 357   2                      send_buffer[4] = 0;
 358   2                      send_buffer[5] = 1;  
 359   2                      sub_send_string(&send_buffer,6);                
 360   2              }                       
C51 COMPILER V9.00   COMMSUB                                                               05/08/2013 16:47:37 PAGE 7   

 361   1              else if(types == READ_SERIAL_NUMBER_3)
 362   1              {                       
 363   2                      send_buffer[0] = addr;
 364   2                      send_buffer[1] = READ_VARIABLES;
 365   2                      send_buffer[2] = Tst_Register[TST_SERIAL_NUM_3][type] >> 8;
 366   2                      send_buffer[3] = Tst_Register[TST_SERIAL_NUM_3][type]; // the start address of tstat serial number 
 367   2                      send_buffer[4] = 0;
 368   2                      send_buffer[5] = 1;  
 369   2                      sub_send_string(&send_buffer,6);                
 370   2              }                       
 371   1      /*      else if(types == READ_WALL_SETPOINT)
 372   1              {               
 373   1                      send_buffer[0] = addr;
 374   1                      send_buffer[1] = READ_VARIABLES;
 375   1                      send_buffer[2] = 1;  // 341 = 1 * 256 + 0x55
 376   1                      send_buffer[3] = 0x55;
 377   1                      send_buffer[4] = 0;
 378   1                      send_buffer[5] = 1;
 379   1                      sub_send_string(&send_buffer,6);
 380   1              }                
 381   1              else if(types == WRITE_WALL_SETPOINT)
 382   1              {                       
 383   1                      send_buffer[0] = addr;
 384   1                      send_buffer[1] = WRITE_VARIABLES;
 385   1                      send_buffer[2] = 1;  // 341 = 1 * 256 + 0x55
 386   1                      send_buffer[3] = 0x55;
 387   1                      send_buffer[4] = 0;
 388   1                      send_buffer[5] = tstat_setpoint[by_tstat_index];
 389   1                      sub_send_string(&send_buffer,6);
 390   1              }*/              
 391   1              else if(types == SEND_SCHEDUEL)
 392   1              {         // write command                                              
 393   2                      send_buffer[0] = send_schedual[0];
 394   2                      send_buffer[1] = send_schedual[1];                      
 395   2                      send_buffer[2] = Tst_Register[TST_OCCUPIED][type] >> 8;  
 396   2                      send_buffer[3] = Tst_Register[TST_OCCUPIED][type];
 397   2                      send_buffer[4] = send_schedual[4];
 398   2                      send_buffer[5] = send_schedual[5];
 399   2      
 400   2      
 401   2              /*      Test[40] = send_buffer[0];
 402   2                      Test[41] = send_buffer[1];
 403   2                      Test[42] = send_buffer[2];
 404   2                      Test[43] = send_buffer[3];
 405   2                      Test[44] = send_buffer[4];
 406   2                      Test[45] = send_buffer[5];
 407   2                      Test[46] = send_buffer[6];
 408   2                      Test[47] = send_buffer[7];
 409   2                      Test[48]++;     */
 410   2                      sub_send_string(&send_buffer,6);
 411   2              }               
 412   1              else if(types == READ_ADDRESS)  // read command 
 413   1              {                       
 414   2                      send_buffer[0] = addr;
 415   2                      send_buffer[1] = READ_VARIABLES;
 416   2                      send_buffer[2] = Tst_Register[TST_ADDRESS][type] >> 8;  
 417   2                      send_buffer[3] = Tst_Register[TST_ADDRESS][type];//6;
 418   2                      send_buffer[4] = 0;
 419   2                      send_buffer[5] = 1;
 420   2                      sub_send_string(&send_buffer,6);
 421   2              }       /*      case WRITE_ADDRESS:
 422   1                              send_buffer[0] = addr;
C51 COMPILER V9.00   COMMSUB                                                               05/08/2013 16:47:37 PAGE 8   

 423   1                              send_buffer[1] = WRITE_VARIABLES;                       
 424   1                              send_buffer[2] = 0;  
 425   1                              send_buffer[3] = TSTAT_ADDRESS;//184;
 426   1                              send_buffer[4] = 0;
 427   1                              send_buffer[5] = schedule_data[schedule_id];
 428   1                              sub_send_string(&send_buffer,6);
 429   1                              break;
 430   1              */      
 431   1              
 432   1      
 433   1              
 434   1      
 435   1              if(send_buffer[1] == READ_VARIABLES)
 436   1                      sub_rece_size = 7;
 437   1              else if(send_buffer[1] == WRITE_VARIABLES)
 438   1                      sub_rece_size = 8;
 439   1              sub_serial_restart();
 440   1              for(i = 0;i < 12;i++)
 441   1                      sub_data_buffer[i] = 0; 
 442   1              
 443   1                      
 444   1      }
 445          
 446          
 447          void internal_sub_deal(U8_T cmd_index,U8_T tst_addr_index,U8_T *sub_net_buf)
 448          {
 449   1              U8_T type = tstat_type[tst_addr_index]; 
 450   1              if(type == 0xff)
 451   1              {
 452   2                      if(cmd_index == READ_PRODUCT_MODLE)
 453   2                              type = 0;
 454   2                      else
 455   2                              return;
 456   2              }
 457   1              if(sub_net_buf[1] == READ_VARIABLES)
 458   1              {               
 459   2                      switch(cmd_index)
 460   2                      {                       
 461   3                              case READ_ROOM_SETPOINT:                        
 462   3                                      tstat_setpoint[tst_addr_index] = sub_net_buf[3] * 256 + sub_net_buf[4];                                         
 463   3                                      
 464   3                                      break;
 465   3                              case READ_HEATTING_SETPOINT:                            
 466   3                                      tstat_heat_setpoint[tst_addr_index] = sub_net_buf[3] * 256 + sub_net_buf[4];    
 467   3                                      
 468   3                                      break;
 469   3                              case READ_COOLING_SETPOINT:                             
 470   3                                      tstat_cool_setpoint[tst_addr_index] = sub_net_buf[3] * 256 + sub_net_buf[4];
 471   3                                      break;
 472   3                              case READ_TEMPERAUTE:
 473   3                                      tstat_temperature[tst_addr_index] = sub_net_buf[3] * 256 + sub_net_buf[4];
 474   3                                      break;                          
 475   3                              case READ_MODE_OPERATION:       
 476   3                              
 477   3                                      tstat_mode[tst_addr_index] = sub_net_buf[4];    
 478   3                                      break;  
 479   3                              case READ_OUTPUT_STATE: 
 480   3                                      tstat_output_state[tst_addr_index] = sub_net_buf[4];    
 481   3                                      break;  
 482   3                              case READ_OCCUPIED_STATE:       
 483   3                                      if(     sub_net_buf[5] == 1)
 484   3                                              tstat_occupied |= (0x01 << tst_addr_index);
C51 COMPILER V9.00   COMMSUB                                                               05/08/2013 16:47:37 PAGE 9   

 485   3                                      else 
 486   3                                              tstat_occupied &= ~(0x01 << tst_addr_index);
 487   3                                      
 488   3                                      break;  
 489   3                              case READ_NIGHT_HEAT_DB:        
 490   3                                      tstat_night_heat_db[tst_addr_index] = sub_net_buf[4];
 491   3                                      break;  
 492   3                              case READ_NIGHT_COOL_DB:
 493   3                                      tstat_night_cool_db[tst_addr_index] = sub_net_buf[4];
 494   3                                      break;  
 495   3                              case READ_NIGHT_HEAT_SP:
 496   3                                      tstat_night_heat_sp[tst_addr_index] = sub_net_buf[4];
 497   3                                      break;  
 498   3                              case READ_NIGHT_COOL_SP:
 499   3                                      tstat_night_cool_sp[tst_addr_index] = sub_net_buf[4];
 500   3                                      break;  
 501   3                              case READ_PRODUCT_MODLE:
 502   3                                      if(sub_net_buf[4] == 6)
 503   3                                              tstat_type[tst_addr_index] = TSTAT_6;
 504   3                                      else if(sub_net_buf[4] == 1 || sub_net_buf[4] == 2 ||sub_net_buf[4] == 3 ||sub_net_buf[4] == 4 ||sub_n
             -et_buf[4] == 12||sub_net_buf[4] == 17)
 505   3                                              tstat_type[tst_addr_index] = TSTAT_5A;
 506   3                                      else if(sub_net_buf[4] == 16 || sub_net_buf[4] == 19)
 507   3                                              tstat_type[tst_addr_index] = TSTAT_5E;
 508   3                                      tstat_product_model[tst_addr_index] = sub_net_buf[4];
 509   3                                      break;
 510   3                              case READ_OVER_RIDE:
 511   3                                      tstat_over_ride[tst_addr_index] = sub_net_buf[4];
 512   3                                      break;
 513   3                              case READ_SERIAL_NUMBER_0:
 514   3                                      tstat_serial_number[tst_addr_index][0] = sub_net_buf[4];
 515   3                                      break;  
 516   3                              case READ_SERIAL_NUMBER_1:
 517   3                                      tstat_serial_number[tst_addr_index][1] = sub_net_buf[4];
 518   3                                      break;  
 519   3                              case READ_SERIAL_NUMBER_2:
 520   3                                      tstat_serial_number[tst_addr_index][2] = sub_net_buf[4];
 521   3                                      break;  
 522   3                              case READ_SERIAL_NUMBER_3:
 523   3                                      tstat_serial_number[tst_addr_index][3] = sub_net_buf[4];
 524   3                                      break;  
 525   3                              case READ_WALL_SETPOINT:
 526   3                                      tstat_setpoint[tst_addr_index] = sub_net_buf[4];/*((U16_T)sub_net_buf[4] * 256 + sub_net_buf[5])/100;*
             -/
 527   3                                      break;
 528   3                              case READ_ADDRESS:
 529   3                                      //ttt[0] = sub_net_buf[3];
 530   3                                      //ttt[1] = sub_net_buf[4];
 531   3                                      break;
 532   3              
 533   3                              default:
 534   3                                      break;                          
 535   3                      }       
 536   2              }
 537   1              else if(sub_net_buf[1] == CHECKONLINE)  
 538   1              {
 539   2                      
 540   2              }       
 541   1      }
 542          
 543          
 544          
C51 COMPILER V9.00   COMMSUB                                                               05/08/2013 16:47:37 PAGE 10  

 545          
 546          
 547          
 548          
 549          void vStartCommSubTasks( U8_T uxPriority)
 550          {       
 551   1              xSubRevQueue = xQueueCreate(3,sizeof(U8_T) * 15);
 552   1              sTaskCreate(Comm_Tstat_task, (const signed portCHAR * const)"Comm_Tstat_task",CommTst_STACK_SIZE, NULL, u
             -xPriority, (xTaskHandle *)&xCommTstTask);
 553   1      
 554   1      }
 555          
 556          
 557          
 558          
 559          void Comm_Tstat_task(void)
 560          {
 561   1              portTickType xDelayPeriod = ( portTickType ) 100 / portTICK_RATE_MS;      
 562   1              static U16_T count = 0;
 563   1              for (;;)
 564   1              {
 565   2                      vTaskDelay( xDelayPeriod);      
 566   2                      
 567   2                      if(b_Master_Slave == TSTAT)             continue;
 568   2                      if(count < 30)
 569   2                      {       
 570   3                              vTaskDelay( xDelayPeriod);       
 571   3                              
 572   3                              count++;
 573   3      
 574   3                              if(sub_no == 0)   continue;     
 575   3                              
 576   3                              Test[3]++;
 577   3                              if(flag_control_by_button == 1)
 578   3                              {
 579   4                                      Com_Tstat(WRT_Tst_Reg,WRT_Tst_ID);      
 580   4                                      flag_control_by_button = 0;
 581   4                              }                       
 582   3                              else if(flag_send_schedual == 1)
 583   3                              {
 584   4                                      Com_Tstat(SEND_SCHEDUEL, 0);
 585   4      //                              Test[30]++;     
 586   4                                      flag_send_schedual = 0;
 587   4                              }
 588   3                              else
 589   3                              {
 590   4                                      Com_Tstat(tst_reg_index, sub_addr[tst_addr_index]);     
 591   4                                      wait_SubSerial(10);
 592   4                                      if(cQueueReceive( xSubRevQueue, &sub_data_buffer, 0))
 593   4                                      {
 594   5                                              U16_T crc_val = 0;
 595   5                                              crc_val = crc16(sub_data_buffer,5);     
 596   5                                              if(crc_val == sub_data_buffer[5] * 256 + sub_data_buffer[6])
 597   5                                              {       
 598   6                                                      internal_sub_deal(tst_reg_index,tst_addr_index,sub_data_buffer);
 599   6                                              }
 600   5                                      }       
 601   4              
 602   4              
 603   4                                      if(tst_reg_index < READ_SERIAL_NUMBER_3)
 604   4                                              tst_reg_index++;
 605   4                                      else
C51 COMPILER V9.00   COMMSUB                                                               05/08/2013 16:47:37 PAGE 11  

 606   4                                      {
 607   5                                              tst_reg_index = READ_ROOM_SETPOINT;     
 608   5                                              if(tst_addr_index <  sub_no)
 609   5                                                      tst_addr_index++;
 610   5                                              else
 611   5                                                      tst_addr_index = 0;
 612   5                                              
 613   5                                      }       
 614   4                              }                       
 615   3                                              
 616   3                      }
 617   2                      else
 618   2                      {
 619   3                              Test[14]++;
 620   3                              Scan_Sub_ID();
 621   3                              check_on_line();        
 622   3                              count = 0;
 623   3                      }       
 624   2              
 625   2              }
 626   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3630    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =    560      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =    648    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
