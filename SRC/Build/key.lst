C51 COMPILER V9.00   KEY                                                                   05/08/2013 16:47:36 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\Build\key.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE key\key.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\FreeR
                    -TOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\SRC\UART\;
                    -..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;..\SRC\GS
                    -M\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management\;..\SRC\
                    -dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule;..\SRC\program;..\SRC\Scan) DEFIN
                    -E(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\key.lst) OBJECT(.\Build\key.obj)

line level    source

   1           /*================================================================================
   2           * Module Name : key.c
   3           * Purpose     : key dirver and deal with back light and buzzer
   4           * Author      : Chelsea
   5           * Date        : 2008/11/10
   6           * Notes       : 
   7           * Revision        : 
   8           *      rev1.0
   9           *================================================================================
  10           */
  11          
  12          
  13          #define KEY
  14          #ifdef KEY
  15          
  16          #include "main.h"
  17          #include "key.h"
  18          
  19          /* CONSTANT DECLARATIONS */
  20          
  21          #define C_MAX_TIME       200
  22          #define C_TRUE_TIME      1
  23          #define C_HOLD_TIME_S    15
  24          #define C_HOLD_TIME_M    30
  25          #define C_HOLD_TIME_L    50
  26          
  27          
  28          
  29          #define C_BEEP                   1              /* last time when the buzzer is enabled */
  30          #define C_BACK               1200               /* last time when the backlit is enabled */
  31          
  32          #define         KEY_QUEUE_SIZE          3
  33          
  34          
  35          /* GLOBAL VARIABLE DECLARATIONS */
  36          U16_T w_Key_Count;
  37          //U8_T by_Key_Buffer;
  38          U8_T b_PressKey;
  39          U16_T w_Beep_Count;
  40          U16_T w_Backlit_Count;
  41          U8_T by_Key;                    /* the value of button */
  42          static U8_T by_shake_Count = 0;
  43          
  44          xTaskHandle xKeyTask;
  45          xQueueHandle xKeyQueue;
  46          
  47          
  48          
  49          
  50          /*
C51 COMPILER V9.00   KEY                                                                   05/08/2013 16:47:36 PAGE 2   

  51           *--------------------------------------------------------------------------------
  52           * void Key_Inital(void)
  53           * Purpose : initial I/O port and datas of Key
  54           * Params  : none
  55           * Returns : none
  56           * Note    : 
  57           *--------------------------------------------------------------------------------
  58           */
  59          
  60          // <summary>
  61          //  Key_Inital: Fuction for initialing I/O port and datas of Key
  62          //  </summary>
  63          void Key_Inital(void)
  64          {
  65   1              KEY_PRO = 1;
  66   1              KEY_SEL = 0;
  67   1              KEY_DOWN = 1;
  68   1              KEY_UP = 0;     
  69   1      //      KEY_LATCH = 0;
  70   1              
  71   1              w_Key_Count = 0;
  72   1              w_Beep_Count = 0;
  73   1              w_Backlit_Count = 0;
  74   1      //      BEEPER = BEEP_OFF;
  75   1              BACKLIT = BACK_ON;
  76   1              w_Backlit_Count = C_BACK;  // start up, light back board for 1min
  77   1      }
  78          
  79          
  80          /*
  81           *--------------------------------------------------------------------------------
  82           * void vStartKeyTasks( unsigned char uxPriority)
  83           * Purpose : start the KEY_TASK and create a queue for key event
  84           * Params  : none
  85           * Returns : none
  86           * Note    : 
  87           *--------------------------------------------------------------------------------
  88           */
  89          
  90          // <summary>
  91          //  vStartKeyTasks : Function for starting the KEY_TASK and creating a queue for key event
  92          //  </summary>
  93          //  <param name="uxPriority"> the priority of this KEY_TASK </param>
  94          
  95          void vStartKeyTasks( unsigned char uxPriority)
  96          {       
  97   1              sTaskCreate(Key_Process, (const signed portCHAR * const)"key_task",portMINIMAL_STACK_SIZE, NULL, uxPriori
             -ty, (xTaskHandle *)&xKeyTask);
  98   1              xKeyQueue = xQueueCreate(KEY_QUEUE_SIZE,sizeof(U8_T));
  99   1      }
 100          
 101          
 102          
 103          /*
 104           *--------------------------------------------------------------------------------
 105           * void Key_Process(void)
 106           * Purpose : key task
 107           *                      1. check key event,send the value of the key to another task
 108           *                      2. control the back light and buzzer
 109           * Params  : none
 110           * Returns : none
 111           * Note    : 
C51 COMPILER V9.00   KEY                                                                   05/08/2013 16:47:36 PAGE 3   

 112           *--------------------------------------------------------------------------------
 113           */
 114          
 115          // <summary>
 116          //  Key_Process : Function for dealing with key task
 117          //  1. check key event,send the value of the key to another task
 118          //      2. control the back light and buzzer
 119          //  </summary>
 120          extern xTaskHandle far Handle_PWMoutput;
 121          
 122          void Key_Process(void) reentrant
 123          {
 124   1              U8_T by_Dat = K_NONE;
 125   1              U8_T by_Out = K_NONE;
 126   1              U8_T by_Key_Buffer = 0;
 127   1              portTickType xDelayPeriod = ( portTickType ) 50 / portTICK_RATE_MS;       
 128   1      //      portTickType xLastWakeTime = xTaskGetTickCount();
 129   1      
 130   1              for (;;)
 131   1              {
 132   2                      by_Dat = K_NONE;
 133   2                      by_Out = K_NONE;
 134   2                      vTaskDelay(xDelayPeriod);
 135   2                      Test[10]++;
 136   2              //      EA = 0;
 137   2                      
 138   2              
 139   2                      DI1_LATCH = 1; 
 140   2                      DI2_LATCH = 1; 
 141   2                      RELAY_LATCH = 0;
 142   2                      KEY_LATCH = 0;
 143   2                      P0 = 0xff;
 144   2                      DELAY_Us(10); 
 145   2                      by_Key_Buffer = P0 & 0xcc;  // KEYPAND P0 
 146   2                      KEY_LATCH = 1;
 147   2      //              EA = 1;  
 148   2                       
 149   2              
 150   2              #if 0
                              by_Key = K_NONE; 
              
                              if(!(by_Key_Buffer & 0x04))             by_Key = K_PROGRAM;
                              if(!(by_Key_Buffer & 0x08))                 by_Key = K_SELECT;
                              if(!(by_Key_Buffer & 0x40))             by_Key = K_UP;
                              if(!(by_Key_Buffer & 0x80))             by_Key = K_DOWN;
                      #endif
 158   2      #if 1
 159   2                      // by_shake_Count, avoid shakeing
 160   2                      if(by_shake_Count < 2)          by_shake_Count++;
 161   2                      else   
 162   2                      {
 163   3                              by_shake_Count = 0;
 164   3                              b_PressKey = 1;
 165   3                      }
 166   2                      if(!b_PressKey) 
 167   2                      {
 168   3                              by_Key = K_NONE; 
 169   3                              if(xKeyQueue != 0)
 170   3                              {
 171   4                                      cQueueSend( xKeyQueue, ( void * )&by_Key, 10);                          
 172   4                              } 
 173   3                              continue;        
C51 COMPILER V9.00   KEY                                                                   05/08/2013 16:47:36 PAGE 4   

 174   3                      }
 175   2                      b_PressKey = 0;
 176   2              
 177   2              /*  check the P2 to get the value of the key */
 178   2              /*      if(!(by_Key_Buffer & 0x04))             {by_Dat = K_PROGRAM; Test[35]++;}
 179   2                      if(!(by_Key_Buffer & 0x08))                 {by_Dat = K_SELECT; Test[36]++;}
 180   2                      if(!(by_Key_Buffer & 0x40))             {by_Dat = K_UP;  Test[37]++;}
 181   2                      if(!(by_Key_Buffer & 0x80))             {by_Dat = K_DOWN;Test[38]++;} */
 182   2                      if(by_Key_Buffer == 200)                {by_Dat = K_PROGRAM; }
 183   2                      if(by_Key_Buffer == 196)                {by_Dat = K_SELECT;}
 184   2                      if(by_Key_Buffer == 140)                {by_Dat = K_UP; }
 185   2                      if(by_Key_Buffer == 76)                 {by_Dat = K_DOWN;}
 186   2      
 187   2                      /* the following are combine keys*/ 
 188   2                      //if(!(by_Key_Buffer & 0x80) && !(by_Key_Buffer & 0x40))  by_Dat = K_UP_DOWN;
 189   2                      //if(!(by_Key_Buffer & 0x04) && !(by_Key_Buffer & 0x08))  by_Dat = K_SEL_PRO;
 190   2      
 191   2                      if(by_Dat == K_NONE)
 192   2                      {
 193   3                          w_Key_Count = 0;
 194   3                              by_Key = K_NONE;
 195   3                              if(xKeyQueue != 0)
 196   3                              {
 197   4                                      cQueueSend( xKeyQueue, ( void * )&by_Key, 10);
 198   4                              }       //  aviod shakeing                              
 199   3                              continue;
 200   3                      }
 201   2      
 202   2                      if(w_Key_Count < C_MAX_TIME)    ++w_Key_Count;
 203   2              
 204   2                      if(w_Key_Count == C_TRUE_TIME)
 205   2                      {
 206   3              //   press any button, 1 beep  100ms                    
 207   3      
 208   3                              w_Beep_Count = C_BEEP;
 209   3                              w_Backlit_Count = C_BACK;
 210   3                              BACKLIT = BACK_ON;      
 211   3                              by_Out = by_Dat;
 212   3                              
 213   3      
 214   3                      }
 215   2              //  add press up and down longer, +/- 1
 216   2                      if(w_Key_Count > C_HOLD_TIME_S)
 217   2                      {
 218   3                          if(by_Dat == K_DOWN || by_Dat == K_UP)
 219   3                          {
 220   4                              if((w_Key_Count % C_TRUE_TIME) == 0)
 221   4                              {
 222   5                                      by_Out = by_Dat;
 223   5                              }
 224   4                          }
 225   3                      }
 226   2                      #if 0
                              if(w_Key_Count == C_HOLD_TIME_M)
                              {
                              if(by_Dat == K_SELECT || by_Dat == K_SEL_PRO||by_Dat == K_PROGRAM ||by_Dat == K_UP_SEL || by_Dat =
             -= K_DOWN_SEL )
                              {
                                      by_Out = by_Dat + 0x80;
                              }
                              }
                              /* K_RESET hold 5s */
C51 COMPILER V9.00   KEY                                                                   05/08/2013 16:47:36 PAGE 5   

                              if(w_Key_Count == C_HOLD_TIME_L)  
                              {
                                      if(by_Dat == K_UP_DOWN)
                              {
                                      by_Out = by_Dat + 0x80;
                              }
                              }
                               #endif
 243   2                      by_Key = by_Out;   
 244   2      
 245   2                      if(xKeyQueue != 0)
 246   2                      {
 247   3                              cQueueSend( xKeyQueue, ( void * )&by_Key, 10 );
 248   3                      } 
 249   2                continue;
 250   2      
 251   2      #endif
 252   2      
 253   2              }
 254   1      }
 255          
 256          
 257          
 258          #endif
 259          
 260          
 261          
 262          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    789    ----
   CONSTANT SIZE    =      9    ----
   XDATA SIZE       =     15    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
