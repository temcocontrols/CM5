C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE HSUART
OBJECT MODULE PLACED IN .\Build\hsuart.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE hsur\hsuart.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\F
                    -reeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\SRC\UA
                    -RT\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;..\SR
                    -C\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management\;..\
                    -SRC\dhcp\;..\SRC\pppoe\;..\SRC\MINI_262\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule) DEFINE(KEIL
                    -_AX11000) VARBANKING DEBUG PRINT(.\Build\hsuart.lst) OBJECT(.\Build\hsuart.obj)

line level    source

   1          /*
   2           *********************************************************************************
   3           *     Copyright (c) 2005   ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           *********************************************************************************
  10           */
  11          /*================================================================================
  12           * Module Name : hsuart.c
  13           * Purpose     : The High Speed UART module driver. It manages the character
  14           *               buffer and handles the ISR.
  15           * Author      : Robin Lee
  16           * Date        : 2006-01-09
  17           * Notes       : None.
  18           * $Log: hsuart.c,v $
  19           * Revision 1.20  2006/07/25 03:41:23  robin6633
  20           * 1.Add Xon/Xoff counter for debugging.
  21           *
  22           * Revision 1.19  2006/07/24 06:40:51  robin6633
  23           * 1.Fixed the XON/XOFF ASCII is put into hardware transmitting register driectly.
  24           *
  25           * Revision 1.18  2006/07/21 11:24:55  robin6633
  26           * 1.Add flow control check in hsurFlowOn==1.
  27           *
  28           * Revision 1.17  2006/07/19 08:51:24  robin6633
  29           * 1.Fixed Hardware flow control function.
  30           * 2.Extern a function HSUR_GetLineStatus() to get UR2_LSR.
  31           *
  32           * Revision 1.16  2006/07/18 08:03:59  robin6633
  33           * 1.Fixed Tx flow control in software flow control mode.
  34           *
  35           * Revision 1.15  2006/06/30 06:17:01  robin6633
  36           * 1.Fixed software flow control in first initial.
  37           *
  38           * Revision 1.14  2006/06/27 10:45:24  robin6633
  39           * 1.Add flow control for transmitting.
  40           *
  41           * Revision 1.13  2006/06/19 14:20:57  robin6633
  42           * 1.Protect transmit counter and pointer.
  43           * 2.Force transmit more data if transmit fifo empty.
  44           *
  45           * Revision 1.12  2006/06/11 02:18:49  robin6633
  46           * 1.Add Xon/Xoff.
  47           *
  48           * Revision 1.11  2006/06/05 06:21:43  robin6633
  49           * 1.Fixed function declaration.
  50           *    U8_T HSUR_RxBufFlowControl(void) -> void HSUR_RxBufFlowControl(void)
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 2   

  51           * 2.Fixed hsur_ReadLsr() & hsur_ReadMsr().
  52           *
  53           * Revision 1.10  2006/06/05 01:30:44  robin6633
  54           * 1.Fixed software flow control and prevented the hardware FIFO overrun.
  55           *
  56           * Revision 1.9  2006/05/24 05:40:34  robin6633
  57           * 1.Add flow control water mark.
  58           *
  59           * Revision 1.8  2006/05/23 11:07:51  robin6633
  60           * 1.Enable flow control code.
  61           *
  62           * Revision 1.7  2006/05/22 13:23:42  robin6633
  63           * 1.Fixed buffer overwrite.
  64           *
  65           * Revision 1.6  2006/05/22 07:39:28  robin6633
  66           * 1.Disable flow control.
  67           *
  68           * Revision 1.5  2006/05/19 06:37:13  robin6633
  69           * 1.Fixed the baudrate setup for default configuration.
  70           *
  71           * Revision 1.4  2006/05/19 03:48:37  robin6633
  72           * 1.Add Xon/Xoff flow control.
  73           * 2.Expand an external function HSUR_ChangeBaud(U8_T baud).
  74           *
  75           * Revision 1.3  2006/05/18 09:57:55  Louis
  76           * no message
  77           *
  78           * Revision 1.2  2006/05/18 02:27:56  robin6633
  79           * 1.Removed printf in UART2.
  80           *
  81           * Revision 1.1  2006/05/15 03:06:52  robin6633
  82           * no message
  83           *
  84           * Revision 1.3  2006/05/03 02:42:30  robin6633
  85           * Changed the the function name HSUR_GetBufCount()
  86           * to HSUR_GetRxBufCount() .
  87           *
  88           * Revision 1.2  2006/05/02 01:44:07  robin6633
  89           * Add an expanding function to get the counter value of UART2 software buffer.
  90           *
  91           * Revision 1.1  2006/04/07 11:38:18  robin6633
  92           * no message
  93           *
  94           *================================================================================
  95           */
  96          
  97          /* INCLUDE FILE DECLARATIONS */
  98          #include        "reg80390.h"
  99          #include        "types.h"
 100          #include        "uart.h"
 101          #include        "mstimer.h"
 102          #include        "hsuart.h"
*** WARNING C322 IN LINE 167 OF HSUR\HSUART.H: unknown identifier
 103          #include        "string.h"
 104          
 105          
 106          /* STATIC VARIABLE DECLARATIONS */
 107          
 108           U8_T   far     hsurRxBuffer[UR2_MAX_RX_SIZE];
 109          static U8_T     far     hsurTxBuffer[UR2_MAX_TX_SIZE];
 110          static U16_T far        hsurRxBufNum = 0;
 111          static U16_T far        hsurTxBufNum = 0;
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 3   

 112          static U8_T      far    hsurRxTrigLvl = 0;
 113           U16_T  far hsurRxCount = 0;
 114          static S16_T far        hsurTxCount = 0;
 115          static U16_T far        hsurGetPtr = 0;
 116          static U16_T far        hsurPutPtr = 0;
 117          static U8_T      far    hsurFlowCtrl = 0;
 118          static U8_T      far    hsurFlowOn = 0;
 119          static U8_T      far    hsurTxTransmit = 0;
 120          static U8_T      far    hsurTxFlag = 0;
 121          static U8_T      far    hsurTxState = 0;
 122          static U16_T far        hsurErrorCount = 0;
 123          static U32_T far        hsurErrTimeStart = 0;
 124          static U32_T far        hsurErrTimeStop = 0;
 125          static U8_T      far    hsurErrBlocking = 0;
 126          static U16_T far        hsurBaudRateDivisor = 0;
 127          static U8_T      far    hsurLineStatusValue = 0;
 128          static U8_T      far    hsurModemStatusValue = 0;       
 129          static U8_T      far    hsurLineControlValue = 0;
 130          static U8_T      far    hsurModemControlValue = 0;
 131          static U8_T      far    hsurFifoControlValue = 0;
 132          static U8_T      far    hsurAppFlowOn = 0;
 133          static U8_T     far  hsurFlowCtrlXoff = FALSE;
 134          static U8_T    far  hsurFlowCtrlXon = FALSE;
 135          static U8_T      far    hsurFlowCtrlHwCTSon = FALSE;
 136          
 137          
 138          /* LOCAL SUBPROGRAM DECLARATIONS */
 139          static void             hsur_ReadLsr(void);
 140          static void             hsur_RcvrTrig(void);
 141          static void             hsur_Rcvr(void);
 142          static void             hsur_Xmit(void);
 143          static void             hsur_ReadMsr(void);
 144          
 145          
 146          extern volatile U32_T xTickCount;
 147          /* LOCAL SUBPROGRAM BODIES */
 148          
 149          /*
 150           *--------------------------------------------------------------------------------
 151           * static void hsur_ReadLsr(void)
 152           * Purpose : Read Line Status Register and display.
 153           * Params  : None
 154           * Returns : None
 155           * Note    : None
 156           *--------------------------------------------------------------------------------
 157           */
 158          static void hsur_ReadLsr(void)
 159          {
 160   1              hsurLineStatusValue = UR2_LSR;
 161   1      
 162   1              if (hsurLineStatusValue & UR2_OE)
 163   1              {
 164   2                      // Overrun Error
 165   2                      hsurErrorCount ++;
 166   2      //              P3 = BIT0;
 167   2              }
 168   1              if (hsurLineStatusValue & UR2_PE)
 169   1              {
 170   2                      // Parity Error
 171   2                      hsurErrorCount ++;
 172   2      //              P3 = BIT1;
 173   2              }
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 4   

 174   1              if (hsurLineStatusValue & UR2_FE)
 175   1              {
 176   2                      // Framing Error
 177   2                      hsurErrorCount ++;
 178   2      //              P3 = BIT2;
 179   2              }
 180   1              if (hsurLineStatusValue & UR2_BI)
 181   1              {
 182   2                      // Break Interrupt Occured
 183   2                      hsurErrorCount ++;
 184   2      //              P3 = BIT3;
 185   2              }
 186   1              if (hsurLineStatusValue & UR2_FRAME_ERR)
 187   1              {
 188   2                      // Mixing Error
 189   2                      hsurErrorCount ++;
 190   2      //              P3 = BIT4;
 191   2              }
 192   1      
 193   1              if (hsurErrorCount)
 194   1              {
 195   2                      UR2_FCR |= UR2_RXFIFO_RST;
 196   2      
 197   2                      if (hsurErrorCount >=30)
 198   2                      {
 199   3                              hsurErrTimeStop = xTickCount;
 200   3                              if (((hsurErrTimeStop - hsurErrTimeStart) * SWTIMER_INTERVAL) <= 2000)
 201   3                              {
 202   4                                      UR2_IER = 0;
 203   4                                      hsurErrBlocking = 1;
 204   4                              }
 205   3                              else
 206   3                              {
 207   4                                      hsurErrBlocking = 0;
 208   4                                      hsurErrTimeStart = 0;
 209   4                                      hsurErrorCount = 0;
 210   4                              }
 211   3                      }
 212   2                      else// if (hsurErrorCount < 30)
 213   2                      {
 214   3                              U8_T trash;
 215   3      
 216   3                              while (UR2_LSR & UR2_DR)
 217   3                              {
 218   4                                      trash = UR2_RBR;
 219   4                              }
 220   3      
 221   3                              if ((hsurErrTimeStart == 0) && (hsurErrorCount < 5))
 222   3                              {
 223   4                                      hsurErrTimeStart = xTickCount;
 224   4                              }
 225   3                              else
 226   3                              {
 227   4                                      hsurErrTimeStop = xTickCount;
 228   4                                      if (((hsurErrTimeStop - hsurErrTimeStart) * SWTIMER_INTERVAL) > 2000)
 229   4                                      {
 230   5                                              hsurErrBlocking = 0;
 231   5                                              hsurErrTimeStart = 0;
 232   5                                              hsurErrorCount = 0;
 233   5                                      }
 234   4                              }
 235   3                      }
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 5   

 236   2              }
 237   1      
 238   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 239   1              {
 240   2                      UR2_THR = FLOW_SW_ERROR;
 241   2              }       
 242   1      }
 243          
 244          /*
 245           *--------------------------------------------------------------------------------
 246           * static void hsur_RcvrTrig(void)
 247           * Purpose : Get data and put into the receiver buffer continuously until trigger bytes
 248           * Params  : None
 249           * Returns : None
 250           * Note    : None
 251           *--------------------------------------------------------------------------------
 252           */
 253          static void hsur_RcvrTrig(void)
 254          {
 255   1              U8_T    c;
 256   1              U16_T   i;
 257   1      
 258   1              if (hsurRxCount >= UR2_MAX_RX_SIZE - hsurRxTrigLvl) // buffer full
 259   1                      return;
 260   1      
 261   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 262   1              {
 263   2                      for (i=0 ; i<hsurRxTrigLvl ; i++)
 264   2                      {
 265   3                              c = UR2_RBR;
 266   3                              if (hsurTxState == 1)
 267   3                              {
 268   4                                      EA = 0;
 269   4                                      hsurTxFlag = c;
 270   4                                      hsurTxState = 0;
 271   4                                      EA = 1;
 272   4                              }
 273   3                              else
 274   3                              {
 275   4                                      hsurRxBuffer[hsurRxBufNum] = c;
 276   4                                      hsurRxBufNum ++;
 277   4                                      hsurRxCount ++;
 278   4                                      if (hsurRxBufNum == UR2_MAX_RX_SIZE)
 279   4                                              hsurRxBufNum = 0;
 280   4                              }
 281   3                      }
 282   2              }
 283   1              else if (hsurFlowCtrl != UR2_FLOW_CTRL_X)
 284   1              {
 285   2                      for (i=0 ; i<hsurRxTrigLvl ; i++)
 286   2                      {
 287   3                              hsurRxBuffer[hsurRxBufNum] = UR2_RBR;
 288   3                              hsurRxBufNum ++;
 289   3                              hsurRxCount ++;
 290   3                              if (hsurRxBufNum == UR2_MAX_RX_SIZE)
 291   3                                      hsurRxBufNum = 0;       
 292   3                      }
 293   2              }
 294   1              else
 295   1              {
 296   2                      for (i=0 ; i<hsurRxTrigLvl ; i++)
 297   2                      {
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 6   

 298   3                              c = UR2_RBR;
 299   3                              if (c != ASCII_XOFF && c != ASCII_XON)
 300   3                              {
 301   4                                      hsurRxBuffer[hsurRxBufNum] = c;
 302   4                                      hsurRxBufNum ++;
 303   4                                      hsurRxCount ++;
 304   4                                      if (hsurRxBufNum == UR2_MAX_RX_SIZE)
 305   4                                              hsurRxBufNum = 0;
 306   4                              }
 307   3                              else
 308   3                              {
 309   4                                      if (c == ASCII_XOFF)
 310   4                                              hsurFlowCtrlXoff = TRUE;
 311   4                                      else if (c == ASCII_XON)
 312   4                                              hsurFlowCtrlXon = TRUE;
 313   4                              }
 314   3                      }
 315   2              }
 316   1      
 317   1              if (hsurFlowCtrl != UR2_FLOW_CTRL_NO)
 318   1              {
 319   2                      HSUR_RxBufFlowControl();
 320   2      
 321   2                      if (hsurFlowOn == FALSE)
 322   2                      {
 323   3                              if (hsurRxCount >= UR2_FLOW_HI_WATERMARK) // check software buffer status
 324   3                              {
 325   4                                      hsurFlowOn = TRUE;
 326   4                      }
 327   3                      else if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 328   3                              {
 329   4                                      UR2_THR = FLOW_SW_CONTINUOUS;
 330   4                              }                       
 331   3                      }       
 332   2              }
 333   1      }
 334          
 335          /*
 336           *--------------------------------------------------------------------------------
 337           * static void hsur_Rcvr(void)
 338           * Purpose : Receiving the byte data from hardware register into software buffer.
 339           * Params  : None
 340           * Returns : None
 341           * Note    : None
 342           *--------------------------------------------------------------------------------
 343           */
 344          static void hsur_Rcvr(void)
 345          {
 346   1              U8_T    far lineStatus = 0;
 347   1      
 348   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 349   1              {
 350   2                      while (1)
 351   2                      {
 352   3                              lineStatus = UR2_LSR;
 353   3                              hsurLineStatusValue = lineStatus;
 354   3              
 355   3                              if (lineStatus & UR2_DR)
 356   3                              {
 357   4                                      if (hsurTxState == 1)
 358   4                                      {
 359   5                                              EA = 0;
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 7   

 360   5                                              hsurTxFlag = UR2_RBR;
 361   5                                              hsurTxState = 0;
 362   5                                              EA = 1;
 363   5                                      }
 364   4                                      else
 365   4                                      {
 366   5                                              hsurRxBuffer[hsurRxBufNum] = UR2_RBR;
 367   5                                              hsurRxBufNum ++;
 368   5                                              hsurRxCount ++;
 369   5                                              if (hsurRxBufNum == UR2_MAX_RX_SIZE)
 370   5                                                      hsurRxBufNum = 0;
 371   5      
 372   5                                              if (hsurRxCount >= UR2_MAX_RX_SIZE) // buffer full
 373   5                                                      break;;
 374   5                                      }
 375   4                              }
 376   3                              else
 377   3                                      break;
 378   3                      }
 379   2              }
 380   1              else if (hsurFlowCtrl != UR2_FLOW_CTRL_X)
 381   1              {
 382   2                      while (1)
 383   2                      {
 384   3                              lineStatus = UR2_LSR;
 385   3                              hsurLineStatusValue = lineStatus;
 386   3              
 387   3                              if (lineStatus & UR2_DR)
 388   3                              {
 389   4                                      hsurRxBuffer[hsurRxBufNum] = UR2_RBR;
 390   4                                      hsurRxBufNum ++;
 391   4                                      hsurRxCount ++;
 392   4                                      if (hsurRxBufNum == UR2_MAX_RX_SIZE)
 393   4                                              hsurRxBufNum = 0;
 394   4      
 395   4                                      if (hsurRxCount >= UR2_MAX_RX_SIZE) // buffer full
 396   4                                              break;
 397   4                              }
 398   3                              else                            
 399   3                                      break;
 400   3                      }               
 401   2              }
 402   1              else 
 403   1              {
 404   2                      U8_T    c = 0;
 405   2      
 406   2                      while (1)
 407   2                      {
 408   3                              lineStatus = UR2_LSR;
 409   3                              hsurLineStatusValue = lineStatus;
 410   3              
 411   3                              if (lineStatus & UR2_DR)
 412   3                              {
 413   4                                      c = UR2_RBR;
 414   4      
 415   4                                      if (c != ASCII_XOFF && c != ASCII_XON)
 416   4                                      {
 417   5                                              hsurRxBuffer[hsurRxBufNum] = c;
 418   5                                              hsurRxBufNum ++;
 419   5                                              hsurRxCount ++;
 420   5                                              if (hsurRxBufNum == UR2_MAX_RX_SIZE)
 421   5                                                      hsurRxBufNum = 0;
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 8   

 422   5      
 423   5                                              if (hsurRxCount >= UR2_MAX_RX_SIZE) // buffer full
 424   5                                                      break;
 425   5                                      }
 426   4                                      else
 427   4                                      {
 428   5                                              if (c == ASCII_XOFF)
 429   5                                                      hsurFlowCtrlXoff = TRUE;
 430   5                                              else if (c == ASCII_XON)
 431   5                                                      hsurFlowCtrlXon = TRUE;
 432   5                                      }
 433   4                              }
 434   3                              else
 435   3                                      break;
 436   3                      }
 437   2              }
 438   1      
 439   1              if (hsurFlowCtrl != UR2_FLOW_CTRL_NO)
 440   1                      HSUR_RxBufFlowControl();
 441   1      }
 442          
 443          /*
 444           *--------------------------------------------------------------------------------
 445           * static void hsur_Xmit(void)
 446           * Purpose : Transmitting the byte data from software buffer into hardware register.
 447           * Params  : None
 448           * Returns : None
 449           * Note    : None
 450           *--------------------------------------------------------------------------------
 451           */
 452          static void hsur_Xmit(void)
 453          {
 454   1              U8_T far        i = 0;
 455   1      
 456   1              for (i=0 ; i<UR2_TX_BUF_LEVEL ; i++)
 457   1              {
 458   2                      if (hsurTxCount > 0)
 459   2                      {
 460   3                              UR2_THR = hsurTxBuffer[hsurTxBufNum];
 461   3                              hsurTxBufNum ++;
 462   3                              hsurTxCount --;
 463   3      
 464   3                              if (hsurTxBufNum == UR2_MAX_TX_SIZE)
 465   3                                      hsurTxBufNum = 0; 
 466   3      
 467   3                              if ((hsurFlowCtrl == UR2_FLOW_CTRL_HW) || (hsurFlowCtrl == UR2_FLOW_CTRL_X))
 468   3                              {
 469   4                                      HSUR_TxBufFlowControl();
 470   4                              }
 471   3                      
 472   3                              if (hsurTxCount <= 0)
 473   3                              {               
 474   4                                      UR2_IER &= ~UR2_THRI_ENB;
 475   4                                      return;
 476   4                              }
 477   3                      }
 478   2                      else
 479   2                      {
 480   3                              UR2_IER &= ~UR2_THRI_ENB;
 481   3                              return;
 482   3                      }
 483   2              }
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 9   

 484   1      }
 485          
 486          /*
 487           *--------------------------------------------------------------------------------
 488           * static void hsur_ReadMsr(void)
 489           * Purpose : Reading the modem status register.
 490           * Params  : None
 491           * Returns : None
 492           * Note    : None
 493           *--------------------------------------------------------------------------------
 494           */
 495          static void hsur_ReadMsr(void)
 496          {
 497   1              hsurModemStatusValue = UR2_MSR;
 498   1      
 499   1              if (hsurModemStatusValue & UR2_DCTS)
 500   1              {
 501   2                      if (hsurModemStatusValue & UR2_CTS)
 502   2                      {
 503   3                              HSUR_SetRTS();
 504   3                              hsurFlowCtrlHwCTSon = TRUE;
 505   3                      }
 506   2                      else
 507   2                      {
 508   3                              HSUR_ClearRTS();
 509   3                              hsurFlowCtrlHwCTSon = FALSE;
 510   3                      }
 511   2              }
 512   1      
 513   1              if (hsurModemStatusValue & UR2_DDSR)
 514   1              {
 515   2                      if (hsurModemStatusValue & UR2_DSR)
 516   2                      {
 517   3                              HSUR_SetDTR();
 518   3                      }
 519   2                      else
 520   2                      {
 521   3                              HSUR_ClearDTR();
 522   3                      }
 523   2              }
 524   1      
 525   1              if (hsurModemStatusValue & UR2_TERI)
 526   1              {
 527   2                      if (hsurModemStatusValue & UR2_RI)
 528   2                      {
 529   3                              UR2_MCR |= UR2_OUT1;
 530   3                              hsurModemControlValue |= UR2_OUT1;
 531   3                      }
 532   2                      else
 533   2                      {
 534   3                              UR2_MCR &= ~UR2_OUT1;
 535   3                              hsurModemControlValue &= ~UR2_OUT1;
 536   3                      }
 537   2              }
 538   1      
 539   1              if (hsurModemStatusValue & UR2_DDCD)
 540   1              {
 541   2                      if (hsurModemStatusValue & UR2_DCD)
 542   2                      {
 543   3                              UR2_MCR |= UR2_OUT2;
 544   3                              hsurModemControlValue |= UR2_OUT2;
 545   3                      }
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 10  

 546   2                      else
 547   2                      {
 548   3                              UR2_MCR &= ~UR2_OUT2;
 549   3                              hsurModemControlValue &= ~UR2_OUT2;
 550   3                      }
 551   2              }
 552   1      }
 553          
 554          
 555          /* EXPORTED SUBPROGRAM BODIES */
 556          
 557          /*
 558           *--------------------------------------------------------------------------------
 559           * void HSUR_Func(void)
 560           * Purpose : HSUR interrupt function which checks interrupt status.
 561           * Params  : None.
 562           * Returns : None.
 563           * Note    : None.
 564           *--------------------------------------------------------------------------------
 565           */
 566          void HSUR_Func(void)
 567          {
 568   1              U8_T    far intrStatus = 0;
 569   1      
 570   1              intrStatus = UR2_IIR & 0x0F;
 571   1      
 572   1              if (intrStatus == UR2_RLS_INTR)
 573   1              {
 574   2                      hsur_ReadLsr();
 575   2              }
 576   1              else if (intrStatus == UR2_RD_TRIG_INTR)
 577   1              {
 578   2                      UR2_IER &= ~UR2_RDI_ENB;
 579   2                      hsur_RcvrTrig();
 580   2                      UR2_IER |= UR2_RDI_ENB;
 581   2              }
 582   1              else if (intrStatus == UR2_RD_TI_INTR)
 583   1              {
 584   2                      UR2_IER &= ~UR2_RDI_ENB;
 585   2                      hsur_Rcvr();
 586   2                      UR2_IER |= UR2_RDI_ENB;
 587   2              }
 588   1              else if (intrStatus == UR2_THRE_INTR)
 589   1              {
 590   2                      if (hsurFlowCtrl != UR2_FLOW_CTRL_SW )
 591   2                      {
 592   3                              hsur_Xmit();
 593   3                      }
 594   2                      else
 595   2                      {
 596   3                              EA = 0;
 597   3                              hsurTxTransmit = 1;
 598   3                              hsurTxFlag = 0;
 599   3                              UR2_IER &= ~UR2_THRI_ENB;
 600   3                              EA = 1;
 601   3                      }
 602   2              }
 603   1              else if (intrStatus == UR2_MS_INTR)
 604   1              {
 605   2                      hsur_ReadMsr();
 606   2              }
 607   1      }
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 11  

 608          
 609          /*
 610           *--------------------------------------------------------------------------------
 611           * void HSUR_Setup(U16_T divisor, U8_T lCtrl, U8_T intEnb, U8_T fCtrl, U8_T mCtrl)
 612           * Purpose : Setup the HSUR mode. Before using the HSUR of AX11000, this function
 613           *           must be executed to initiate.
 614           * Params  : divisor - A divisor value used to calculate the baud rate of HSUR.
 615           *           lCtrl - Line control register value.
 616           *           intEnb - Interrupt enable register value.
 617           *           fCtrl - FIFO control register value.
 618           *           mCtrl - Modem control register value.
 619           * Returns : None.
 620           * Note    : None.
 621           *--------------------------------------------------------------------------------
 622           */
 623          void HSUR_Setup(U16_T divisor, U8_T lCtrl, U8_T intEnb, U8_T fCtrl, U8_T mCtrl)
 624          {
 625   1              U16_T   far i;
 626   1      
 627   1              for (i=0 ; i<UR2_MAX_RX_SIZE ; i++)
 628   1              {
 629   2                      hsurRxBuffer[i] = 0;
 630   2              }
 631   1              for (i=0 ; i<UR2_MAX_TX_SIZE ; i++)
 632   1              {
 633   2                      hsurTxBuffer[i] = 0;
 634   2              }
 635   1      
 636   1              hsurRxBufNum = 0;
 637   1              hsurTxBufNum = 0;
 638   1              hsurRxCount = 0;
 639   1              hsurTxCount = 0;
 640   1              hsurGetPtr = 0;
 641   1              hsurPutPtr = 0;
 642   1      
 643   1              switch (fCtrl & 0xC0)
 644   1              {
 645   2                      case UR2_TRIG_01 :
 646   2                              hsurRxTrigLvl = 1;
 647   2                              break;
 648   2                      case UR2_TRIG_04 :
 649   2                              hsurRxTrigLvl = 4;
 650   2                              break;
 651   2                      case UR2_TRIG_08 :
 652   2                              hsurRxTrigLvl = 8;
 653   2                              break;
 654   2                      case UR2_TRIG_14 :
 655   2                              hsurRxTrigLvl = 14;
 656   2                              break;
 657   2              }
 658   1      
 659   1              UR2_LCR = UR2_DLAB_ENB;
 660   1              UR2_DLL = (U8_T)(divisor & 0x00FF);
 661   1              UR2_DLH = (U8_T)((divisor & 0xFF00) >> 8);
 662   1              UR2_LCR &= ~UR2_DLAB_ENB;
 663   1              UR2_LCR = lCtrl;
 664   1              UR2_FCR = fCtrl;
 665   1      #if   HSUR_RS485_ENABLE
*** WARNING C322 IN LINE 665 OF hsur\hsuart.c: unknown identifier
                      UR2_MCR = (mCtrl | UR2_RS485_RECEIVE);
              #else
 668   1              UR2_MCR = mCtrl;
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 12  

 669   1      #endif
 670   1              UR2_IER = intEnb;
 671   1      
 672   1              hsurLineControlValue = lCtrl;
 673   1              hsurFifoControlValue = fCtrl;
 674   1              hsurModemControlValue = mCtrl;
 675   1      }
 676          /*
 677           *--------------------------------------------------------------------------------
 678           * S8_T HSUR_GetChar(void)
 679           * Purpose : Getting one byte data from the software receiver buffer,
 680           *           which stores data received from a serial bus.
 681           * Params  : None.
 682           * Returns : ch - one byte character in buffer.
 683           * Note    : None.
 684           *--------------------------------------------------------------------------------
 685           */
 686          S8_T HSUR_GetChar(void)
 687          {
 688   1              U8_T    far ch = 0;
 689   1          
 690   1              while (hsurRxCount == 0) ;
 691   1              
 692   1              ch = hsurRxBuffer[hsurGetPtr];
 693   1              EA = 0;
 694   1              hsurGetPtr ++;
 695   1              hsurRxCount --;
 696   1              if (hsurGetPtr == UR2_MAX_RX_SIZE)
 697   1                      hsurGetPtr = 0;
 698   1              EA = 1;
 699   1      
 700   1              if ((hsurFlowCtrl != UR2_FLOW_CTRL_NO) && (hsurFlowOn))
 701   1              {
 702   2                      if (hsurRxCount <= UR2_FLOW_LO_WATERMARK)
 703   2                      {
 704   3                              hsurFlowOn = FALSE;
 705   3      
 706   3                              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 707   3                              {
 708   4                                      UR2_THR = FLOW_SW_CONTINUOUS;
 709   4                              }
 710   3                              else if (hsurFlowCtrl == UR2_FLOW_CTRL_HW)
 711   3                              {
 712   4                                      HSUR_SetRTS();
 713   4                              }
 714   3                              else if (hsurFlowCtrl == UR2_FLOW_CTRL_X)
 715   3                              {
 716   4                                      UR2_THR = ASCII_XON;
 717   4                              }
 718   3                      }
 719   2              }
 720   1      
 721   1              return ch;
 722   1      }
 723          
 724          /*
 725           *--------------------------------------------------------------------------------
 726           * S8_T HSUR_PutChar(S8_T ch)
 727           * Purpose : Putting  one byte data into the software transmitter buffer,
 728           *           which stores data that be sent to a serial bus.
 729           * Params  : ch - one byte data will be put into buffer.
 730           * Returns : ch - the same data value will be returned.
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 13  

 731           * Note    : None.
 732           *--------------------------------------------------------------------------------
 733           */
 734          S8_T HSUR_PutChar(S8_T ch)
 735          {
 736   1              U16_T   far tIdleStart = 0;
 737   1              U16_T   far tIdleStop = 0;
 738   1      
 739   1              if (hsurTxCount >= UR2_MAX_TX_SIZE)
 740   1              {
 741   2      //              printd("U2-TX-Full\r\n");
 742   2                      return FALSE;
 743   2              }
 744   1      
 745   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 746   1              {
 747   2                      UR2_THR = ch;
 748   2                      hsurTxState = 1;
 749   2      
 750   2                      if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 751   2                      {
 752   3                              tIdleStart =xTickCount;
 753   3                              while (hsurTxTransmit == 0)
 754   3                              {
 755   4                                      tIdleStop =xTickCount;
 756   4                                      if (((tIdleStop - tIdleStart) / SWTIMER_COUNT_SECOND) >= 3)
 757   4                                      {
 758   5      //                                      PRINTD(DEBUG_MSG, ("Can not transmit in UR2_FLOW_CTRL_SW because of no UR2_THRI_INTR\n\r"));
 759   5                                      }
 760   4                              }
 761   3                      
 762   3                              tIdleStart = xTickCount;
 763   3                              while (hsurTxState == 1)
 764   3                              {
 765   4                                      tIdleStop = xTickCount;
 766   4                                      if (((tIdleStop - tIdleStart) / SWTIMER_COUNT_SECOND) >= 3)
 767   4                                      {
 768   5      //                                      PRINTD(DEBUG_MSG, ("Do not receive any flow control character in UR2_FLOW_CTRL_SW\n\r"));
 769   5                                      }
 770   4                              }
 771   3              
 772   3                              HSUR_TxBufFlowControl();
 773   3                              EA = 0;
 774   3                              hsurTxTransmit = 0;
 775   3                              EA = 1;
 776   3                      }
 777   2              }
 778   1              else
 779   1              {
 780   2                      UR2_IER &= ~UR2_THRI_ENB;               
 781   2                      hsurTxBuffer[hsurPutPtr] = ch;
 782   2                      hsurPutPtr ++;
 783   2                      hsurTxCount ++;
 784   2      
 785   2                      if (hsurPutPtr == UR2_MAX_TX_SIZE)
 786   2                              hsurPutPtr = 0;
 787   2              }
 788   1      
 789   1              UR2_IER |= UR2_THRI_ENB;    /* trigger hardware interrupt if hw FIFO empty */
 790   1      
 791   1      #if UR2_APP_FLOW_CTRL
 792   1              if (hsurTxCount >= UR2_FLOW_HI_WATERMARK)
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 14  

 793   1                      return FALSE;
 794   1              else
 795   1                      return TRUE;
 796   1      #else
                      return ch;
              #endif
 799   1      }
 800          
 801          /*
 802          * -----------------------------------------------------------------------------
 803           * void HSUR_InitValue(void)
 804           * Purpose : Initiating all globe value in this driver function.
 805           * Params  : None.
 806           * Returns : None.
 807           * Note    : None.
 808           * ----------------------------------------------------------------------------
 809           */
 810          void HSUR_InitValue(void)
 811          {
 812   1              U8_T    far sysClk = 0;
 813   1              U16_T   far i;
 814   1      
 815   1              for (i=0 ; i<UR2_MAX_RX_SIZE ; i++)
 816   1              {
 817   2                      hsurRxBuffer[i] = 0;
 818   2              }
 819   1              for (i=0 ; i<UR2_MAX_TX_SIZE ; i++)
 820   1              {
 821   2                      hsurTxBuffer[i] = 0;
 822   2              }
 823   1      
 824   1              hsurRxBufNum = 0;
 825   1              hsurTxBufNum = 0;
 826   1              hsurRxCount = 0;
 827   1              hsurTxCount = 0;
 828   1              hsurGetPtr = 0;
 829   1              hsurPutPtr = 0;
 830   1      
 831   1              sysClk = CSREPR & 0xC0;
 832   1              switch (sysClk)
 833   1              {
 834   2                      case SCS_100M :
 835   2      //                      P3 = 0x10;
 836   2                              break;
 837   2                      case SCS_50M :
 838   2      //                      P3 = 0x50;
 839   2                              break;
 840   2                      case SCS_25M :
 841   2      //                      P3 = 0x25;
 842   2                              break;
 843   2                      default :
 844   2      //                      P3 = 0xAA;
 845   2                              break;
 846   2              }
 847   1      
 848   1      } /* End of UART_Init */
 849          
 850          /*
 851           *--------------------------------------------------------------------------------
 852           * S8_T HSUR_GetCharNb(void)
 853           * Purpose : Getting data from the software receiver buffer, which stores data 
 854           *           received from a serial bus. This function is similar to HSUR_GetChar,
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 15  

 855           *           but this function only check buffer one time.
 856           * Params  : None.
 857           * Returns : ch - one byte data in buffer will be returned if having.
 858           * Note    : None.
 859           *--------------------------------------------------------------------------------
 860           */
 861          //S16_T HSUR_GetCharNb(void)
 862          S8_T HSUR_GetCharNb(void)
 863          {
 864   1              S8_T    far ch = 0;
 865   1      
 866   1              UR2_IER &= ~UR2_RDI_ENB;
 867   1       
 868   1              if (hsurRxCount > 0)
 869   1              {
 870   2                      ch = hsurRxBuffer[hsurGetPtr];          
 871   2                      hsurGetPtr++;
 872   2                      hsurRxCount --;
 873   2                      if (hsurGetPtr == UR2_MAX_RX_SIZE)
 874   2                              hsurGetPtr = 0;
 875   2      
 876   2                      if ((hsurFlowCtrl != UR2_FLOW_CTRL_NO) && (hsurFlowOn))
 877   2                      {
 878   3                              if (hsurRxCount <= UR2_FLOW_LO_WATERMARK)
 879   3                              {
 880   4                                      hsurFlowOn = FALSE;
 881   4      
 882   4                                      if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 883   4                                      {
 884   5                                              UR2_THR = FLOW_SW_CONTINUOUS;
 885   5                                      }
 886   4                                      else if (hsurFlowCtrl == UR2_FLOW_CTRL_HW)
 887   4                                      {
 888   5                                              HSUR_SetRTS();
 889   5                                      }
 890   4                                      else if (hsurFlowCtrl == UR2_FLOW_CTRL_X)
 891   4                                      {
 892   5                                              UR2_THR = ASCII_XON;
 893   5                                      }
 894   4                              }
 895   3                      }
 896   2      
 897   2                      UR2_IER |= UR2_RDI_ENB;
 898   2                      return ch;
 899   2              }
 900   1              else
 901   1              {
 902   2                      UR2_IER |= UR2_RDI_ENB;
 903   2              
 904   2                      return -1;
 905   2             // return 1000;
 906   2              }
 907   1      }
 908          
 909          /*
 910           * ----------------------------------------------------------------------------
 911           * U16_T HSUR_GetRxBufCount(void)
 912           * Purpose : Getting the remain character number in UART2 Rx buffer.
 913           * Params  : none
 914           * Returns : hsurRxCount - the number of remain character in UART2 Rx buffer.
 915           * Note    : none
 916           * ----------------------------------------------------------------------------
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 16  

 917           */
 918          U16_T HSUR_GetRxBufCount(void)
 919          {
 920   1              return hsurRxCount;
 921   1      }
 922          
 923          /*
 924           * ----------------------------------------------------------------------------
 925           * void HSUR_SetFlowControl(U8_T mode)
 926           * Purpose : Setting the UART2 flow control mode.
 927           * Params  : mode - flow control mode.
 928           * Returns : none
 929           * Note    : none
 930           * ----------------------------------------------------------------------------
 931           */
 932          void HSUR_SetFlowControl(U8_T mode)
 933          {
 934   1              hsurFlowCtrl = mode;
 935   1      
 936   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 937   1              {
 938   2                      hsurTxTransmit = 0;
 939   2                      hsurTxFlag = 0;
 940   2                      hsurFlowOn = 0;
 941   2              }
 942   1      }
 943          
 944          /*
 945           * ----------------------------------------------------------------------------
 946           * BOOL HSUR_CheckTxComplete(void)
 947           * Purpose : Check the hardware FIFO empty and software Tx buffer empty
 948           * Params  : none
 949           * Returns : TRUE - both empty.
 950           * Note    : none
 951           * ----------------------------------------------------------------------------
 952           */
 953          BOOL HSUR_CheckTxComplete(void)
 954          {
 955   1              if ((UR2_LSR & UR2_THRE) && (hsurTxCount == 0))
 956   1                      return TRUE;
 957   1              else
 958   1                      return FALSE;
 959   1      }
 960          
 961          
 962          /*
 963           * ----------------------------------------------------------------------------
 964           * void HSUR_RxBufFlowControl(void)
 965           * Purpose : Check the receiving buffer space and return the flow control character.
 966           * Params  : none
 967           * Returns : none
 968           * Note    : none
 969           * ----------------------------------------------------------------------------
 970           */
 971          void HSUR_RxBufFlowControl(void)
 972          {
 973   1              U8_T    far charFlowCtrl = 0;
 974   1      
 975   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 976   1              {
 977   2                      if (hsurRxCount >= UR2_MAX_RX_SIZE)
 978   2                      {
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 17  

 979   3                              charFlowCtrl = FLOW_SW_ERROR;
 980   3                      }
 981   2                      else if (hsurRxCount >= UR2_FLOW_HI_WATERMARK)
 982   2                      {
 983   3                              hsurFlowOn = TRUE;
 984   3                              charFlowCtrl = FLOW_SW_WAIT;
 985   3                      }
 986   2                      else if ((hsurFlowOn) && (hsurRxCount > UR2_FLOW_LO_WATERMARK))
 987   2                      {
 988   3                              charFlowCtrl = FLOW_SW_WAIT;
 989   3                      }
 990   2                      else if ((hsurFlowOn) && (hsurRxCount <= UR2_FLOW_LO_WATERMARK))
 991   2                      {
 992   3                              hsurFlowOn = FALSE;
 993   3                              charFlowCtrl = FLOW_SW_CONTINUOUS;
 994   3                      }
 995   2                      else if (hsurFlowOn == FALSE)
 996   2                      {
 997   3                              charFlowCtrl = FLOW_SW_CONTINUOUS;
 998   3                      }
 999   2                      else
1000   2                      {
1001   3                              charFlowCtrl = FLOW_SW_CONTINUOUS;
1002   3                      }
1003   2      
1004   2                      UR2_THR = charFlowCtrl;
1005   2              }
1006   1              else if (hsurFlowCtrl == UR2_FLOW_CTRL_HW)
1007   1              {
1008   2                      if (hsurRxCount >= UR2_FLOW_HI_WATERMARK)
1009   2                      {
1010   3                              hsurFlowOn = TRUE;
1011   3                              UR2_MCR &= ~UR2_RTS;
1012   3                      }
1013   2                      else if ((hsurFlowOn) && (hsurRxCount <= UR2_FLOW_LO_WATERMARK))
1014   2                      {
1015   3                              hsurFlowOn = FALSE;
1016   3                              UR2_MCR |= UR2_RTS;
1017   3                      }
1018   2              }
1019   1              else if (hsurFlowCtrl == UR2_FLOW_CTRL_X)
1020   1              {
1021   2                      if (hsurRxCount >= UR2_FLOW_HI_WATERMARK)
1022   2                      {
1023   3                              hsurFlowOn = TRUE;
1024   3                              UR2_THR = ASCII_XOFF;
1025   3                      }
1026   2                      else if ((hsurFlowOn) && (hsurRxCount <= UR2_FLOW_LO_WATERMARK))
1027   2                      {
1028   3                              hsurFlowOn = FALSE;
1029   3                              UR2_THR = ASCII_XON;
1030   3                      }
1031   2              }
1032   1      }
1033          
1034          /*
1035           * ----------------------------------------------------------------------------
1036           * void HSUR_TxBufFlowControl(void)
1037           * Purpose : Check the transmitting flow control character.
1038           * Params  : none
1039           * Returns : none
1040           * Note    : none
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 18  

1041           * ----------------------------------------------------------------------------
1042           */
1043          void HSUR_TxBufFlowControl(void)
1044          {
1045   1              U8_T    far charFlowCtrl = 0;
1046   1              U16_T   far tIdleStart = 0;
1047   1              U16_T   far tIdleStop = 0;
1048   1              
1049   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_HW)
1050   1              {
1051   2                      if (hsurFlowCtrlHwCTSon == TRUE)
1052   2                      {
1053   3                              return;
1054   3                      }
1055   2      
1056   2                      tIdleStart = xTickCount;
1057   2                      while (1)
1058   2                      {
1059   3                              if (hsurFlowCtrlHwCTSon == TRUE)
1060   3                              {
1061   4                                      return;
1062   4                              }
1063   3                              else
1064   3                              {
1065   4                                      tIdleStop = xTickCount;
1066   4      
1067   4                                      if (((tIdleStop - tIdleStart) / SWTIMER_COUNT_SECOND) >= 1)
1068   4                                      {
1069   5      //                                      PRINTD(DEBUG_MSG, ("Do not match any flow control character in UR2_FLOW_CTRL_HW\n\r"));
1070   5                                      }
1071   4                              }
1072   3                      }
1073   2              }
1074   1              else if (hsurFlowCtrl == UR2_FLOW_CTRL_X)
1075   1              {
1076   2                      if (hsurFlowCtrlXoff == TRUE)
1077   2                      {
1078   3                              hsurFlowCtrlXoff = FALSE;
1079   3              
1080   3                              tIdleStart = xTickCount;
1081   3                              while (1)
1082   3                              {
1083   4                                      if (hsurFlowCtrlXon == TRUE)
1084   4                                      {
1085   5                                              hsurFlowCtrlXon = FALSE;
1086   5      
1087   5                                              break;
1088   5                                      }
1089   4                                      else
1090   4                                      {
1091   5                                              tIdleStop = xTickCount;
1092   5                                              if (((tIdleStop - tIdleStart) / SWTIMER_COUNT_SECOND) >= 3)
1093   5                                              {
1094   6      //                                              PRINTD(DEBUG_MSG, ("Do not match any flow control character in UR2_FLOW_CTRL_X\n\r"));
1095   6                                              }
1096   5                                      }
1097   4                              }
1098   3                      }
1099   2              }
1100   1              else if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
1101   1              {
1102   2                      tIdleStart = xTickCount;
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 19  

1103   2                      while (1)
1104   2                      {
1105   3                              charFlowCtrl = hsurTxFlag;
1106   3                              if (charFlowCtrl == FLOW_SW_CONTINUOUS)
1107   3                                      break;
1108   3                              else if (charFlowCtrl == FLOW_SW_ERROR)
1109   3                                      UR2_IER &= ~UR2_THRI_ENB;
1110   3                              else
1111   3                              {
1112   4                                      tIdleStop =xTickCount;
1113   4                                      if (((tIdleStop - tIdleStart) / SWTIMER_COUNT_SECOND) >= 3)
1114   4                                      {
1115   5      //                                      PRINTD(DEBUG_MSG, ("Do not match any flow control character in UR2_FLOW_CTRL_SW\n\r"));
1116   5                                      }
1117   4                              }
1118   3                      }
1119   2              }
1120   1      }
1121          
1122          /*
1123           * ----------------------------------------------------------------------------
1124           * void HSUR_ErrorRecovery(void)
1125           * Purpose : Checking the HSUR Line Status Register value of errors and
1126           *           re-enable interrupt of receiving and line status.
1127           * Params  : none
1128           * Returns : none
1129           * Note    : none
1130           * ----------------------------------------------------------------------------
1131           */
1132          void HSUR_ErrorRecovery(void)
1133          {
1134   1              if (hsurErrBlocking)
1135   1              {
1136   2                      U8_T    far lsrVal = UR2_LSR;
1137   2                      U8_T    far trash = 0;
1138   2      
1139   2      //              printd("hsurErrBlocking = 1\n\r");
1140   2                      if (lsrVal & UR2_DR)
1141   2                      {
1142   3                              trash = UR2_RBR;
1143   3                      }
1144   2                      else if (!(lsrVal & UR2_DR) && (hsurErrorCount >= 30))
1145   2                      {
1146   3      //                      printd("clear hsurErrBlocking = 0\n\r");
1147   3                              EA = 0;
1148   3                              UR2_IER |= (UR2_RDI_ENB | UR2_RLSI_ENB | UR2_MSI_ENB);
1149   3                              hsurErrBlocking = 0;
1150   3                              hsurErrorCount = 0;
1151   3                              EA = 1;
1152   3                      }
1153   2              }
1154   1      }
1155          
1156          /*
1157           * ----------------------------------------------------------------------------
1158           * BOOL HSUR_SetBaudRate(U16_T divBaudRate)
1159           * Purpose : Setting the HSUR baudrate.
1160           * Params  : divBaudRate - divisor of the baudrate.
1161           * Returns : TRUE - setting complete.
1162           * Note    : none
1163           * ----------------------------------------------------------------------------
1164           */
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 20  

1165          BOOL HSUR_SetBaudRate(U16_T divBaudRate)
1166          {
1167   1              U8_T    far recIntrEnb = UR2_IER;
1168   1      
1169   1              UR2_IER = 0;
1170   1              UR2_LCR |= UR2_DLAB_ENB;
1171   1              UR2_DLL = (U8_T)(divBaudRate & 0x00FF);
1172   1              UR2_DLH = (U8_T)((divBaudRate & 0xFF00) >> 8);
1173   1              UR2_LCR &= ~UR2_DLAB_ENB;
1174   1      
1175   1              hsurBaudRateDivisor = divBaudRate;
1176   1      
1177   1              switch (CSREPR & 0xC0)
1178   1              {
1179   2                      case SCS_100M :
1180   2      //                      P3 = 0x10;
1181   2                              break;
1182   2                      case SCS_50M :
1183   2      //                      P3 = 0x50;
1184   2                              break;
1185   2                      case SCS_25M :
1186   2      //                      P3 = 0x25;
1187   2                              break;
1188   2              }
1189   1      
1190   1              UR2_FCR |= UR2_RXFIFO_RST | UR2_TXFIFO_RST;
1191   1              UR2_IER = recIntrEnb;
1192   1      
1193   1              return TRUE;
1194   1      }
1195          
1196          /*
1197           * ----------------------------------------------------------------------------
1198           * void HSUR_SetLineControl(U8_T value)
1199           * Purpose : Setting the HSUR Line control register with "value".
1200           * Params  : value - variable to be set.
1201           * Returns : none
1202           * Note    : none
1203           * ----------------------------------------------------------------------------
1204           */
1205          void HSUR_SetLineControl(U8_T value)
1206          {
1207   1              U8_T    recIntrEnb = UR2_IER;
1208   1      
1209   1              UR2_IER = 0;
1210   1              UR2_LCR = value;
1211   1              hsurLineControlValue = value;
1212   1              UR2_IER = recIntrEnb;
1213   1      }
1214          
1215          /*
1216           * ----------------------------------------------------------------------------
1217           * void HSUR_SetFifoControl(U8_T value)
1218           * Purpose : Setting the HSUR FIFO control register with "value".
1219           * Params  : value - variable to be set.
1220           * Returns : none
1221           * Note    : none
1222           * ----------------------------------------------------------------------------
1223           */
1224          void HSUR_SetFifoControl(U8_T value)
1225          {
1226   1              U8_T    far recIntrEnb = UR2_IER;
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 21  

1227   1      
1228   1              UR2_IER = 0;
1229   1              UR2_FCR = value;
1230   1              hsurFifoControlValue = value;
1231   1              UR2_IER = recIntrEnb;
1232   1      }
1233          
1234          /*
1235           * ----------------------------------------------------------------------------
1236           * void HSUR_SetModemControl(U8_T value)
1237           * Purpose : Setting the HSUR Modem control register with "value".
1238           * Params  : value - variable to be set.
1239           * Returns : none
1240           * Note    : none
1241           * ----------------------------------------------------------------------------
1242           */
1243          void HSUR_SetModemControl(U8_T value)
1244          {
1245   1              U8_T    far recIntrEnb = UR2_IER;
1246   1      
1247   1              UR2_IER = 0;
1248   1              UR2_MCR = value;
1249   1              hsurModemControlValue = value;
1250   1              UR2_IER = recIntrEnb;
1251   1      }
1252          
1253          /*
1254           * ----------------------------------------------------------------------------
1255           * void HSUR_SetRTS(void)
1256           * Purpose : Only setting the HSUR RTS bit of Modem control register.
1257           * Params  : none
1258           * Returns : none
1259           * Note    : none
1260           * ----------------------------------------------------------------------------
1261           */
1262          void HSUR_SetRTS(void)
1263          {
1264   1              U8_T    far recIntrEnb = UR2_IER;
1265   1      
1266   1              UR2_IER = 0;
1267   1              UR2_MCR |= UR2_RTS;
1268   1              hsurModemControlValue |= UR2_RTS;
1269   1              UR2_IER = recIntrEnb;
1270   1      }
1271          
1272          /*
1273           * ----------------------------------------------------------------------------
1274           * void HSUR_SetDTR(void)
1275           * Purpose : Only setting the HSUR DTR bit of Modem control register.
1276           * Params  : none
1277           * Returns : none
1278           * Note    : none
1279           * ----------------------------------------------------------------------------
1280           */
1281          void HSUR_SetDTR(void)
1282          {
1283   1              U8_T    far recIntrEnb = UR2_IER;
1284   1      
1285   1              UR2_IER = 0;
1286   1              UR2_MCR |= UR2_DTR;
1287   1              hsurModemControlValue |= UR2_DTR;
1288   1              UR2_IER = recIntrEnb;
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 22  

1289   1      }
1290          
1291          /*
1292           * ----------------------------------------------------------------------------
1293           * void HSUR_ClearRTS(void)
1294           * Purpose : Only clear the HSUR RTS bit of Modem control register.
1295           * Params  : none
1296           * Returns : none
1297           * Note    : none
1298           * ----------------------------------------------------------------------------
1299           */
1300          void HSUR_ClearRTS(void)
1301          {
1302   1              UR2_MCR &= ~UR2_RTS;
1303   1              hsurModemControlValue &= ~UR2_RTS;
1304   1      }
1305          
1306          /*
1307           * ----------------------------------------------------------------------------
1308           * void HSUR_ClearDTR(void)
1309           * Purpose : Only clear the HSUR DTR bit of Modem control register.
1310           * Params  : none
1311           * Returns : none
1312           * Note    : none
1313           * ----------------------------------------------------------------------------
1314           */
1315          void HSUR_ClearDTR(void)
1316          {
1317   1              UR2_MCR &= ~UR2_DTR;
1318   1              hsurModemControlValue &= ~UR2_DTR;
1319   1      }
1320          
1321          /*
1322           * ----------------------------------------------------------------------------
1323           * U16_T HSUR_GetBaudRate(void)
1324           * Purpose : Getting the HSUR baudrate divisor.
1325           * Params  : none
1326           * Returns : divBaudRate - baudrate divisor.
1327           * Note    : none
1328           * ----------------------------------------------------------------------------
1329           */
1330          U16_T HSUR_GetBaudRate(void)
1331          {
1332   1              U16_T   far divBaudRate = 0;
1333   1      
1334   1              switch (CSREPR & 0xC0)
1335   1              {
1336   2                      case SCS_100M :
1337   2      //                      P3 = 0x10;
1338   2                              UR2_LCR |= UR2_DLAB_ENB;
1339   2                              switch (hsurBaudRateDivisor)
1340   2                              {
1341   3                                      case UR2_BR100_921600 :
1342   3                                              divBaudRate = UR2_BR100_921600;
1343   3                                              break;
1344   3                                      case UR2_BR100_115200 :
1345   3                                              divBaudRate = UR2_BR100_115200;
1346   3                                              break;
1347   3                                      case UR2_BR100_57600 :
1348   3                                              divBaudRate = UR2_BR100_57600;
1349   3                                              break;
1350   3                                      case UR2_BR100_38400 :
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 23  

1351   3                                              divBaudRate = UR2_BR100_38400;
1352   3                                              break;
1353   3                                      case UR2_BR100_19200 :
1354   3                                              divBaudRate = UR2_BR100_19200;
1355   3                                              break;
1356   3                                      case UR2_BR100_9600 :
1357   3                                              divBaudRate = UR2_BR100_9600;
1358   3                                              break;
1359   3                                      case UR2_BR100_7200 :
1360   3                                              divBaudRate = UR2_BR100_7200;
1361   3                                              break;
1362   3                                      case UR2_BR100_4800 :
1363   3                                              divBaudRate = UR2_BR100_4800;
1364   3                                              break;
1365   3                                      case UR2_BR100_3600 :
1366   3                                              divBaudRate = UR2_BR100_3600;
1367   3                                              break;
1368   3                                      case UR2_BR100_2400 :
1369   3                                              divBaudRate = UR2_BR100_2400;
1370   3                                              break;
1371   3                                      case UR2_BR100_1200 :
1372   3                                              divBaudRate = UR2_BR100_1200;
1373   3                                              break;
1374   3                              }
1375   2                              UR2_LCR &= ~UR2_DLAB_ENB;
1376   2                              break;
1377   2                      case SCS_50M :
1378   2      //                      P3 = 0x50;
1379   2                              UR2_LCR |= UR2_DLAB_ENB;
1380   2                              switch (hsurBaudRateDivisor)
1381   2                              {
1382   3                                      case UR2_BR50_921600 :
1383   3                                              divBaudRate = UR2_BR50_921600;
1384   3                                              break;
1385   3                                      case UR2_BR50_115200 :
1386   3                                              divBaudRate = UR2_BR50_115200;
1387   3                                              break;
1388   3                                      case UR2_BR50_57600 :
1389   3                                              divBaudRate = UR2_BR50_57600;
1390   3                                              break;
1391   3                                      case UR2_BR50_38400 :
1392   3                                              divBaudRate = UR2_BR50_38400;
1393   3                                              break;
1394   3                                      case UR2_BR50_19200 :
1395   3                                              divBaudRate = UR2_BR50_19200;
1396   3                                              break;
1397   3                                      case UR2_BR50_9600 :
1398   3                                              divBaudRate = UR2_BR50_9600;
1399   3                                              break;
1400   3                                      case UR2_BR50_7200 :
1401   3                                              divBaudRate = UR2_BR50_7200;
1402   3                                              break;
1403   3                                      case UR2_BR50_4800 :
1404   3                                              divBaudRate = UR2_BR50_4800;
1405   3                                              break;
1406   3                                      case UR2_BR50_3600 :
1407   3                                              divBaudRate = UR2_BR50_3600;
1408   3                                              break;
1409   3                                      case UR2_BR50_2400 :
1410   3                                              divBaudRate = UR2_BR50_2400;
1411   3                                              break;
1412   3                                      case UR2_BR50_1200 :
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 24  

1413   3                                              divBaudRate = UR2_BR50_1200;
1414   3                                              break;
1415   3                              }
1416   2                              UR2_LCR &= ~UR2_DLAB_ENB;
1417   2                              break;
1418   2                      case SCS_25M :
1419   2      //                      P3 = 0x25;
1420   2                              UR2_LCR |= UR2_DLAB_ENB;
1421   2                              switch (hsurBaudRateDivisor)
1422   2                              {
1423   3                                      case UR2_BR25_921600 :
1424   3                                              divBaudRate = UR2_BR25_921600;
1425   3                                              break;
1426   3                                      case UR2_BR25_115200 :
1427   3                                              divBaudRate = UR2_BR25_115200;
1428   3                                              break;
1429   3                                      case UR2_BR25_57600 :
1430   3                                              divBaudRate = UR2_BR25_57600;
1431   3                                              break;
1432   3                                      case UR2_BR25_38400 :
1433   3                                              divBaudRate = UR2_BR25_38400;
1434   3                                              break;
1435   3                                      case UR2_BR25_19200 :
1436   3                                              divBaudRate = UR2_BR25_19200;
1437   3                                              break;
1438   3                                      case UR2_BR25_9600 :
1439   3                                              divBaudRate = UR2_BR25_9600;
1440   3                                              break;
1441   3                                      case UR2_BR25_7200 :
1442   3                                              divBaudRate = UR2_BR25_7200;
1443   3                                              break;
1444   3                                      case UR2_BR25_4800 :
1445   3                                              divBaudRate = UR2_BR25_4800;
1446   3                                              break;
1447   3                                      case UR2_BR25_3600 :
1448   3                                              divBaudRate = UR2_BR25_3600;
1449   3                                              break;
1450   3                                      case UR2_BR25_2400 :
1451   3                                              divBaudRate = UR2_BR25_2400;
1452   3                                              break;
1453   3                                      case UR2_BR25_1200 :
1454   3                                              divBaudRate = UR2_BR25_1200;
1455   3                                              break;
1456   3                              }
1457   2                              UR2_LCR &= ~UR2_DLAB_ENB;
1458   2                              break;
1459   2              }
1460   1              
1461   1              return TRUE;
1462   1      }
1463          
1464          /*
1465           * ----------------------------------------------------------------------------
1466           * U8_T HSUR_GetLineControl(void)
1467           * Purpose : Getting the HSUR Line Control register variables.
1468           * Params  : none
1469           * Returns : varLineCtrl.
1470           * Note    : none
1471           * ----------------------------------------------------------------------------
1472           */
1473          U8_T HSUR_GetLineControl(void)
1474          {
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 25  

1475   1              U8_T    far varLineCtrl = 0;
1476   1      
1477   1              varLineCtrl = UR2_LCR;
1478   1      
1479   1              return varLineCtrl;
1480   1      }
1481          
1482          /*
1483           * ----------------------------------------------------------------------------
1484           * U8_T HSUR_GetFifoControl(void)
1485           * Purpose : Getting the HSUR FIFO Control register variables.
1486           * Params  : none
1487           * Returns : hsurFifoControlValue.
1488           * Note    : none
1489           * ----------------------------------------------------------------------------
1490           */
1491          U8_T HSUR_GetFifoControl(void)
1492          {
1493   1              return hsurFifoControlValue;
1494   1      }
1495          
1496          /*
1497           * ----------------------------------------------------------------------------
1498           * U8_T HSUR_GetModemControl(void)
1499           * Purpose : Getting the HSUR Modem Control register variables.
1500           * Params  : none
1501           * Returns : hsurModemControlValue.
1502           * Note    : none
1503           * ----------------------------------------------------------------------------
1504           */
1505          U8_T HSUR_GetModemControl(void)
1506          {
1507   1              return hsurModemControlValue;
1508   1      }
1509          
1510          /*
1511           * ----------------------------------------------------------------------------
1512           * U8_T HSUR_GetLineStatus(U8_T intrSynth)
1513           * Purpose : Getting the HSUR Line Status .
1514           * Params  : intrSynth - 1: Get LSR according to an interrupt trigger.
1515           *                       0: Get LSR by directly reading the register.
1516           * Returns : varLineStatus - Line status register variable.
1517           * Note    : none
1518           * ----------------------------------------------------------------------------
1519           */
1520          U8_T HSUR_GetLineStatus(U8_T intrSynth)
1521          {
1522   1              U8_T    far varLineStatus = 0;
1523   1      
1524   1              if (intrSynth == TRUE)
1525   1                      varLineStatus = hsurLineStatusValue;
1526   1              else if (intrSynth == FALSE)
1527   1                      varLineStatus = UR2_LSR;
1528   1      
1529   1              return varLineStatus;
1530   1      }
1531          
1532          /*
1533           * ----------------------------------------------------------------------------
1534           * U8_T HSUR_GetModemStatus(U8_T intrSynth)
1535           * Purpose : Getting the HSUR Modem Status .
1536           * Params  : intrSynth - 1: Get MSR according to an interrupt trigger.
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 26  

1537           *                       0: Get MSR by directly reading the register.
1538           * Returns : varModemStatus - Modem status register variable.
1539           * Note    : none
1540           * ----------------------------------------------------------------------------
1541           */
1542          U8_T HSUR_GetModemStatus(U8_T intrSynth)
1543          {
1544   1              U8_T    far varModemStatus = 0;
1545   1      
1546   1              if (intrSynth == TRUE)
1547   1                      varModemStatus = hsurModemStatusValue;
1548   1              else if (intrSynth == FALSE)
1549   1                      varModemStatus = UR2_MSR;
1550   1      
1551   1              return varModemStatus;
1552   1      }
1553          
1554          /*
1555           * ----------------------------------------------------------------------------
1556           * BOOL HSUR_XonByApp(void)
1557           * Purpose : Application issue flow control characters Xon to driver for
1558           *           stopping or starting the current transfer.
1559           * Params  : none
1560           * Returns : TRUE - driver is already in Xon/Xoff flow control.
1561           *           FLASE - driver is not in Xon/Xoff flow control.
1562           * Note    : none
1563           * ----------------------------------------------------------------------------
1564           */
1565          BOOL HSUR_XonToApp(void)
1566          {
1567   1              if (hsurFlowCtrl != UR2_FLOW_CTRL_X)
1568   1              {
1569   2                      return FALSE;
1570   2              }
1571   1      
1572   1              hsurAppFlowOn = TRUE;
1573   1      
1574   1              return TRUE;
1575   1      }
1576          
1577          /*
1578           * ----------------------------------------------------------------------------
1579           * BOOL HSUR_XoffByApp(void)
1580           * Purpose : Application issue flow control characters Xoff to driver for
1581           *           stopping or starting the current transfer.
1582           * Params  : none
1583           * Returns : TRUE - driver is already in Xon/Xoff flow control.
1584           *           FLASE - driver is not in Xon/Xoff flow control.
1585           * Note    : none
1586           * ----------------------------------------------------------------------------
1587           */
1588          BOOL HSUR_XoffByApp(void)
1589          {
1590   1              if (hsurFlowCtrl != UR2_FLOW_CTRL_X)
1591   1              {
1592   2                      return FALSE;
1593   2              }
1594   1      
1595   1              hsurAppFlowOn = FALSE;
1596   1      
1597   1              return TRUE;
1598   1      }
C51 COMPILER V9.00   HSUART                                                                03/01/2013 15:56:49 PAGE 27  

1599          /* End of hsuart.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4755    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   1096    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
