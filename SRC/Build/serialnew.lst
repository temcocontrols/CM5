C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SERIALNEW
OBJECT MODULE PLACED IN .\Build\serialnew.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Modbus\serialnew.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\
                    -SRC\FreeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\S
                    -RC\UART\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;
                    -..\SRC\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management
                    -\;..\SRC\dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule;..\SRC\program;..\SRC\Sc
                    -an) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\serialnew.lst) OBJECT(.\Build\serialnew.obj)

line level    source

   1          #include "main.h"    
   2          #include "serial.h"
   3          #include "schedule.h" 
   4          #include "stdlib.h" 
   5          
   6          
   7          extern xQueueHandle     xSubRevQueue;
   8          extern U8_T flag_send_scan_table;
   9          
  10          void responseCmd(U8_T type,U8_T* pData,HTTP_SERVER_CONN * pHttpConn); 
  11          
  12                  U8_T demo_enable = 0;
  13          
  14                  U8_T far serialNum[4];
  15          //      U8_T firmwareVer[2];
  16                  U8_T Modbus_address;
  17                  U8_T product_model;
  18                  U8_T hardRev;
  19                  U8_T baudrate;
  20          //      U8_T PICversion;
  21          //      U8_T update;
  22                  U8_T unit;
  23                  U8_T far sub_addr[8];
  24          
  25                  U8_T IspVer;
  26          //      U8_T UPDATE_STATUS;
  27                  U8_T BASE_ADRESS;
  28                  U8_T TCP_TYPE;   /* 0 -- DHCP, 1-- STATIC */
  29                  U8_T far Mac_Addr[6];
  30                  U8_T far IP_Addr[4];
  31                  U8_T far SUBNET[4];
  32                  U8_T far GETWAY[4];
  33          
  34                  U16_T  far AI_Value[10];        
  35                  U8_T far Input_Range[10];
  36                  U8_T far Input_Filter[10];      
  37                  U16_T far Input_CAL[10];
  38          
  39                  S8_T far menu_name[36][14];
  40                  U8_T dis_temp_num;
  41                  U8_T dis_temp_interval;
  42                  U8_T dis_temp_seq[10];
  43          
  44                  U8_T DI1_Value;
  45                  U8_T DI2_Value;
  46                  U8_T DI_Type[8];                /* choose DI1 or DI2 control DO, 0 -- DI1, 1 -- DI2 */
  47                  U16_T DO_Value;                 // control relay
  48                  U8_T DO_SoftSwitch;     // software switch logic
  49                  U8_T Priority;                  // Zone1 has priority,
  50                  U16_T count_priority;   // count priority timer 
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 2   

  51          //      U8_T Master;
  52                  U16_T DI_Enable;
  53                  U16_T AI_Enable;
  54                  U16_T DInputAM;  // digital input 
  55                  U16_T OuputAM;
  56                  U16_T AInputAM;  // input 1 - 10 sensor
  57              U8_T sn_write_flag;
  58                  U8_T update_status;
  59                  U8_T sub_no;
  60                  U8_T heat_no;
  61                  U8_T cool_no;
  62          
  63          UN_Time RTC;
  64          
  65          //STR_MODBUS  far Modbus;       
  66          extern U16_T far Test[50];
  67          
  68          //Added by andy sun
  69          #define DATA_TO_FIRMWARE  1000
  70          U8_T temp_state = NONE_ID;
  71          
  72          
  73          U8_T flag_update;  
  74          
  75          //extern U8_T pic_type; // chelsea
  76          signed int RangeConverter(U8_T function, signed int para,U8_T i,U16_T cal);
  77          
  78          xTaskHandle far Handle_MainSerial;
  79          xTaskHandle far Handle_SubSerial;
  80          
  81          
  82          U16_T main_rece_count, sub_rece_count;
  83          U8_T main_rece_size = 0;
  84          U16_T sub_rece_size = 0;
  85          U8_T main_dealwithTag;
  86          U8_T sub_dealwithTag;
  87          U8_T far main_serial_receive_timeout_count, sub_serial_receive_timeout_count;
  88          U8_T main_transmit_finished, sub_transmit_finished;
  89          U8_T far main_data_buffer[MAIN_BUF_LEN];
  90          U8_T sub_data_buffer[SUB_BUF_LEN];
  91          
  92          
  93          
  94          
  95          U8_T far sub_net_state = SUB_NET_SPARE;
  96          U8_T far sub_response_in = FALSE;
  97          
  98          
  99          U8_T SERIAL_RECEIVE_TIMEOUT;
 100          
 101          U8_T b_Master_Slave = 0;  // flag for CM5 or Tstat, if CM5 b_Master_Slave is 0, if Tstat b_Master_Slave is
             - 1
 102          U8_T SNWriteflag;
 103          bit flag_control_by_button = 0;  // control Tstat using T3000 or CM5's button
 104          
 105          U8_T far rand_read_ten_count;
 106          
 107          unsigned short TransID = 1;
 108          
 109          U8_T far flag_uart = 0;
 110          
 111          
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 3   

 112          U8_T comm_tstat = SPARE;             // 0: T3000 control TSTAT, 1: CM5 control TSTAT directly
 113          U8_T datalen = 0;
 114          //U8_T  address = 0;
 115          
 116          void main_dealwithData( void );
 117          void subdealwithData( void );
 118          //void subdealwithData( void );
 119          
 120          
 121          void vStartMainSerialTasks( U8_T uxPriority)
 122          {
 123   1              sub_no = 0;
 124   1              memset(sub_addr,0,8);
 125   1      //      sub_addr[0] = 140;
 126   1      //      memset(menu_name,0,MAX_NAME * NAME_SIZE);
 127   1              initSerial();
 128   1      //      memset(&Modbus,0,sizeof(STR_MODBUS));
 129   1              sTaskCreate( main_dealwithData, "mainserailtask", MainSerialSTACK_SIZE, NULL, uxPriority, &Handle_MainSer
             -ial );
 130   1      }
 131          
 132          
 133          void initSerial(void)
 134          {
 135   1              UART1_TXEN = RECEIVE;
 136   1              main_rece_count = 0;
 137   1              main_dealwithTag = 0;
 138   1      //      check if during ISP mode if the address has been changed
 139   1              E2prom_Read_Byte(EEP_ADDRESS,& Modbus_address);
 140   1      
 141   1              // if it has not been changed, check the flash memory
 142   1              if( ( Modbus_address == 255) || ( Modbus_address == 0) )
 143   1              {
 144   2              //      if(E2prom_Read_Byte(EEP_ADDRESS, & address) )
 145   2                      {
 146   3                               Modbus_address = 254;
 147   3                              E2prom_Write_Byte(EEP_ADDRESS,  Modbus_address);
 148   3                      }
 149   2      
 150   2              }
 151   1              else
 152   1          {
 153   2                      E2prom_Write_Byte(EEP_ADDRESS,  Modbus_address);
 154   2      
 155   2              }
 156   1      
 157   1              // if data is blank, means first Time programming, thus put as default
 158   1              // Added by RL 02/11/04
 159   1              if( Modbus_address == 0 ||  Modbus_address == 255 ) 
 160   1                       Modbus_address = 254;
 161   1      
 162   1      
 163   1      
 164   1      }
 165          /****************************************************\
 166          *       CRC CODE START
 167          \****************************************************/
 168          U8_T MainCRChi = 0xff;
 169          U8_T MainCRClo = 0xff;
 170          U8_T SubCRChi = 0xff;
 171          U8_T SubCRClo = 0xff;
 172          
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 4   

 173          U8_T EthernetCRChi = 0xff;
 174          U8_T EthernetCRClo = 0xff;
 175          
 176          // Table of CRC values for high¡§Corder byt
 177          U8_T const code auchCRCHi[256] = {
 178                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
 179                  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
 180                  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
 181                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
 182                  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
 183                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
 184                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
 185                  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
 186                  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
 187                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
 188                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
 189                  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
 190                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
 191                  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
 192                  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
 193                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
 194          };      
 195          
 196          // Table of CRC values for low Corder byte
 197          U8_T const code  auchCRCLo[256] = {
 198                  0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04,
 199                  0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8,
 200                  0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
 201                  0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 0x11, 0xD1, 0xD0, 0x10,
 202                  0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
 203                  0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
 204                  0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C,
 205                  0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0,
 206                  0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
 207                  0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
 208                  0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C,
 209                  0xB4, 0x74, 0x75, 0xB5, 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
 210                  0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54,
 211                  0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
 212                  0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
 213                  0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
 214          };
 215          
 216          void sub_send_byte(U8_T buffer, U8_T crc);      
 217          
 218          //init crc 
 219          void main_init_crc16(void)
 220          {
 221   1              MainCRClo = 0xff;
 222   1              MainCRChi = 0xff;
 223   1      }
 224          
 225          void sub_init_crc16(void)
 226          {
 227   1              SubCRClo = 0xff;
 228   1              SubCRChi = 0xff;
 229   1      }
 230          
 231          void ethernet_init_crc16(void)
 232          {
 233   1              EthernetCRClo = 0xff;
 234   1              EthernetCRChi = 0xff;
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 5   

 235   1      }
 236          
 237          //calculate crc with one byte
 238          void main_crc16_byte(U8_T ch)
 239          {
 240   1              U8_T uIndex;
 241   1              uIndex = MainCRChi^ch; // calculate the CRC 
 242   1              MainCRChi = MainCRClo^auchCRCHi[uIndex];
 243   1              MainCRClo = auchCRCLo[uIndex];
 244   1      }
 245          
 246          void sub_crc16_byte(U8_T ch)
 247          {
 248   1              U8_T uIndex;
 249   1              uIndex = SubCRChi^ch; // calculate the CRC 
 250   1              SubCRChi = SubCRClo^auchCRCHi[uIndex];
 251   1              SubCRClo = auchCRCLo[uIndex];
 252   1      }
 253          
 254          void ethernet_crc16_byte(U8_T ch)
 255          {
 256   1              U8_T uIndex;
 257   1              uIndex = EthernetCRChi^ch; // calculate the CRC 
 258   1              EthernetCRChi = EthernetCRClo^auchCRCHi[uIndex];
 259   1              EthernetCRClo = auchCRCLo[uIndex];
 260   1      }
 261          
 262          //calculate crc 
 263          U16_T crc16(U8_T *p, U8_T length)
 264          {
 265   1              U16_T uchCRCHi = 0xff;  // high byte of CRC initialized 
 266   1              U8_T uchCRCLo = 0xff;   // low byte of CRC initialized 
 267   1              U8_T uIndex;                    // will index into CRC lookup table 
 268   1              U8_T i = 0;
 269   1      
 270   1              while(length--)//pass through message buffer 
 271   1              {               
 272   2                      uIndex = uchCRCHi^p[i++]; // calculate the CRC 
 273   2                      uchCRCHi = uchCRCLo^auchCRCHi[uIndex] ;
 274   2                      uchCRCLo = auchCRCLo[uIndex];
 275   2              }
 276   1              return (uchCRCHi << 8 | uchCRCLo);
 277   1      }
 278          /****************************************************\
 279          *       CRC CODE END
 280          \****************************************************/
 281          
 282          
 283          
 284          
 285          
 286          
 287          #if 1
 288          U8_T wait_SubSerial(U16_T delay)
 289          {
 290   1              U16_T far wait = 0;
 291   1      //      wait = 0;
 292   1              /* delay is to avoid dead cycle */
 293   1              while((sub_dealwithTag == 0) && (wait < delay)) 
 294   1              {
 295   2                      wait++;
 296   2                      vTaskDelay(1);                                  
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 6   

 297   2              }
 298   1              cQueueSend(xSubRevQueue, &sub_data_buffer, 0); 
 299   1              if(sub_dealwithTag == VALID_PACKET) return 1;   
 300   1              else return 0;
 301   1      }
 302          
 303          #endif
 304          
 305          void sub_serial_restart(void)
 306          {
 307   1              UART0_TXEN = RECEIVE;
 308   1      //      DELAY_Us(10);
 309   1              sub_rece_count = 0;
 310   1              sub_dealwithTag = 0;
 311   1      //      sub_rece_size = 8;      
 312   1      }
 313          
 314          void sub_net_init(void)
 315          {
 316   1              UART_Init(0);
 317   1              sub_serial_restart();
 318   1      //      sub_respond_state = SPARE;
 319   1      }
 320          
 321          void sub_init_send_com(void)
 322          {
 323   1              UART_Init(0);
 324   1              sub_transmit_finished = 0;
 325   1              UART0_TXEN = SEND;
 326   1              DELAY_Us(10);
 327   1      }
 328          
 329          void sub_send_byte(U8_T buffer, U8_T crc)
 330          {
 331   1              U8_T count = 0;
 332   1              SBUF0 = buffer;
 333   1              sub_transmit_finished = 0;
 334   1              while(!sub_transmit_finished && count < 20)
 335   1              {
 336   2                      DELAY_Us(1);
 337   2                      count++;
 338   2              }
 339   1              if(crc == CRC_NO)
 340   1              {
 341   2                      sub_crc16_byte(buffer);
 342   2              }
 343   1      }
 344          
 345          void sub_send_string(U8_T *bufs,char len)
 346          {
 347   1              char data i;
 348   1              U16_T crc_val;
 349   1              U8_T far buf[20];
 350   1              U16_T count;
 351   1      
 352   1              crc_val = crc16(bufs,len);
 353   1              memcpy(buf,bufs,len);
 354   1              buf[len] =  crc_val >> 8;
 355   1              buf[len + 1] =  crc_val;
 356   1      
 357   1              for(i = 0;i < len + 2;i++)
 358   1              {
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 7   

 359   2                      SBUF0 = buf[i];
 360   2                      sub_transmit_finished = 0;
 361   2                      count = 0;
 362   2                      while (!sub_transmit_finished && count < 20)
 363   2                      {
 364   3                      //      Test[40]++;
 365   3                              DELAY_Us(1);
 366   3                              count++;
 367   3                      }
 368   2                      if(sub_transmit_finished == 0)    Test[43]++;
 369   2              
 370   2              }
 371   1              
 372   1      }
 373          //------------------------serialport ----------------------------------
 374          //      serial port interrupt , deal with all action about serial port. include receive data and 
 375          //              send data and deal with interal.
 376          
 377          
 378          void handle_Modbus_RX0(void) interrupt 4
 379          {
 380   1              if(RI0 == 1)
 381   1              {
 382   2                      RI0 = 0;
 383   2      
 384   2                      if(sub_rece_count < SUB_BUF_LEN)
 385   2                              sub_data_buffer[sub_rece_count++] = SBUF0;
 386   2      
 387   2                      sub_serial_receive_timeout_count = 2;
 388   2      
 389   2                      if(sub_data_buffer[0] == 0)  {  sub_rece_count--;        }
 390   2              //      Test[41]= sub_rece_count;
 391   2                      if(sub_rece_count >= sub_rece_size)
 392   2                      {
 393   3                      //      Test[33]++;
 394   3                              sub_serial_receive_timeout_count = 0;
 395   3              //              Test[40] = sub_rece_count;
 396   3                      /*      if(xSubRevQueue != 0)
 397   3                              {  
 398   3                                      cQueueSendFromISR( xSubRevQueue, ( void * )&sub_data_buffer, 0);                                
 399   3                              } */
 400   3                              sub_dealwithTag = VALID_PACKET;
 401   3                      //      sub_rece_count = 0;
 402   3                      }
 403   2              }
 404   1              else if(TI0 == 1)
 405   1              {
 406   2                      TI0 = 0;
 407   2                      sub_transmit_finished = 1;
 408   2              }
 409   1              return;
 410   1      
 411   1      }
 412          
 413          
 414          
 415          
 416                  
 417          /*********************************************\
 418          *       MAIN NET CODE START
 419          \*********************************************/
 420          void main_serial_restart(void)
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 8   

 421          {
 422   1              UART1_TXEN = RECEIVE;
 423   1              main_rece_count = 0;
 424   1              main_dealwithTag = 0;
 425   1      }
 426          
 427          void main_net_init(void)
 428          {
 429   1      //      UART_Init(1);
 430   1              SERIAL_RECEIVE_TIMEOUT = 2;
 431   1              main_serial_restart();
 432   1      }
 433          
 434          void main_init_send_com(void)
 435          {
 436   1              main_transmit_finished = 0;
 437   1              UART1_TXEN = SEND;
 438   1              DELAY_Us(100);
 439   1      }
 440          
 441          void main_send_byte(U8_T buffer, U8_T crc)
 442          {
 443   1              SBUF1 = buffer;
 444   1              main_transmit_finished = 0;
 445   1              while(!main_transmit_finished);
 446   1              if(crc == CRC_NO)
 447   1              {
 448   2                      main_crc16_byte(buffer);
 449   2              }
 450   1      }
 451          
 452          void handle_Modbus_RX1(void) interrupt 6
 453          {
 454   1              if(RI1 == 1)
 455   1              {
 456   2                      RI1 = 0;                
 457   2                      if(main_rece_count < MAIN_BUF_LEN)
 458   2                              main_data_buffer[main_rece_count++] = SBUF1;
 459   2                      else
 460   2                              main_serial_restart();
 461   2                      
 462   2                      main_serial_receive_timeout_count = 2;//SERIAL_RECEIVE_TIMEOUT;
 463   2      
 464   2                      if(main_rece_count == 1)
 465   2                      {
 466   3                              main_rece_size = 8;
 467   3                              main_serial_receive_timeout_count = 2;//SERIAL_RECEIVE_TIMEOUT;
 468   3                      }
 469   2                      else if(main_rece_count == 4)
 470   2                      {
 471   3                              if((((U16_T)(main_data_buffer[2] << 8) + main_data_buffer[3]) == 0x0a) && (main_data_buffer[1] == WRITE
             -_VARIABLES))
 472   3                              {
 473   4                                      main_rece_size = DATABUFLEN_SCAN;
 474   4                                      main_serial_receive_timeout_count = 2;//SERIAL_RECEIVE_TIMEOUT; 
 475   4                              }
 476   3                      }
 477   2                      else if(main_rece_count == 7)
 478   2                      {
 479   3                              if(main_data_buffer[1] == MULTIPLE_WRITE)
 480   3                              {
 481   4                                      main_rece_size = main_data_buffer[6] + 9;
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 9   

 482   4                                      main_serial_receive_timeout_count = main_data_buffer[6] + 8;//from 4 to 8 to see if can resolve multip
             -le problem
 483   4                              }
 484   3                      }
 485   2      //              else if(((main_rece_count == main_rece_size) && ((main_data_buffer[1] == READ_VARIABLES) || (main_data
             -_buffer[1] == WRITE_VARIABLES) || (main_data_buffer[1] == MULTIPLE_WRITE))) || ((main_rece_count == 6) && (main_data_buf
             -fer[1] == CHECKONLINE)))
 486   2                      else if(main_rece_count == main_rece_size)
 487   2                      {        
 488   3                      
 489   3                              main_serial_receive_timeout_count = 0;
 490   3                              main_dealwithTag = VALID_PACKET;
 491   3                      }
 492   2              }
 493   1              else if(TI1 == 1)
 494   1              {
 495   2                      TI1 = 0;
 496   2                      main_transmit_finished = 1;
 497   2              }
 498   1      
 499   1              return;
 500   1      }
 501          
 502          
 503          // ------------------------dealwithdata -------------------------
 504          // the routine dealwith data ,it has three steps.
 505          // the 3 step is : 1 prepare to send data and init crc for next Tim
 506          //                                 2 dealwith interal
 507          //                 3 organize the data of sending, and send data.
 508          
 509          void main_dealwithData(void)
 510          {
 511   1              U16_T far address;
 512   1      //      static char tempcount = 0;
 513   1              U8_T frametype;
 514   1              portTickType xDelayPeriod = ( portTickType ) 50 / portTICK_RATE_MS;
 515   1              main_net_init();
 516   1              for( ; ;)
 517   1              {       
 518   2                      vTaskDelay(xDelayPeriod);
 519   2                      Test[11]++;
 520   2                      if(main_dealwithTag == VALID_PACKET)
 521   2                      {                                       
 522   3                              address = ((U16_T)main_data_buffer[2] << 8) + main_data_buffer[3];
 523   3                              if (checkData(address))
 524   3                              {       
 525   4                                      U16_T i;
 526   4                                      b_Master_Slave = CM5; 
 527   4                                                                      
 528   4                                      for(i = 0;i <  sub_no && !b_Master_Slave;i++)
 529   4                                      {
 530   5                                              if(main_data_buffer[0] == sub_addr[i])  
 531   5                                                      b_Master_Slave = TSTAT;  // Tstat is sub device
 532   5                                              else
 533   5                                                      b_Master_Slave = CM5;  // the current device is CM5
 534   5                                      } 
 535   4                                      
 536   4                                      if(b_Master_Slave == CM5)       
 537   4                                      {
 538   5                                              if(main_data_buffer[0] ==  Modbus_address || main_data_buffer[0] == 255)
 539   5                                              {
 540   6                                                      main_init_send_com();
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 10  

 541   6                              
 542   6                                                      main_init_crc16();
 543   6                              
 544   6                                                      main_responseData(address);
 545   6                                              }
 546   5                                      }
 547   4                                      else
 548   4                                      {  
 549   5                                              sub_init_send_com();
 550   5                                              if(main_data_buffer[1] == READ_VARIABLES) 
 551   5                                              {
 552   6                                                      sub_rece_size = main_data_buffer[5] * 2 + 5;
 553   6      
 554   6                                                      for(i = 0;i < 8;i++)
 555   6                                                      {
 556   7                                                              sub_send_byte(main_data_buffer[i],CRC_YES);
 557   7                                                      }                       
 558   6                                                      
 559   6                                              }
 560   5                                              else if(main_data_buffer[1] == WRITE_VARIABLES) 
 561   5                                              {
 562   6                                                      sub_rece_size = 8;
 563   6                                                      for(i = 0;i < 8;i++)
 564   6                                                      {
 565   7                                                              sub_send_byte(main_data_buffer[i],CRC_YES);
 566   7                                                      }
 567   6                                              }
 568   5                                              else if(main_data_buffer[1] == MULTIPLE_WRITE)  // MULTIPLE_WRITE
 569   5                                              {                               
 570   6                                                      sub_rece_size = 8;
 571   6                                                      for(i = 0;i < 137;i++)
 572   6                                                      {
 573   7                                                              sub_send_byte(main_data_buffer[i],CRC_YES);
 574   7                                                      }       
 575   6                                              }
 576   5                                              
 577   5                                              sub_serial_restart();  
 578   5                                              //comm_tstat = T3000_Control_Sub_Direct;
 579   5                                              wait_SubSerial(10);
 580   5                                              if(cQueueReceive( xSubRevQueue, &sub_data_buffer, 0))
 581   5                                              {
 582   6                                                      main_init_send_com();    // enable COM1 send 
 583   6                                                      // send data to MBPOLL or T3000 
 584   6                                                      for(i = 0;i < sub_rece_size;i++)                                        
 585   6                                                              main_send_byte(sub_data_buffer[i],CRC_YES);
 586   6                                              } 
 587   5                                      } 
 588   4                              }  
 589   3                                                              
 590   3                      // Restart the serial receive.
 591   3                              main_serial_restart();          
 592   3                      } 
 593   2                      else
 594   2                      {
 595   3                              main_serial_restart();          
 596   3                      /*      
 597   3                              //if(main_serial_receive_timeout_count > 10)    main_serial_receive_timeout_count = 5;
 598   3                              //if(main_serial_receive_timeout_count > 0)
 599   3                              {
 600   3                                      main_serial_receive_timeout_count--;
 601   3                                      if(main_serial_receive_timeout_count == 0)
 602   3                                      {
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 11  

 603   3                                              main_serial_restart();
 604   3                                      //      main_net_init();
 605   3                                      }
 606   3                              } */
 607   3                      } 
 608   2              
 609   2                      
 610   2              }
 611   1      
 612   1      }
*** WARNING C280 IN LINE 513 OF MODBUS\SERIALNEW.C: 'frametype': unreferenced local variable
 613          
 614          
 615          //---------------------checkdata ----------------------
 616          //This function calculates and verifies the checksum
 617          U8_T checkData(U8_T address)
 618          {
 619   1              U16_T crc_val;
 620   1              U8_T minaddr,maxaddr, variable_delay;
 621   1              U8_T randval;
 622   1      
 623   1              U8_T i;
 624   1      
 625   1      //      if(main_data_buffer[0] != 255 && main_data_buffer[0] !=  address && main_data_buffer[0] != 0)
 626   1      //              return FALSE;
 627   1      
 628   1              if(main_data_buffer[1] == CHECKONLINE)
 629   1              {
 630   2                      crc_val = crc16(main_data_buffer, 4);
 631   2                      if(crc_val != (main_data_buffer[4] << 8) + main_data_buffer[5])
 632   2                              return FALSE;
 633   2      
 634   2                      minaddr = (main_data_buffer[2] >= main_data_buffer[3]) ? main_data_buffer[3] : main_data_buffer[2];     
 635   2                      maxaddr = (main_data_buffer[2] >= main_data_buffer[3]) ? main_data_buffer[2] : main_data_buffer[3];     
 636   2                      if( address < minaddr ||  address > maxaddr)
 637   2                              return FALSE;
 638   2                      else
 639   2                      {
 640   3                              variable_delay = rand() % 20;
 641   3                              for (i = 0; i < variable_delay; i++);                           
 642   3                              return TRUE;
 643   3                      }
 644   2              }
 645   1              
 646   1              if((main_data_buffer[1] != READ_VARIABLES) && (main_data_buffer[1] != WRITE_VARIABLES) && (main_data_buff
             -er[1] != MULTIPLE_WRITE))
 647   1                      return FALSE;
 648   1       /*******************************************************************************************************/
 649   1        //copy from tstat code the add PLUG_N_PLAY function
 650   1              if(main_data_buffer[2]*256 + main_data_buffer[3] ==  MODBUS_ADDRESS_PLUG_N_PLAY)
 651   1              {
 652   2                      if(main_data_buffer[1] == WRITE_VARIABLES)
 653   2                      {
 654   3                              if(main_data_buffer[6] != serialNum[0]) 
 655   3                              return 0;
 656   3                              if(main_data_buffer[7] != serialNum[1]) 
 657   3                              return 0;
 658   3                              if(main_data_buffer[8] != serialNum[2])  
 659   3                              return 0;
 660   3                              if(main_data_buffer[9] != serialNum[3]) 
 661   3                              return 0;
 662   3                      }
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 12  

 663   2                      if (main_data_buffer[1] == READ_VARIABLES)
 664   2                      {
 665   3                              randval = rand() % 10 / 2 ;
 666   3                      }
 667   2      
 668   2                      if(randval != RESPONSERANDVALUE)
 669   2                      {
 670   3      //mhf:12-29-05 if more than 5 times does not response read register 10,reponse manuly.
 671   3                              rand_read_ten_count++;
 672   3                              if(rand_read_ten_count%5 == 0)
 673   3                              {
 674   4                                      rand_read_ten_count = 0;
 675   4                                      randval = RESPONSERANDVALUE;
 676   4                                      variable_delay = rand() % 10;
 677   4                                      for ( i=0; i<variable_delay; i++)
 678   4                                              DELAY_Us(75);
 679   4                              }
 680   3                              else
 681   3                                      return 0;
 682   3                      }
 683   2                      else
 684   2                      {               
 685   3                              // in the TRUE case, we add a random delay such that the Interface can pick up the packets
 686   3                              rand_read_ten_count = 0;
 687   3                              variable_delay = rand() % 10;
 688   3                              for ( i=0; i<variable_delay; i++)
 689   3                                      DELAY_Us(75);                           
 690   3                      }
 691   2              }
 692   1      
 693   1       /*******************************************************************************************************/
 694   1              
 695   1      
 696   1              crc_val = crc16(main_data_buffer, main_rece_size - 2);
 697   1      
 698   1              if(crc_val == ((U16_T)main_data_buffer[main_rece_size - 2] << 8) | main_data_buffer[main_rece_size - 1])
 699   1                      return TRUE;
 700   1              else
 701   1                      return FALSE;
 702   1      }
 703          
 704          
 705          void main_responseData(U16_T address)
 706          {
 707   1              responseCmd(MODBUS,main_data_buffer,NULL);
 708   1      }
*** WARNING C280 IN LINE 705 OF MODBUS\SERIALNEW.C: 'address': unreferenced local variable
 709          
 710          
 711          /* reponse READ command*/
 712          void responseCmd(U8_T type,U8_T* pData,HTTP_SERVER_CONN * pHttpConn)  
 713          {       
 714   1          U16_T far StartAdd;  
 715   1              U16_T far RegNum;
 716   1              U8_T far HeadLen; // Modbus head is 0, Tcp head is 6
 717   1              U16_T far loop;
 718   1              U8_T far sendbuf[200];
 719   1              U8_T far cmd;
 720   1              U8_T far temp;
 721   1              U8_T far tempbit;
 722   1              U8_T far temp_number;
 723   1              U8_T far temp_address;
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 13  

 724   1              U8_T far send_buffer;
 725   1              U8_T far tempbuf[100];  /* convert schedule structure */
 726   1              U8_T far update_flash;
 727   1      
 728   1              if(type == MODBUS)  // modbus packet
 729   1              {
 730   2                      HeadLen = 0;            
 731   2              }
 732   1              else   // TCP packet
 733   1              {
 734   2                      HeadLen = UIP_HEAD;
 735   2                      for(loop = 0;loop < 6;loop++)
 736   2                              sendbuf[loop] = 0;              
 737   2              }
 738   1      
 739   1              cmd = pData[HeadLen + 1];
 740   1              StartAdd = (U16_T)(pData[HeadLen + 2] <<8 ) + pData[HeadLen + 3];
 741   1              RegNum = (U8_T)pData[HeadLen + 5];
 742   1      
 743   1      
 744   1      /* add transaction id */
 745   1              
 746   1      
 747   1              if(cmd == READ_VARIABLES)
 748   1              {                       
 749   2                      sendbuf[HeadLen] = pData[HeadLen];
 750   2                      sendbuf[HeadLen + 1] = pData[HeadLen + 1];
 751   2                      sendbuf[HeadLen + 2] = RegNum * 2;
 752   2              
 753   2                      for(loop = 0 ;loop < RegNum;loop++)
 754   2                      {
 755   3                              if ( StartAdd + loop >= MODBUS_SERIALNUMBER_LOWORD && StartAdd + loop <= MODBUS_SERIALNUMBER_LOWORD + 3
             - )
 756   3                              {                       
 757   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 758   4                              //      sendbuf[HeadLen + 3 + loop * 2] = (Test[StartAdd + loop - MODBUS_SERIALNUMBER_LOWORD] >> 8) & 0xFF;;
             -        
 759   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  serialNum[StartAdd + loop - MODBUS_SERIALNUMBER_LOWORD];
 760   4                              //      sendbuf[HeadLen + 3 + loop * 2 + 1] = Test[StartAdd + loop - MODBUS_SERIALNUMBER_LOWORD] & 0xFF;
 761   4                              }
 762   3                              else if(StartAdd + loop == MODBUS_FIRMWARE_VERSION_NUMBER_LO)
 763   3                              {
 764   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;    
 765   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = SW_REV & 0xff;
 766   4                              }
 767   3                              else if(StartAdd + loop == MODBUS_FIRMWARE_VERSION_NUMBER_HI)
 768   3                              {
 769   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 770   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = SW_REV >> 8;                      
 771   4                              }
 772   3                              else if(StartAdd + loop == MODBUS_HARDWARE_REV)
 773   3                              {
 774   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 775   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = HW_REV;
 776   4                              }
 777   3                              else if(StartAdd + loop ==  MODBUS_ADDRESS)
 778   3                              {
 779   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;    
 780   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  Modbus_address;          
 781   4                              }
 782   3                              else if(StartAdd + loop == MODBUS_PRODUCT_MODEL)
 783   3                              {
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 14  

 784   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;    
 785   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = PRODUCT_CM5;
 786   4                              }
 787   3                              else if(StartAdd + loop == MODBUS_ISP_VER)
 788   3                              {
 789   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;    
 790   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  IspVer;
 791   4                              }
 792   3                              else if(StartAdd + loop == MODBUS_PIC)
 793   3                              {
 794   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;    
 795   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = PIC_REV;
 796   4                              }
 797   3                              else if(StartAdd + loop == MODBUS_BAUDRATE)
 798   3                              {
 799   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 800   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  baudrate;
 801   4                              }
 802   3                              else if(StartAdd + loop == MODBUS_UPDATE_STATUS)
 803   3                              {
 804   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 805   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  update_status;
 806   4                              }
 807   3                              else if(StartAdd + loop == MODBUS_DEMO_ENABLE)
 808   3                              {
 809   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 810   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  demo_enable;
 811   4                              }                       
 812   3                              else if(StartAdd + loop >= MODBUS_MAC_1 && StartAdd + loop <= MODBUS_MAC_6)
 813   3                              {
 814   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 815   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  Mac_Addr[StartAdd + loop - MODBUS_MAC_1];
 816   4                              }
 817   3                              else if(StartAdd + loop == MODBUS_TCP_TYPE)
 818   3                              {
 819   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;    
 820   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  TCP_TYPE;
 821   4                              }
 822   3                              else if(StartAdd + loop >= MODBUS_IP_1 && StartAdd + loop <= MODBUS_IP_4)
 823   3                              {
 824   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;    
 825   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  IP_Addr[StartAdd + loop - MODBUS_IP_1];
 826   4                              }
 827   3                              else if(StartAdd + loop >= MODBUS_SUBNET_1 && StartAdd + loop <= MODBUS_SUBNET_4)
 828   3                              {
 829   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;    
 830   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  SUBNET[StartAdd + loop - MODBUS_SUBNET_1];
 831   4                              }
 832   3                              else if(StartAdd + loop >= MODBUS_GETWAY_1 && StartAdd + loop <= MODBUS_GETWAY_4)
 833   3                              {
 834   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;    
 835   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  GETWAY[StartAdd + loop - MODBUS_GETWAY_1];
 836   4                              } 
 837   3                              else if(StartAdd + loop == MODBUS_TCP_LISTEN_PORT)
 838   3                              {
 839   4                                      sendbuf[HeadLen + 3 + loop * 2] = HTTP_SERVER_PORT >> 8;        
 840   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  (U8_T)HTTP_SERVER_PORT;
 841   4                              }
 842   3                      
 843   3      #if 1           
 844   3                              /* the following is for sub-tstat 
 845   3                              register 5670 - 5758
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 15  

 846   3                              register 160 - 200
 847   3                              */
 848   3      /* START SUB TSTAT */
 849   3                              else if(StartAdd + loop >= MODBUS_SUBADDR_FIRST && StartAdd + loop <= MODBUS_SUBADDR_LAST)
 850   3                              {  // 160 - 167
 851   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;    
 852   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  sub_addr[StartAdd + loop  - MODBUS_SUBADDR_FIRST];
 853   4                              }
 854   3                              else if(StartAdd + loop == MODBUS_OCCUPIED)
 855   3                              {
 856   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 857   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = tstat_occupied;
 858   4                              }
 859   3                              else if(StartAdd + loop >= MODBUS_ROOM_SETPOINT_FIRST && StartAdd + loop <= MODBUS_ROOM_SETPOINT_LAST)
 860   3                              {
 861   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 862   4                                      
 863   4                                      if(StartAdd + loop  - MODBUS_ROOM_SETPOINT_FIRST <  sub_no)     
 864   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = tstat_setpoint[StartAdd + loop  - MODBUS_ROOM_SETPOINT_FIRST];
 865   4                                      else 
 866   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = 0;
 867   4                              }
 868   3                              else if(StartAdd + loop >= MODBUS_COOL_SETPOINT_FIRST && StartAdd + loop <= MODBUS_COOL_SETPOINT_LAST)
 869   3                              {
 870   4                                      
 871   4                                      if(StartAdd + loop  - MODBUS_COOL_SETPOINT_FIRST <  sub_no)     
 872   4                                      {
 873   5                                              sendbuf[HeadLen + 3 + loop * 2] = tstat_cool_setpoint[StartAdd + loop  - MODBUS_COOL_SETPOINT_FIRST] 
             ->> 8;
 874   5                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = (U8_T)tstat_cool_setpoint[StartAdd + loop  - MODBUS_COOL_SETPOI
             -NT_FIRST];
 875   5                                      }
 876   4                                      else 
 877   4                                      {
 878   5                                              sendbuf[HeadLen + 3 + loop * 2] = 0;
 879   5                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = 0;
 880   5                                      }
 881   4                              }
 882   3                              else if(StartAdd + loop >= MODBUS_HEAT_SETPOINT_FIRST && StartAdd + loop <= MODBUS_HEAT_SETPOINT_LAST)
 883   3                              {
 884   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 885   4                                      if(StartAdd + loop  - MODBUS_HEAT_SETPOINT_FIRST <  sub_no)     
 886   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = tstat_heat_setpoint[StartAdd + loop  - MODBUS_HEAT_SETPOINT_FIR
             -ST];
 887   4                                      else 
 888   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = 0;
 889   4                              }
 890   3                              else if(StartAdd + loop >= MODBUS_ROOM_TEM_FIRST && StartAdd + loop <= MODBUS_ROOM_TEM_LAST)
 891   3                              {
 892   4                                      
 893   4                                      if(StartAdd + loop  - MODBUS_ROOM_TEM_FIRST <  sub_no)
 894   4                                      {       
 895   5                                              sendbuf[HeadLen + 3 + loop * 2] = tstat_temperature[StartAdd + loop  - MODBUS_ROOM_TEM_FIRST] >> 8;
 896   5                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = (U8_T)tstat_temperature[StartAdd + loop  - MODBUS_ROOM_TEM_FIRS
             -T];
 897   5                                      }
 898   4                                      else 
 899   4                                      {
 900   5                                              sendbuf[HeadLen + 3 + loop * 2] = 0;
 901   5                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = 0;
 902   5                                      }
 903   4                              }
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 16  

 904   3                              else if(StartAdd + loop >= MODBUS_MODE_FIRST && StartAdd + loop <= MODBUS_MODE_LAST)
 905   3                              {
 906   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;                            
 907   4                                      if(StartAdd + loop  - MODBUS_MODE_FIRST <  sub_no)      
 908   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = tstat_mode[StartAdd + loop  - MODBUS_MODE_FIRST];
 909   4                                      else 
 910   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = 0;
 911   4                              }
 912   3                              else if(StartAdd + loop >= MODBUS_OUTPUT_STATE_FIRST && StartAdd + loop <= MODBUS_OUTPUT_STATE_LAST)
 913   3                              {
 914   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;                            
 915   4                                      if(StartAdd + loop  - MODBUS_OUTPUT_STATE_FIRST <  sub_no)      
 916   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = tstat_output_state[StartAdd + loop  - MODBUS_OUTPUT_STATE_FIRST
             -];
 917   4                                      else 
 918   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = 0;
 919   4                              }
 920   3                              else if(StartAdd + loop >= MODBUS_NIGHT_HEAT_DB_FIRST && StartAdd + loop <= MODBUS_NIGHT_HEAT_DB_LAST)
 921   3                              {
 922   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 923   4                                      if(StartAdd + loop  - MODBUS_NIGHT_HEAT_DB_FIRST <  sub_no)     
 924   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = tstat_night_heat_db[StartAdd + loop  - MODBUS_NIGHT_HEAT_DB_FIR
             -ST];
 925   4                                      else 
 926   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = 0;
 927   4                              }
 928   3                              else if(StartAdd + loop >= MODBUS_NIGHT_COOL_DB_FIRST && StartAdd + loop <= MODBUS_NIGHT_COOL_DB_LAST)
 929   3                              {
 930   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 931   4                                      if(StartAdd + loop  - MODBUS_NIGHT_COOL_DB_FIRST <  sub_no)     
 932   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = tstat_night_cool_db[StartAdd + loop  - MODBUS_NIGHT_COOL_DB_FIR
             -ST];
 933   4                                      else 
 934   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = 0;
 935   4                              }
 936   3                              else if(StartAdd + loop >= MODBUS_NIGHT_HEAT_SP_FIRST && StartAdd + loop <= MODBUS_NIGHT_HEAT_SP_LAST)
 937   3                              {
 938   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 939   4                                      if(StartAdd + loop  - MODBUS_NIGHT_HEAT_SP_FIRST <  sub_no)     
 940   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = tstat_night_heat_sp[StartAdd + loop  - MODBUS_NIGHT_HEAT_SP_FIR
             -ST];
 941   4                                      else 
 942   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = 0;
 943   4                              }
 944   3                              else if(StartAdd + loop >= MODBUS_NIGHT_COOL_SP_FIRST && StartAdd + loop <= MODBUS_NIGHT_COOL_SP_LAST)
 945   3                              {
 946   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 947   4                                      if(StartAdd + loop  - MODBUS_NIGHT_COOL_SP_FIRST <  sub_no)     
 948   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = tstat_night_cool_sp[StartAdd + loop  - MODBUS_NIGHT_COOL_SP_FIR
             -ST];
 949   4                                      else 
 950   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = 0;
 951   4                              }
 952   3                              else if(StartAdd + loop >= MODBUS_PRODUCT_MODEL_FIRST && StartAdd + loop <= MODBUS_PRODUCT_MODEL_LAST)
 953   3                              {
 954   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 955   4                                      if(StartAdd + loop  - MODBUS_PRODUCT_MODEL_FIRST <  sub_no)     
 956   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = tstat_product_model[StartAdd + loop  - MODBUS_PRODUCT_MODEL_FIR
             -ST];
 957   4                                      else 
 958   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = 0;
 959   4                              }
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 17  

 960   3                              else if(StartAdd + loop >= MODBUS_OVER_RIDE_FIRST && StartAdd + loop <= MODBUS_OVER_RIDE_LAST)
 961   3                              {       
 962   4                                      if(StartAdd + loop  - MODBUS_OVER_RIDE_FIRST <  sub_no) 
 963   4                                      {                       
 964   5                                              sendbuf[HeadLen + 3 + loop * 2] = tstat_over_ride[StartAdd + loop  - MODBUS_OVER_RIDE_FIRST] >> 8;
 965   5                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = (U8_T)tstat_over_ride[StartAdd + loop  - MODBUS_OVER_RIDE_FIRST
             -];                
 966   5                                      }
 967   4                                      else 
 968   4                                      {
 969   5                                              sendbuf[HeadLen + 3 + loop * 2] = 0;
 970   5                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = 0;
 971   5                                      }
 972   4                              }
 973   3                              else if(StartAdd + loop >= MODBUS_SERIAL_NUM_FIRST && StartAdd + loop <= MODBUS_SERIAL_NUM_LAST)  // ha
             -ve  4 * 8= 32 bytes 
 974   3                              {
 975   4                                      
 976   4                                      if((StartAdd + loop  - MODBUS_SERIAL_NUM_FIRST) / 4 <  sub_no)  
 977   4                                      {       
 978   5                                              sendbuf[HeadLen + 3 + loop * 2] = 0;
 979   5                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = tstat_serial_number[(StartAdd + loop  - MODBUS_SERIAL_NUM_FIRST
             -)/4][(StartAdd + loop  - MODBUS_SERIAL_NUM_FIRST)%4];
 980   5                                      }
 981   4                                      else
 982   4                                      {       
 983   5                                              sendbuf[HeadLen + 3 + loop * 2] = 0;
 984   5                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = 0;
 985   5                                      }
 986   4                              }
 987   3      /*  END SUB TSTAT */
 988   3                              else if(StartAdd + loop == MODBUS_TOTAL_NO)     
 989   3                              {       
 990   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 991   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  sub_no;
 992   4                              }
 993   3                              else if(StartAdd + loop == MODBUS_TOTAL_HEAT)   
 994   3                              {       
 995   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
 996   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  heat_no;
 997   4                              }
 998   3                              else if(StartAdd + loop == MODBUS_TOTAL_COOL)   
 999   3                              {       
1000   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1001   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  cool_no;
1002   4                              }
1003   3                              else if(StartAdd + loop == MODBUS_REFRESH_STATUS)
1004   3                              {       
1005   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1006   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = REFRESH_STATUS;
1007   4                              }
1008   3      #endif
1009   3      /******************************end for tstst resigter ************************************************/
1010   3                              else if(StartAdd + loop >= MODBUS_AINPUT1 && StartAdd + loop <= MODBUS_AINPUT10)
1011   3                              {
1012   4                                      U16_T tempValue;
1013   4                                      tempValue = AI_Value[StartAdd + loop - MODBUS_AINPUT1];
1014   4      
1015   4                              //      if( AInputAM & (0x01 << (StartAdd + loop - MODBUS_AINPUT1)) == 0)  // auto
1016   4                                      {
1017   5                                      
1018   5                                      sendbuf[HeadLen + 3 + loop * 2] = (RangeConverter(Input_Range[StartAdd + loop - MODBUS_AINPUT1],
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 18  

1019   5                                                              tempValue, StartAdd + loop - MODBUS_AINPUT1, Input_CAL[StartAdd + loop - MODBUS_AINPUT1])>> 8) & 0x
             -FF;
1020   5                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = RangeConverter(Input_Range[StartAdd + loop - MODBUS_AINPUT1],
1021   5                                                              tempValue, StartAdd + loop - MODBUS_AINPUT1, Input_CAL[StartAdd + loop - MODBUS_AINPUT1]) & 0xFF;
1022   5                                      }
1023   4                              /*      else
1024   4                                      {
1025   4                                              sendbuf[HeadLen + 3 + loop * 2] = tempValue >> 8;
1026   4                                              sendbuf[HeadLen + 3 + loop * 2 + 1] = tempValue;
1027   4                                      } */
1028   4                              }
1029   3                              else if(StartAdd + loop >= MODBUS_INPUT1_RANGE && StartAdd + loop <= MODBUS_INPUT10_RANGE)
1030   3                              {
1031   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1032   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  Input_Range[StartAdd + loop - MODBUS_INPUT1_RANGE];
1033   4                              }
1034   3                              
1035   3                              else if(StartAdd + loop >= MODBUS_INPUT1_FILTER && StartAdd + loop <= MODBUS_INPUT10_FILTER)
1036   3                              {
1037   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1038   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  Input_Filter[StartAdd + loop - MODBUS_INPUT1_FILTER];
1039   4                              }
1040   3                              else if(StartAdd + loop >= MODBUS_INPUT1_CAL && StartAdd + loop <= MODBUS_INPUT10_CAL)
1041   3                              {
1042   4                                      sendbuf[HeadLen + 3 + loop * 2] = (U8_T)( Input_CAL[StartAdd + loop - MODBUS_INPUT1_CAL] >> 8);
1043   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = (U8_T)( Input_CAL[StartAdd + loop - MODBUS_INPUT1_CAL]);
1044   4                              }
1045   3                              else if(StartAdd + loop >= MODBUS_DI_TYPE1 && StartAdd + loop <= MODBUS_DI_TYPE8)
1046   3                              {
1047   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1048   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  DI_Type[StartAdd + loop - MODBUS_DI_TYPE1];
1049   4                              }
1050   3                              else if(StartAdd + loop == MODBUS_DI1)
1051   3                              {
1052   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1053   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  DI1_Value;
1054   4                              }
1055   3                              else if(StartAdd + loop == MODBUS_DI2)
1056   3                              {
1057   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1058   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  DI2_Value;
1059   4                              }
1060   3                              else if(StartAdd + loop == MODBUS_DOUTPUT)
1061   3                              {
1062   4                                      sendbuf[HeadLen + 3 + loop * 2] = (U8_T)(DO_Value >> 8);
1063   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  (U8_T)DO_Value;
1064   4                              }
1065   3                              else if(StartAdd + loop == MODBUS_SWITCH)   /* switch logic */
1066   3                              {
1067   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1068   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  DO_SoftSwitch;
1069   4                              }
1070   3                              else if(StartAdd + loop == MODBUS_PRIORTITY)   /* switch logic */
1071   3                              {
1072   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1073   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  Priority;
1074   4                              }
1075   3                              else if(StartAdd + loop == MODBUS_COUNT_PRI)   /* count priority timer,count down */
1076   3                              {
1077   4                                      sendbuf[HeadLen + 3 + loop * 2] = (U8_T)(( Priority * 60 -  count_priority) >> 8);
1078   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = (U8_T)( Priority * 60 -  count_priority);
1079   4                              }
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 19  

1080   3                              else if(StartAdd + loop == MODBUS_DI_ENABLE)
1081   3                              {
1082   4                                      sendbuf[HeadLen + 3 + loop * 2] = (U8_T)( DI_Enable >> 8);
1083   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = (U8_T)( DI_Enable);
1084   4                              }
1085   3                              else if(StartAdd + loop == MODBUS_AI_ENABLE)
1086   3                              {
1087   4                                      sendbuf[HeadLen + 3 + loop * 2] = (U8_T)( AI_Enable >> 8);
1088   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = (U8_T)( AI_Enable);
1089   4                              }
1090   3                              else if(StartAdd + loop == MODBUS_DINPUT_AM)
1091   3                              {
1092   4                                      sendbuf[HeadLen + 3 + loop * 2] = (U8_T)( DInputAM >> 8);
1093   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = (U8_T)( DInputAM);
1094   4                              }
1095   3                              else if(StartAdd + loop == MODBUS_OUTPUT_AM)
1096   3                              {
1097   4                                      sendbuf[HeadLen + 3 + loop * 2] = (U8_T)( OuputAM >> 8);
1098   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = (U8_T)( OuputAM);
1099   4                              }
1100   3                              else if(StartAdd + loop == MODBUS_AINPUT_AM)
1101   3                              {
1102   4                                      sendbuf[HeadLen + 3 + loop * 2] = (U8_T)( AInputAM >> 8);
1103   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = (U8_T)( AInputAM);
1104   4                              }
1105   3                              else if(StartAdd + loop >= MODBUS_TIMER_ADDRESS && StartAdd + loop < MODBUS_TIMER_ADDRESS + 8)
1106   3                              {        
1107   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1108   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] =  RTC.all[StartAdd + loop - MODBUS_TIMER_ADDRESS];
1109   4                              }
1110   3                              else if( StartAdd + loop >= MODBUS_WR_DESCRIP_FIRST && StartAdd + loop < MODBUS_WR_DESCRIP_LAST)
1111   3                              {
1112   4                                      temp_number = (StartAdd + loop - MODBUS_WR_DESCRIP_FIRST) / WR_DESCRIPTION_SIZE;
1113   4                                      temp_address = (StartAdd + loop - MODBUS_WR_DESCRIP_FIRST) % WR_DESCRIPTION_SIZE;
1114   4      
1115   4                                      send_buffer = WR_Roution[temp_number].UN.all[temp_address];
1116   4                                  if(temp_address == WR_DESCRIPTION_SIZE - 1 && send_buffer != 0xff)
1117   4                                      {
1118   5                                              if((send_buffer & 0x80) == 0)
1119   5                                              {
1120   6                                                      if(GetBit(temp_number,wr_state_index))
1121   6                                                      send_buffer |= 0x40;
1122   6                                                      else
1123   6                                                      send_buffer &= 0xbf;
1124   6                                              }
1125   5                                              if(GetBit(temp_number,holiday1_state_index))
1126   5                                              send_buffer |= 0x20;
1127   5                                              else
1128   5                                              send_buffer &= 0xdf;
1129   5                                              if(GetBit(temp_number,holiday2_state_index))
1130   5                                              send_buffer |= 0x10;
1131   5                                              else
1132   5                                              send_buffer &= 0xef;
1133   5                                      }
1134   4      
1135   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1136   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = send_buffer;      
1137   4                                      
1138   4                              }
1139   3                              else if( StartAdd + loop >= MODBUS_AR_DESCRIP_FIRST && StartAdd + loop < MODBUS_AR_DESCRIP_LAST)
1140   3                              {
1141   4                                      temp_number = (StartAdd + loop - MODBUS_AR_DESCRIP_FIRST) / AR_DESCRIPTION_SIZE;    // line
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 20  

1142   4                                      temp_address = (StartAdd + loop - MODBUS_AR_DESCRIP_FIRST) % AR_DESCRIPTION_SIZE;
1143   4                                      send_buffer = AR_Roution[temp_number].UN.all[temp_address];
1144   4      
1145   4                                      if(temp_address == AR_DESCRIPTION_SIZE - 1)
1146   4                                      {
1147   5                                              if((send_buffer & 0x80) == 0)
1148   5                                              {
1149   6                                                      if(GetBit(temp_number,ar_state_index))
1150   6                                                      send_buffer |= 0x40;
1151   6                                                      else
1152   6                                                      send_buffer &= 0xbf;
1153   6                                              }
1154   5                                      }
1155   4      
1156   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1157   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = send_buffer;
1158   4                                      
1159   4                              }
1160   3                              else if( StartAdd + loop >= MODBUS_ID_FIRST && StartAdd + loop < MODBUS_ID_LAST)
1161   3                              {
1162   4                                      temp_number = (StartAdd + loop - MODBUS_ID_FIRST) / ID_SIZE;
1163   4                                      temp_address = (StartAdd + loop - MODBUS_ID_FIRST) % ID_SIZE;
1164   4                                      send_buffer = ID_Config[temp_number].all[temp_address];
1165   4                      
1166   4      
1167   4                                      // --- send first byte -------------                    
1168   4                              //      Send_Byte(send_buffer,CRC_NO);  
1169   4                                      
1170   4                                      // --- send second byte ------------                     
1171   4                      
1172   4                                      if(temp_address == ID_SIZE - 1 && send_buffer != 0xff)
1173   4                                      {
1174   5                                              if((send_buffer & 0x80) == 0)
1175   5                                              {
1176   6                                                      if(GetBit(temp_number,output_state_index))
1177   6                                                      send_buffer |= 0x40;
1178   6                                                      else
1179   6                                                      send_buffer &= 0xbf;
1180   6                                              }
1181   5                                              if(GetBit(temp_number,schedual1_state_index))
1182   5                                              send_buffer |= 0x20;
1183   5                                              else
1184   5                                              send_buffer &= 0xdf;
1185   5                                              if(GetBit(temp_number,schedual2_state_index))
1186   5                                              send_buffer |= 0x10;
1187   5                                              else
1188   5                                              send_buffer &= 0xef;
1189   5                                      }
1190   4      
1191   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1192   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = send_buffer;      
1193   4                              }
1194   3                              else if( StartAdd + loop >= MODBUS_AR_TIME_FIRST && StartAdd + loop < MODBUS_WR_ONTIME_FIRST )
1195   3                              {
1196   4                                      temp_number = (StartAdd + loop - MODBUS_AR_TIME_FIRST) / AR_TIME_SIZE;
1197   4                                      temp_address = (StartAdd + loop-MODBUS_AR_TIME_FIRST)%AR_TIME_SIZE;
1198   4      
1199   4                                      send_buffer = AR_Roution[temp_number].Time[temp_address];
1200   4      
1201   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1202   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = send_buffer;      
1203   4                              }
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 21  

1204   3                              else if( StartAdd + loop >= MODBUS_WR_ONTIME_FIRST && StartAdd + loop < MODBUS_WR_OFFTIME_FIRST )
1205   3                              {
1206   4                                      temp_number =   (StartAdd + loop - MODBUS_WR_ONTIME_FIRST) / WR_TIME_SIZE;              
1207   4                                      temp_address = (StartAdd + loop - MODBUS_WR_ONTIME_FIRST) % WR_TIME_SIZE;
1208   4                                      send_buffer = WR_Roution[temp_number].OnTime[temp_address];
1209   4      
1210   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1211   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = send_buffer;
1212   4                              }
1213   3                              else if( StartAdd + loop >= MODBUS_WR_OFFTIME_FIRST && StartAdd + loop <= MODBUS_WR_OFFTIME_LAST )
1214   3                              {
1215   4                                      // --- send first byte -------------                    
1216   4                                      
1217   4                                      temp_number = (StartAdd + loop - MODBUS_WR_OFFTIME_FIRST) / WR_TIME_SIZE;
1218   4                                      temp_address = (StartAdd + loop - MODBUS_WR_OFFTIME_FIRST) % WR_TIME_SIZE;
1219   4      
1220   4                                      send_buffer = WR_Roution[temp_number].OffTime[temp_address];
1221   4      
1222   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1223   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = send_buffer;                      
1224   4                              }       
1225   3                              /*else if(StartAdd + loop >= MODBUS_TSTAT_OFFTIME_FIRST && StartAdd + loop <= MODBUS_TSTAT_OFFTIME_LAST
             - )        
1226   3                              {
1227   3                                      sendbuf[HeadLen + 3 + loop * 2] = (U8_T) (time_tstat_off[StartAdd + loop - MODBUS_TSTAT_OFFTIME_FIRST]
             - >> 8);
1228   3                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = (U8_T)time_tstat_off[StartAdd + loop - MODBUS_TSTAT_OFFTIME_FIRS
             -T];
1229   3                              }       
1230   3                              else if(StartAdd + loop >= MODBUS_TSTAT_ONTIME_FIRST && StartAdd + loop <= MODBUS_TSTAT_ONTIME_LAST )   
1231   3                              {
1232   3                                      sendbuf[HeadLen + 3 + loop * 2] = (U8_T)(time_tstat_on[StartAdd + loop - MODBUS_TSTAT_ONTIME_FIRST] >>
             - 8);
1233   3                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = (U8_T)time_tstat_on[StartAdd + loop - MODBUS_TSTAT_ONTIME_FIRST]
             -;
1234   3                              }*/
1235   3                              else if( StartAdd + loop >= MODBUS_TEST && StartAdd + loop <= MODBUS_TEST_50 )
1236   3                              {
1237   4                                      sendbuf[HeadLen + 3 + loop * 2] = (Test[StartAdd + loop - MODBUS_TEST] >> 8) & 0xFF;
1238   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = Test[StartAdd + loop - MODBUS_TEST] & 0xFF;
1239   4                              }
1240   3                         /**************** start of names inputs and output *********************/
1241   3                          else if(StartAdd + loop >= MODBUS_NAME_FIRST && StartAdd + loop <= MODBUS_NAME_LAST)
1242   3                              {
1243   4                                      unsigned char temp = (StartAdd + loop - MODBUS_NAME_FIRST);
1244   4                                      sendbuf[HeadLen + 3 + loop * 2] = menu_name[temp / (NAME_SIZE / 2)][(temp % (NAME_SIZE / 2)) * 2 ];
1245   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = menu_name[temp / (NAME_SIZE / 2)][(temp % (NAME_SIZE / 2)) * 2 +
             - 1];                        
1246   4                              }       
1247   3                         /******************end of names of inputs and outputs ******************/
1248   3                              else if(StartAdd + loop == MODBUS_DISPLAY_TEMP_NUM)
1249   3                              {
1250   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1251   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = dis_temp_num;
1252   4                              }       
1253   3                              else if(StartAdd + loop == MODBUS_DISPLAY_TMEP_INTERVAL)
1254   3                              {
1255   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1256   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = dis_temp_interval;
1257   4                              }       
1258   3                              else if(StartAdd + loop >= MODBUS_DISPLAY_TEMP_SEQ_FIRST && StartAdd + loop <= MODBUS_DISPLAY_TEMP_SEQ_
             -LAST)
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 22  

1259   3                              {
1260   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;
1261   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = dis_temp_seq[StartAdd + loop - MODBUS_DISPLAY_TEMP_SEQ_FIRST];
1262   4                              }
1263   3                              else
1264   3                              {
1265   4                                      sendbuf[HeadLen + 3 + loop * 2] = 0;    
1266   4                                      sendbuf[HeadLen + 3 + loop * 2 + 1] = 1;
1267   4                              }
1268   3                      }
1269   2      
1270   2                      if(type == MODBUS)
1271   2                      {
1272   3                              main_init_send_com();
1273   3                              for(loop = 0;loop < RegNum * 2 + 3;loop++)
1274   3                                      main_send_byte(sendbuf[loop],CRC_NO);
1275   3      
1276   3                              main_send_byte(MainCRChi,CRC_YES);
1277   3                              main_send_byte(MainCRClo,CRC_YES);
1278   3                      }
1279   2                      else // TCP
1280   2                      {
1281   3                              TransID =  ((U16_T)pData[0] << 8) | pData[1];
1282   3                              sendbuf[0] = TransID >> 8;                      //      TransID
1283   3                              sendbuf[1] = (U8_T)TransID;     
1284   3                              sendbuf[2] = 0;                 //      ProtoID
1285   3                              sendbuf[3] = 0;
1286   3                              sendbuf[4] = (6 + RegNum * 2) >> 8;     //      Len
1287   3                              sendbuf[5] = (U8_T)(6 + RegNum * 2) ;
1288   3      
1289   3                              TCPIP_TcpSend(pHttpConn->TcpSocket, sendbuf, RegNum * 2 + HeadLen + 3, TCPIP_SEND_NOT_FINAL); 
1290   3                      }
1291   2              }
1292   1              else if(cmd == WRITE_VARIABLES)
1293   1              {               
1294   2                      
1295   2                      if(type == MODBUS)
1296   2                      {
1297   3                              main_init_send_com();
1298   3                              /* send data back */
1299   3                              for (loop = 0;loop < 8;loop++)
1300   3                              {
1301   4                                      main_send_byte(pData[loop],CRC_YES);    
1302   4                              }
1303   3                      }
1304   2                      else // TCP   dont have CRC 
1305   2                      {
1306   3                      //      SetTransactionId(6 + UIP_HEAD);
1307   3      
1308   3                              sendbuf[0] = pData[0];//0;                      //      TransID
1309   3                              sendbuf[1] = pData[1];//TransID++;      
1310   3                              sendbuf[2] = 0;                 //      ProtoID
1311   3                              sendbuf[3] = 0;
1312   3                              sendbuf[4] = (3 + UIP_HEAD) >> 8;       //      Len
1313   3                              sendbuf[5] = (U8_T)(3 + UIP_HEAD) ;
1314   3      
1315   3                              for (loop = 0;loop < 6;loop++)
1316   3                              {
1317   4                                      sendbuf[HeadLen + loop] = pData[HeadLen + loop];        
1318   4                              }
1319   3                              TCPIP_TcpSend(pHttpConn->TcpSocket, sendbuf, 6 + UIP_HEAD, TCPIP_SEND_NOT_FINAL); 
1320   3                      }
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 23  

1321   2      
1322   2      
1323   2                      /* dealwith write command */
1324   2                      if (StartAdd >= MODBUS_SERIALNUMBER_LOWORD && StartAdd <= MODBUS_SERIALNUMBER_LOWORD + 3 )
1325   2                      {
1326   3                              if((StartAdd == MODBUS_SERIALNUMBER_LOWORD) && (SNWriteflag & 0x01) == 0)
1327   3                              {
1328   4                                       serialNum[0] = pData[HeadLen + 5];
1329   4                                       serialNum[1] = pData[HeadLen + 4];
1330   4                                      E2prom_Write_Byte(EEP_SERIALNUMBER_LOWORD , serialNum[0]);
1331   4                                      E2prom_Write_Byte(EEP_SERIALNUMBER_LOWORD + 1, serialNum[1]);
1332   4      
1333   4                                      SNWriteflag |= 0x01;
1334   4                                      if(SNWriteflag & 0x02)
1335   4                                              update_flash = 0;
1336   4                              }
1337   3                              else if((StartAdd == MODBUS_SERIALNUMBER_HIWORD) && (SNWriteflag & 0x02) == 0)
1338   3                              {
1339   4                                       serialNum[2] = pData[HeadLen + 5];
1340   4                                       serialNum[3] = pData[HeadLen + 4];
1341   4                                      E2prom_Write_Byte(EEP_SERIALNUMBER_HIWORD , serialNum[2]);
1342   4                                      E2prom_Write_Byte(EEP_SERIALNUMBER_HIWORD + 1, serialNum[3]);
1343   4                                      SNWriteflag |= 0x02;
1344   4                                      if(SNWriteflag & 0x01)
1345   4                                              update_flash = 0;
1346   4                              }
1347   3                      }
1348   2                      else if(StartAdd == MODBUS_HARDWARE_REV)
1349   2                      {       
1350   3                               hardRev = pData[HeadLen + 5]+ (pData[HeadLen + 4]<<8);
1351   3                              E2prom_Write_Byte(EEP_HARDWARE_REV, pData[HeadLen + 5]+ (pData[HeadLen + 4]<<8) );
1352   3      
1353   3                              Lcd_Initial();
1354   3                              //SNWriteflag |= 0x04;
1355   3                              //E2prom_Write_Int(EEP_SERINALNUMBER_WRITE_FLAG, SNWriteflag );
1356   3                              //hardware_rev = pData[HeadLen + 5];
1357   3                      }
1358   2                      else if(StartAdd ==  MODBUS_ADDRESS )
1359   2                      {
1360   3                               Modbus_address = pData[HeadLen + 5]+ (pData[HeadLen + 4]<<8);
1361   3                              E2prom_Write_Byte(EEP_ADDRESS, Modbus_address);
1362   3                      }
1363   2                      else if(StartAdd == MODBUS_UPDATE_STATUS)
1364   2                      {
1365   3                              update_flash = pData[HeadLen + 5];
1366   3                              if(update_flash == 0x9F)
1367   3                              {
1368   4                                      //...
1369   4                              }               
1370   3                              else if((update_flash == 0x8E) || (update_flash == 0x8F))
1371   3                              {
1372   4                                      if(update_flash == 0x8e)
1373   4                                      {
1374   5                                              SNWriteflag = 0x00;
1375   5                                              E2prom_Write_Byte(EEP_SERIALNUMBER_WRITE_FLAG, SNWriteflag);
1376   5      
1377   5                                               serialNum[0] = 0;
1378   5                                               serialNum[1] = 0;
1379   5                                               serialNum[2] = 0;
1380   5                                               serialNum[3] = 0;
1381   5                                      }
1382   4                              }
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 24  

1383   3                      }
1384   2      
1385   2                      /*else if(StartAdd >= MODBUS_MINADDR && StartAdd <= MODBUS_MAXADDR)              
1386   2                      {                                                               
1387   2                              E2prom_Write_Byte(EEP_MINADDR + StartAdd - MODBUS_MINADDR, pData[HeadLen + 5] );
1388   2                               address = pData[HeadLen + 5] ; 
1389   2                      //      iap_program_data_byte(0,DATA_TO_FIRMWARE + EEP_ADDRESS);        // will reset the address to 254 if in ISP m
             -ode
1390   2                              IntFlashWriteByte(0x70000 + DATA_TO_FIRMWARE + StartAdd - MODBUS_MINADDR,0);
1391   2                      }*/
1392   2                      else if(StartAdd == MODBUS_BAUDRATE )
1393   2                      {
1394   3                               baudrate = pData[HeadLen + 5];
1395   3                              E2prom_Write_Byte(EEP_BAUDRATE, pData[HeadLen + 5] );
1396   3                      
1397   3                              if(pData[HeadLen + 5] == 1)
1398   3                              {
1399   4                                      PCON  |= 0XC0 ;
1400   4                                      //SERIAL_RECEIVE_TIMEOUT = 3;
1401   4                              }
1402   3                              else
1403   3                              {
1404   4                                      PCON  = 0X00 ;
1405   4                              //      SERIAL_RECEIVE_TIMEOUT = 6;
1406   4                              }
1407   3                      }       
1408   2              /*      else if( StartAdd ==  addressESS_PLUG_N_PLAY)
1409   2                      {
1410   2                              if(randval == RESPONSERANDVALUE)
1411   2                              {
1412   2                                      if(pData[HeadLen + 5] >=  MinAddr && pData[HeadLen + 5] <=  MaxAddr && pData[HeadLen + 5] != 0 && pDat
             -a[HeadLen + 5] != 255)
1413   2                                      {
1414   2                                              E2prom_Write_Byte( EEP_ADDRESS , pData[HeadLen + 5] ) ;
1415   2                                               address = pData[HeadLen + 5];  
1416   2                                              IntFlashWriteByte(0x70000 + DATA_TO_FIRMWARE + StartAdd - MODBUS_MINADDR,0);
1417   2                                      }
1418   2                              }
1419   2                      }*/     
1420   2                      else if(StartAdd == MODBUS_UNIT)
1421   2                      {
1422   3                               unit = pData[HeadLen + 5];;
1423   3                              E2prom_Write_Byte(EEP_UNIT, unit);
1424   3                      }
1425   2                      else if(StartAdd == MODBUS_DEMO_ENABLE)
1426   2                      {
1427   3                               demo_enable = pData[HeadLen + 5];;
1428   3                      //      E2prom_Write_Byte(EEP_UNIT, unit);
1429   3                      }       
1430   2                              
1431   2                      else if(StartAdd == MODBUS_TCP_TYPE)
1432   2                      {
1433   3                               TCP_TYPE = pData[HeadLen + 5]+ (pData[HeadLen + 4]<<8);
1434   3                              E2prom_Write_Byte(EEP_TCP_TYPE,  TCP_TYPE );
1435   3                      }
1436   2                      else if(StartAdd >= MODBUS_IP_1 && StartAdd <= MODBUS_IP_4)
1437   2                      {
1438   3                               IP_Addr[StartAdd - MODBUS_IP_1] = pData[HeadLen + 5];
1439   3                              E2prom_Write_Byte(EEP_IP + StartAdd - MODBUS_IP_1, IP_Addr[StartAdd - MODBUS_IP_1]);
1440   3                      }
1441   2                      else if(StartAdd >= MODBUS_SUBNET_1 && StartAdd <= MODBUS_SUBNET_4)
1442   2                      {
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 25  

1443   3                               SUBNET[StartAdd - MODBUS_SUBNET_1] = pData[HeadLen + 5];
1444   3                              E2prom_Write_Byte(EEP_SUBNET + StartAdd - MODBUS_SUBNET_1, SUBNET[StartAdd - MODBUS_SUBNET_1]);
1445   3                      }
1446   2                      else if(StartAdd >= MODBUS_GETWAY_1 && StartAdd <= MODBUS_GETWAY_4)
1447   2                      {
1448   3                               GETWAY[StartAdd - MODBUS_GETWAY_1] = pData[HeadLen + 5];
1449   3                      //      E2prom_Write_Byte(EEP_GETWAY + StartAdd - MODBUS_GETWAY_1, GETWAY[StartAdd - MODBUS_GETWAY_1]);
1450   3                      }
1451   2                      
1452   2                      else if(StartAdd >= MODBUS_AINPUT1 && StartAdd <= MODBUS_AINPUT10 )
1453   2                      {  // if auto/manual feature is Manual (0=auto, 1=manual)
1454   3                              if( AInputAM & (0x01 << (StartAdd - MODBUS_AINPUT1)))  // manual
1455   3                              {
1456   4                                       AI_Value[StartAdd - MODBUS_AINPUT1] = pData[HeadLen + 5]+ (U16_T)(pData[HeadLen + 4]<<8);
1457   4                              }
1458   3                      }
1459   2                      else if(StartAdd >= MODBUS_INPUT1_RANGE && StartAdd <= MODBUS_INPUT10_RANGE)
1460   2                      {
1461   3                              Input_Range[StartAdd - MODBUS_INPUT1_RANGE] = pData[HeadLen + 5]+ (U16_T)(pData[HeadLen + 4]<<8);
1462   3                              if( Input_Range[StartAdd - MODBUS_INPUT1_RANGE] > 5 ||  Input_Range[StartAdd - MODBUS_INPUT1_RANGE] < 0
             -)
1463   3                                       Input_Range[StartAdd - MODBUS_INPUT1_RANGE] = 0;
1464   3                              E2prom_Write_Byte(EEP_INPUT1_RANGE + StartAdd - MODBUS_INPUT1_RANGE, Input_Range[StartAdd - MODBUS_INPU
             -T1_RANGE]);
1465   3                      }
1466   2                      else if(StartAdd >= MODBUS_INPUT1_FILTER && StartAdd <= MODBUS_INPUT10_FILTER)
1467   2                      {
1468   3                               Input_Filter[StartAdd - MODBUS_INPUT1_FILTER] = pData[HeadLen + 5]+ (U16_T)(pData[HeadLen + 4]<<8);
1469   3                              E2prom_Write_Byte(EEP_INPUT1_FILTER + StartAdd - MODBUS_INPUT1_FILTER, Input_Filter[StartAdd - MODBUS_I
             -NPUT1_FILTER]);
1470   3                      }
1471   2                      else if(StartAdd >= MODBUS_INPUT1_CAL && StartAdd <= MODBUS_INPUT10_CAL)
1472   2                      {
1473   3                              Input_CAL[StartAdd - MODBUS_INPUT1_CAL] = pData[HeadLen + 5]+ (U16_T)(pData[HeadLen + 4]<<8);
1474   3                              E2prom_Write_Byte(EEP_INPUT1_CAL + StartAdd - MODBUS_INPUT1_CAL,pData[HeadLen + 5]);
1475   3                              E2prom_Write_Byte(EEP_INPUT1_CAL + StartAdd - MODBUS_INPUT1_CAL + 1,pData[HeadLen + 4]);
1476   3                      }
1477   2                      else if(StartAdd >= MODBUS_DI_TYPE1 && StartAdd <= MODBUS_DI_TYPE8)
1478   2                      {
1479   3                              DI_Type[StartAdd - MODBUS_DI_TYPE1] = pData[HeadLen + 5];
1480   3                              E2prom_Write_Byte(EEP_DI_TYPE1 + StartAdd - MODBUS_DI_TYPE1, DI_Type[StartAdd - MODBUS_DI_TYPE1]);
1481   3                      }
1482   2                      /* for test OUTPUT 1-8 */
1483   2                      else if(StartAdd == MODBUS_DI1)
1484   2                      {
1485   3                              U8_T loop;
1486   3                              U8_T temp1 = 0;
1487   3                              U8_T temp2 = 0;
1488   3                              U8_T temp3 = 0;
1489   3                              for(loop = 0;loop < 8;loop++)
1490   3                              {
1491   4                                      temp1 = pData[HeadLen + 5] & (0x01 << loop);
1492   4                                      temp2 = DInputAM & (0x01 << loop);
1493   4                                      temp3 |= (temp1 & temp2);
1494   4                                              
1495   4                              }
1496   3                              DI1_Value = temp3;              
1497   3                      }
1498   2                      else if(StartAdd == MODBUS_DI2)
1499   2                      {       
1500   3                              U8_T loop;
1501   3                              U8_T temp1 = 0;
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 26  

1502   3                              U8_T temp2 = 0;
1503   3                              U8_T temp3 = 0;
1504   3                              for(loop = 0;loop < 8;loop++)
1505   3                              {
1506   4                                      temp1 = pData[HeadLen + 5] & (0x01 << loop);
1507   4                                      temp2 = (DInputAM >> 8) & (0x01 << loop);
1508   4                                      temp3 |= (temp1 & temp2);
1509   4                                              
1510   4                              }
1511   3                              DI2_Value = temp3;
1512   3                      }
1513   2                      else if(StartAdd == MODBUS_DOUTPUT)
1514   2                      {  /* only manual type, it can be changed */
1515   3                              /*U8_T loop;
1516   3                              U16_T temp = pData[HeadLen + 5] + (U16_T)(pData[HeadLen + 4]<<8);
1517   3                              for(loop = 0;loop < 10;loop++)
1518   3                              {
1519   3                                      if(OuputAM & (0x01 << loop)) // manual
1520   3                                      {
1521   3                                              if(temp & (0x01 << loop))
1522   3                                              {
1523   3                                                      DO_Value |= (0x01 << loop);
1524   3                                              }
1525   3                                              else
1526   3                                              {
1527   3                                                      DO_Value &= ~(0x01 << loop);    
1528   3                                              }
1529   3                                      }
1530   3                              }*/
1531   3                              
1532   3                              DO_Value = (pData[HeadLen + 5] + (U16_T)(pData[HeadLen + 4]<<8)) & OuputAM;
1533   3                              E2prom_Write_Byte(EEP_OUTPUT_LOW,DO_Value);
1534   3                              E2prom_Write_Byte(EEP_OUTPUT_HIGH,DO_Value);
1535   3                      }               
1536   2                      else if(StartAdd == MODBUS_SWITCH )
1537   2                      {
1538   3                               DO_SoftSwitch = pData[HeadLen + 5] + (U16_T)(pData[HeadLen + 4]<<8);
1539   3                              if( DO_SoftSwitch >2)    DO_SoftSwitch = 0;
1540   3                              E2prom_Write_Byte(EEP_SWITCH, DO_SoftSwitch);
1541   3                      }
1542   2                      else if(StartAdd == MODBUS_PRIORTITY )
1543   2                      {
1544   3                               Priority = pData[HeadLen + 5] + (U16_T)(pData[HeadLen + 4]<<8);
1545   3                               E2prom_Write_Byte(EEP_PRIORTITY, Priority);
1546   3                               count_priority = 0;
1547   3                      }
1548   2                      else if(StartAdd == MODBUS_DI_ENABLE)
1549   2                      {
1550   3                               DI_Enable = pData[HeadLen + 5] + (U16_T)(pData[HeadLen + 4]<<8);
1551   3                              E2prom_Write_Byte(EEP_DI_ENABLE_LOW,pData[HeadLen + 5]);
1552   3                              E2prom_Write_Byte(EEP_DI_ENABLE_HIGH,pData[HeadLen + 4]);
1553   3                      }
1554   2                      else if(StartAdd == MODBUS_AI_ENABLE)
1555   2                      {
1556   3                               AI_Enable = pData[HeadLen + 5] + (U16_T)(pData[HeadLen + 4]<<8);
1557   3                              E2prom_Write_Byte(EEP_AI_ENABLE_LOW,pData[HeadLen + 5]);
1558   3                              E2prom_Write_Byte(EEP_AI_ENABLE_HIGH,pData[HeadLen + 4]);
1559   3                      }
1560   2                      else if(StartAdd == MODBUS_DINPUT_AM)
1561   2                      {
1562   3                              DInputAM = pData[HeadLen + 5] + (U16_T)(pData[HeadLen + 4]<<8);
1563   3                              E2prom_Write_Byte(EEP_DINPUT_AM_LOW,pData[HeadLen + 5]);
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 27  

1564   3                              E2prom_Write_Byte(EEP_DINPUT_AM_HIGH,pData[HeadLen + 4]);
1565   3                      }
1566   2                      else if(StartAdd == MODBUS_OUTPUT_AM)
1567   2                      { 
1568   3                               OuputAM = pData[HeadLen + 5] + (U16_T)(pData[HeadLen + 4]<<8);
1569   3                               E2prom_Write_Byte(EEP_OUTPUT_AM_LOW,pData[HeadLen + 5]);
1570   3                               E2prom_Write_Byte(EEP_OUTPUT_AM_HIGH,pData[HeadLen + 4]);
1571   3                      }
1572   2                      else if(StartAdd == MODBUS_AINPUT_AM)
1573   2                      {
1574   3                               AInputAM = pData[HeadLen + 5] + (U16_T)(pData[HeadLen + 4]<<8);
1575   3                              E2prom_Write_Byte(EEP_AINPUT_AM_LOW,pData[HeadLen + 5]);
1576   3                              E2prom_Write_Byte(EEP_AINPUT_AM_HIGH,pData[HeadLen + 4]);
1577   3                      }
1578   2              /*      else if(StartAdd == MODBUS_MASTER )
1579   2                      {
1580   2                               Master = pData[HeadLen + 5];+ (U16_T)(pData[HeadLen + 4]<<8);
1581   2                              E2prom_Write_Byte(EEP_MASTER, Master);
1582   2                      }*/
1583   2                      else if(StartAdd >= MODBUS_TIMER_ADDRESS && StartAdd <= MODBUS_TIMER_ADDRESS + 7)
1584   2                      {
1585   3                               RTC.all[StartAdd - MODBUS_TIMER_ADDRESS] = pData[HeadLen + 5]+ (U16_T)(pData[HeadLen + 4]<<8);
1586   3                      //      E2prom_Write_Byte(EEP_SEC + StartAdd - MODBUS_SEC, Time.all[StartAdd - MODBUS_SEC]);
1587   3                              Set_Clock(PCF_SEC + 7 - StartAdd + MODBUS_TIMER_ADDRESS, RTC.all[StartAdd - MODBUS_TIMER_ADDRESS]);
1588   3                      }
1589   2                      else if(StartAdd == MODBUS_DISPLAY_TEMP_NUM)
1590   2                      {
1591   3                              dis_temp_num = pData[HeadLen + 5];
1592   3                              E2prom_Write_Byte(EEP_DIS_TEMP_NUM,pData[HeadLen + 5]);
1593   3                      }
1594   2                      else if(StartAdd == MODBUS_DISPLAY_TMEP_INTERVAL)
1595   2                      {
1596   3                              dis_temp_interval = pData[HeadLen + 5];
1597   3                              E2prom_Write_Byte(EEP_DIS_TEMP_INTERVAL,pData[HeadLen + 5]);
1598   3                      }       
1599   2                      else if(StartAdd >= MODBUS_DISPLAY_TEMP_SEQ_FIRST && StartAdd <= MODBUS_DISPLAY_TEMP_SEQ_FIRST + 9)
1600   2                      {
1601   3                              dis_temp_seq[StartAdd - MODBUS_DISPLAY_TEMP_SEQ_FIRST] = pData[HeadLen + 5];
1602   3                              E2prom_Write_Byte(EEP_DIS_TEMP_SEQ_FIRST + StartAdd - MODBUS_DISPLAY_TEMP_SEQ_FIRST,pData[HeadLen + 5])
             -;
1603   3                      }
1604   2      
1605   2              }
1606   1              else if(cmd == MULTIPLE_WRITE)
1607   1              {
1608   2                      if(type == MODBUS)   // TBD: need change
1609   2                      {       
1610   3                              main_init_send_com();
1611   3                              // --- response to a multiple write function ---
1612   3                              // the 6 first bits are the same and then send the crc bits
1613   3                              for (loop = 0; loop < 6; loop++)
1614   3                                      main_send_byte(pData[loop],CRC_NO);     
1615   3                              main_send_byte(MainCRChi,CRC_YES); //send the two last CRC bits
1616   3                              main_send_byte(MainCRClo,CRC_YES);
1617   3                      }
1618   2                      else
1619   2                      {
1620   3                      //      SetTransactionId(6 + UIP_HEAD);
1621   3                      
1622   3                              sendbuf[0] = pData[0];                  //      TransID
1623   3                              sendbuf[1] = pData[1];  
1624   3                              sendbuf[2] = 0;                 //      ProtoID
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 28  

1625   3                              sendbuf[3] = 0;
1626   3                              sendbuf[4] = (3 + UIP_HEAD) >> 8;       //      Len
1627   3                              sendbuf[5] = (U8_T)(3 + UIP_HEAD) ;
1628   3      
1629   3                              for (loop = 0;loop < 6;loop++)
1630   3                              {
1631   4                                      sendbuf[HeadLen + loop] = pData[HeadLen + loop];        
1632   4                              }
1633   3                              TCPIP_TcpSend(pHttpConn->TcpSocket, sendbuf, 6 + UIP_HEAD, TCPIP_SEND_NOT_FINAL);  
1634   3                      }
1635   2      
1636   2                      // the following are schedule registers 
1637   2                      ChangeFlash = 1;
1638   2                      if(StartAdd == MODBUS_TIMER_ADDRESS)
1639   2                      {
1640   3                              if(pData[HeadLen + 5] == 0x08)
1641   3                              {
1642   4                                      if(pData[HeadLen + 5] == pData[HeadLen + 6])
1643   4                                      {
1644   5                                              Set_Clock(PCF_SEC,pData[HeadLen + 14]);  // sec
1645   5                                              Set_Clock(PCF_MIN,pData[HeadLen + 13]);  // min
1646   5                                              Set_Clock(PCF_HOUR,pData[HeadLen + 12]); // hour
1647   5                                              Set_Clock(PCF_DAY,pData[HeadLen + 11]);  // day 
1648   5                                              Set_Clock(PCF_WEEK,pData[HeadLen + 10]); // week
1649   5                                              if(pData[HeadLen + 7] |= 0x80)
1650   5                                                      pData[HeadLen + 9]|=0x80;
1651   5                                              else                                                                       
1652   5                                                      pData[HeadLen + 9]&=0x7f;       
1653   5                                              Set_Clock(PCF_MON,pData[HeadLen + 9]);   // month
1654   5                                              Set_Clock(PCF_YEAR,pData[HeadLen + 8]); // year
1655   5                                      }
1656   4                                      else
1657   4                                      {
1658   5                                              Set_Clock(PCF_SEC,pData[HeadLen + 22]);  // sec
1659   5                                              Set_Clock(PCF_MIN,pData[HeadLen + 20]);  // min
1660   5                                              Set_Clock(PCF_HOUR,pData[HeadLen + 18]); // hour
1661   5                                              Set_Clock(PCF_DAY,pData[HeadLen + 16]);  // day 
1662   5                                              Set_Clock(PCF_WEEK,pData[HeadLen + 14]); // week
1663   5                                              if(pData[HeadLen + 8] |= 0x80)
1664   5                                                      pData[HeadLen + 12]|=0x80;
1665   5                                              else
1666   5                                                      pData[HeadLen + 12]&=0x7f;      
1667   5                                              Set_Clock(PCF_MON,pData[HeadLen + 12]);                 // month
1668   5                                              Set_Clock(PCF_YEAR,pData[HeadLen + 10]);                // year
1669   5                                      }
1670   4                                      calibrated_time = 1;
1671   4                               
1672   4                               }
1673   3                       }
1674   2                       if(StartAdd < MODBUS_WR_DESCRIP_LAST && StartAdd >= MODBUS_WR_DESCRIP_FIRST)
1675   2                       {
1676   3                              if((StartAdd - MODBUS_WR_DESCRIP_FIRST) % WR_DESCRIPTION_SIZE == 0)
1677   3                              {
1678   4                                      U8_T i;
1679   4                                      i = (StartAdd - MODBUS_WR_DESCRIP_FIRST) / WR_DESCRIPTION_SIZE;
1680   4                                      
1681   4                                      memcpy(WR_Roution[i].UN.all,&pData[HeadLen + 7],WR_DESCRIPTION_SIZE);
1682   4                      
1683   4                              }
1684   3                       }
1685   2                       else if(StartAdd < MODBUS_AR_DESCRIP_LAST && StartAdd >= MODBUS_AR_DESCRIP_FIRST)
1686   2                       {
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 29  

1687   3                              if((StartAdd - MODBUS_AR_DESCRIP_FIRST) % AR_DESCRIPTION_SIZE == 0)
1688   3                              {
1689   4                                      U8_T i;
1690   4                                      i = (StartAdd - MODBUS_AR_DESCRIP_FIRST) / AR_DESCRIPTION_SIZE;
1691   4                       
1692   4                                      memcpy(AR_Roution[i].UN.all,&pData[HeadLen + 7],AR_DESCRIPTION_SIZE);
1693   4                              
1694   4                              }
1695   3                       }
1696   2                       else if(StartAdd < MODBUS_ID_LAST && StartAdd >= MODBUS_ID_FIRST)
1697   2                       {
1698   3                              if((StartAdd - MODBUS_ID_FIRST) % ID_SIZE == 0)
1699   3                              {
1700   4                                      U8_T i;
1701   4                                      i = (StartAdd - MODBUS_ID_FIRST) / ID_SIZE;
1702   4                      
1703   4                                      memcpy(ID_Config[i].all,&pData[HeadLen + 7],ID_SIZE);
1704   4                      
1705   4                              }
1706   3                       }
1707   2                       else if(StartAdd < MODBUS_AR_TIME_LAST && StartAdd >= MODBUS_AR_TIME_FIRST)
1708   2                       {
1709   3                              if((StartAdd - MODBUS_AR_TIME_FIRST)%AR_TIME_SIZE == 0)
1710   3                              {
1711   4                                      U8_T i;
1712   4                                      i = (StartAdd - MODBUS_AR_TIME_FIRST) / AR_TIME_SIZE;
1713   4                      
1714   4                                      memcpy(AR_Roution[i].Time,&pData[HeadLen + 7],AR_TIME_SIZE);                    }
1715   3                       }
1716   2                       else if(StartAdd < MODBUS_WR_ONTIME_LAST && StartAdd >= MODBUS_WR_ONTIME_FIRST)
1717   2                       {
1718   3                              if((StartAdd - MODBUS_WR_ONTIME_FIRST) % WR_TIME_SIZE == 0)
1719   3                              {
1720   4                                      U8_T i;
1721   4                                      i = (StartAdd - MODBUS_WR_ONTIME_FIRST) / WR_TIME_SIZE;
1722   4                      
1723   4                                      memcpy(WR_Roution[i].OnTime,&pData[HeadLen + 7],WR_TIME_SIZE);
1724   4                              }
1725   3                       }
1726   2                       else if(StartAdd < MODBUS_WR_OFFTIME_LAST && StartAdd >= MODBUS_WR_OFFTIME_FIRST)
1727   2                       {
1728   3                              if((StartAdd-MODBUS_WR_OFFTIME_FIRST) % WR_TIME_SIZE == 0)
1729   3                              {
1730   4                                      U8_T i;
1731   4                                      i = (StartAdd - MODBUS_WR_OFFTIME_FIRST) / WR_TIME_SIZE;
1732   4                      
1733   4                                      memcpy(WR_Roution[i].OffTime,&pData[HeadLen + 7],WR_TIME_SIZE);          
1734   4                              }
1735   3                       }
1736   2      
1737   2                       else if(StartAdd < MODBUS_NAME_LAST && StartAdd >= MODBUS_NAME_FIRST)
1738   2                       {
1739   3                              if((StartAdd - MODBUS_NAME_FIRST) % (NAME_SIZE / 2) == 0)
1740   3                              {
1741   4                                      U8_T i;
1742   4                                      i = (StartAdd - MODBUS_NAME_FIRST) / (NAME_SIZE / 2);
1743   4              
1744   4                                      memcpy(menu_name[i],&pData[HeadLen + 7],NAME_SIZE);     
1745   4                              //      if(i == MAX_NAME - 1)     // write flash after receive the last name
1746   4                              //              ChangeFlash = 1;                        
1747   4                              }
1748   3                       }
C51 COMPILER V9.00   SERIALNEW                                                             05/08/2013 16:47:34 PAGE 30  

1749   2                      
1750   2      
1751   2              }
1752   1              else if(cmd == CHECKONLINE)
1753   1              {
1754   2                      if(type == MODBUS)
1755   2                      {
1756   3                              main_init_send_com();
1757   3                              main_send_byte(main_data_buffer[0],CRC_NO);
1758   3                              main_send_byte(main_data_buffer[1],CRC_NO);
1759   3                              main_send_byte( Modbus_address,CRC_NO);                         // send address of device       
1760   3              
1761   3                              main_send_byte( serialNum[0],CRC_NO);
1762   3                              main_send_byte( serialNum[1],CRC_NO);
1763   3                              main_send_byte( serialNum[2],CRC_NO);
1764   3                              main_send_byte( serialNum[3],CRC_NO);   
1765   3              
1766   3                              main_send_byte(MainCRChi,CRC_YES);              // send the two last CRC bits
1767   3                              main_send_byte(MainCRClo,CRC_YES);
1768   3                      }
1769   2                      else
1770   2                      {
1771   3                              
1772   3                      }
1773   2              }
1774   1      }
*** WARNING C280 IN LINE 720 OF MODBUS\SERIALNEW.C: 'temp': unreferenced local variable
*** WARNING C280 IN LINE 721 OF MODBUS\SERIALNEW.C: 'tempbit': unreferenced local variable
*** WARNING C280 IN LINE 725 OF MODBUS\SERIALNEW.C: 'tempbuf': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  19978    ----
   CONSTANT SIZE    =    527    ----
   XDATA SIZE       =    386      46
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   1084    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)
