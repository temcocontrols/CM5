C51 COMPILER V9.00   TCPIP                                                                 05/18/2012 10:38:00 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE TCPIP
OBJECT MODULE PLACED IN .\Build\tcpip.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main\tcpip.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\Fr
                    -eeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\SRC\UAR
                    -T\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;..\SRC
                    -\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management\;..\S
                    -RC\dhcp\;..\SRC\pppoe\;..\SRC\MINI_262\;..\SRC\flash;..\SRC\SNTP) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\tc
                    -pip.lst) OBJECT(.\Build\tcpip.obj)

line level    source

   1          #include "main.h"
   2          
   3          #define INCLUDE_DNS_CLIENT  0
   4          #define INCLUDE_DHCP_CLIENT 1
   5          
   6          #if (INCLUDE_DHCP_CLIENT)
   7            #include "dhcpc.h"
   8          #endif
   9          #if (INCLUDE_DNS_CLIENT)
                #include "dnsctab.h"
              
              #endif
  13          
  14          /* NAMING CONSTANT DECLARATIONS */
  15          #ifdef DEBUG
              #define DBGMSG(A) {A}
              #else
  18          #define DBGMSG(A) {}
  19          #endif
  20          
  21          
  22          
  23          
  24          
  25          typedef struct app_buf {
  26                  U32_T   ipaddr;
  27                  U8_T    buf[100];
  28                  U16_T   uip_len;
  29                  U16_T   PayLoadOffset;
  30                  U8_T    wait;
  31          }APP_BUF;
  32          
  33          APP_BUF XDATA app_arp_buf;
  34          
  35          #define TIME_OUT_COUNTER        (250/SWTIMER_INTERVAL)  //250
  36          static U16_T ServerBroadcastListenPort;
  37          /*
  38           * ----------------------------------------------------------------------------
  39           * Function Name: UpdateIpSettings
  40           * Purpose: Update IP address, subnet mak, gateway IP address and DNS IP address 
  41           * Params:
  42           * Returns:
  43           * Note:
  44           * ----------------------------------------------------------------------------
  45           */
  46          void UpdateIpSettings(U32_T ip)
  47          {
  48   1               U32_T gateWay,subnet;
  49   1      
  50   1               if(ip > 0)
C51 COMPILER V9.00   TCPIP                                                                 05/18/2012 10:38:00 PAGE 2   

  51   1               {
  52   2                      ip = STOE_GetIPAddr();
  53   2                      subnet = STOE_GetSubnetMask();
  54   2                      gateWay = STOE_GetGateway();
  55   2              
  56   2                      Modbus.IP[3] = (U8_T)(ip>>24);          
  57   2                      Modbus.IP[2] = (U8_T)(ip>>16);          
  58   2                      Modbus.IP[1] = (U8_T)(ip>>8);           
  59   2                      Modbus.IP[0] = (U8_T)(ip);
  60   2              
  61   2                      Modbus.SUBNET[3] = (U8_T)(subnet>>24);
  62   2                      Modbus.SUBNET[2] = (U8_T)(subnet>>16);
  63   2                      Modbus.SUBNET[1] = (U8_T)(subnet>>8);
  64   2                      Modbus.SUBNET[0] = (U8_T)(subnet);
  65   2              
  66   2                      Modbus.GETWAY[3] = (U8_T)(gateWay>>24);
  67   2                      Modbus.GETWAY[2] = (U8_T)(gateWay>>16);
  68   2                      Modbus.GETWAY[1] = (U8_T)(gateWay>>8);
  69   2                      Modbus.GETWAY[0] = (U8_T)(gateWay);             
  70   2              }
  71   1              else
  72   1              {
  73   2                      ip = (((U32_T)Modbus.IP[3]) << 24) | ((U32_T)Modbus.IP[2] << 16) | ((U32_T)Modbus.IP[1] << 8) | (Modbus.
             -IP[0]);
  74   2                      subnet = (((U32_T)Modbus.SUBNET[3]) << 24) | ((U32_T)Modbus.SUBNET[2] << 16) | ((U32_T)Modbus.SUBNET[1] 
             -<< 8) | (Modbus.SUBNET[0]);
  75   2                      gateWay = (((U32_T)Modbus.GETWAY[3]) << 24) | ((U32_T)Modbus.GETWAY[2] << 16) | ((U32_T)Modbus.GETWAY[1]
             - << 8) | (Modbus.GETWAY[0]);
  76   2                      
  77   2                      TCPIP_SetIPAddr(ip); 
  78   2                      TCPIP_SetSubnetMask(subnet);
  79   2                      TCPIP_SetGateway(gateWay);
  80   2                              
  81   2                      STOE_SetIPAddr(ip); 
  82   2                  STOE_SetSubnetMask(subnet);
  83   2                      STOE_SetGateway(gateWay);
  84   2              
  85   2              //      GCONFIG_SetServerDynamicIP(ip);                                         
  86   2              //      GCONFIG_WriteConfigData();
  87   2              //      GUDPBC_Init(ServerBroadcastListenPort);
  88   2              } 
  89   1      
  90   1      } /* End of UpdateIpSettings */
  91          
  92          /*
  93           * ----------------------------------------------------------------------------
  94           * Function Name: CheckArpTable
  95           * Purpose: Update IP address, subnet mak, gateway IP address and DNS IP address 
  96           * Params:
  97           * Returns:
  98           * Note:
  99           * ----------------------------------------------------------------------------
 100           */
 101          void CheckArpTable(void)
 102          {
 103   1              if (app_arp_buf.wait) 
 104   1              {
 105   2                      U8_T valid = STOE_CHECK_MAC(&app_arp_buf.ipaddr);
 106   2                      if (valid) 
 107   2                      {
 108   3                              DMA_GrantXdata(uip_buf, app_arp_buf.buf, app_arp_buf.uip_len);
 109   3                      //      PRINTD(DEBUG_MSG ,("send out the packet from arp buffer\n\r"));
C51 COMPILER V9.00   TCPIP                                                                 05/18/2012 10:38:00 PAGE 3   

 110   3                              uip_len = app_arp_buf.uip_len;
 111   3                              ETH_Send(app_arp_buf.PayLoadOffset);
 112   3                              uip_len = 0;
 113   3                              app_arp_buf.wait = 0;
 114   3                      }
 115   2              }
 116   1      } /* End of CheckArpTable */
 117          
 118          
 119          
 120          void TCPIP_Task(void)reentrant
 121          {
 122   1         //U32_T far iP,gateWay,subnet;
 123   1         portTickType xDelayPeriod  = ( portTickType ) 250 / portTICK_RATE_MS;//2 minutes writting flash.
 124   1              
 125   1      
 126   1       #if (BOOTLDR_ISR)
                      ERROR: BOOTLDR_ISR must set to '0' in non-bootloader driver.
                 #endif
 129   1         #if (!AX_ETH_INT_ENABLE)
                       ERROR: Must enable ethernet module in this driver.
                 #endif
 132   1               U32_T  timeCount,preTimeCount;
 133   1         #if (INCLUDE_DHCP_CLIENT)
 134   1              U8_T    cmdDhcpFlag = 0;
 135   1              U32_T   dhcpTimeStart = 0;
 136   1              U32_T   dhcpTimeStop = 0;
 137   1      #endif
 138   1      #if STOE_TRANSPARENT
 139   1      //      U8_T xdata arptimer;
 140   1      #endif
 141   1      
 142   1      //   U8_T WhichServer;
 143   1      
 144   1              /* Initialize Network adapter */
 145   1              ETH_Init();
 146   1      
 147   1              DHCP_Init();
 148   1              //if (DHCP_Init())
 149   1              //      printd("DHCP init ok.\n\r");
 150   1      
 151   1      #if (INCLUDE_DNS_CLIENT)
                      DNSCTAB_Init(); /* include DNS table */
              #endif
 154   1      
 155   1      
 156   1      #if GCONFIG_EEPROM_CONFIG
                      I2C_Init();
              #endif
 159   1              GCONFIG_Init();
 160   1      
 161   1      //      ServerBroadcastListenPort = GCONFIG_GetServerBroadcastListenPort();
 162   1      //      printd ("ServerBroadcastListenPort = %d\n\r", ServerBroadcastListenPort);
 163   1      //      ServerBroadcastListenPort = 25122;
 164   1      //      GUDPBC_Init(ServerBroadcastListenPort);
 165   1      
 166   1      #if (INCLUDE_DHCP_CLIENT)       
 167   1              if ( Modbus.TCP_TYPE == DHCP && ((GCONFIG_GetNetwork() & GCONFIG_NETWORK_DHCP_ENABLE) == GCONFIG_NETWORK_
             -DHCP_ENABLE) )
 168   1              {
 169   2              //      printd("DHCP request... ");
 170   2                      DHCP_Start();
C51 COMPILER V9.00   TCPIP                                                                 05/18/2012 10:38:00 PAGE 4   

 171   2      #if (!STOE_TRANSPARENT)
                              STOE_DisableIpFilter();
              #endif
 174   2                      cmdDhcpFlag = 1;
 175   2                      dhcpTimeStart = SWTIMER_Tick();
 176   2              }
 177   1              else
 178   1              {
 179   2                      UpdateIpSettings(0);
 180   2              }
 181   1      #else
              //      printd("DHCP module is not included. Use static IP address\n\r");
                      GCONFIG_SetServerDynamicIP(GCONFIG_GetServerStaticIP());                                                
                      GCONFIG_WriteConfigData();
                      GUDPBC_Init(ServerBroadcastListenPort);
              #endif
 187   1      
 188   1              ServerBroadcastListenPort = 1234; 
 189   1              GUDPBC_Init(ServerBroadcastListenPort);
 190   1      
 191   1              HTTP_Init();
 192   1      //      FSYS_Init();
 193   1      
 194   1      //      SNTPC_Init();
 195   1              
 196   1              ETH_Start();
 197   1      
 198   1      //      WhichServer=Para[45]; //customer choose which server fro Sync.
 199   1      //      SNTPC_Start(800, IpServer[WhichServer]);
 200   1      //      should add condition if whichserver exceeds 6
 201   1      
 202   1              while (1)
 203   1              {
 204   2      //              HSUR_ErrorRecovery(); 
 205   2        
 206   2      
 207   2      #if (!STOE_TRANSPARENT)
                              ETH_SendArpToGateway(ETH_CONTINUE_ARP_REQUEST_TO_GATEWAY_AFTER_REPLY);
              #endif
 210   2      
 211   2                      CheckArpTable();
 212   2      
 213   2      #if (INCLUDE_DHCP_CLIENT)
 214   2                      if (cmdDhcpFlag == 1)
 215   2                      {                       
 216   3                              if (DHCP_GetState() > DHCP_IDLE_STATE)
 217   3                              {
 218   4                                      DHCP_Send();
 219   4                              }
 220   3                              else
 221   3                              {
 222   4                                      UpdateIpSettings(STOE_GetIPAddr());
 223   4      #if (!STOE_TRANSPARENT)
                                              STOE_EnableIpFilter();
              #endif
 226   4                                      cmdDhcpFlag = 0;
 227   4                              }
 228   3                      }
 229   2      #endif
 230   2      
 231   2      #if (STOE_GET_INTSTATUS_MODE == STOE_INTERRUPT_MODE)    /* interrupt mode */
                              if (STOE_GetInterruptFlag())
C51 COMPILER V9.00   TCPIP                                                                 05/18/2012 10:38:00 PAGE 5   

                              {
                                      STOE_ProcessInterrupt();
                              }
              #else   /* polling mode */
 237   2                      STOE_ProcessInterrupt();
 238   2      #endif
 239   2      
 240   2      #if (!MAC_GET_INTSTATUS_MODE)
 241   2                      if (MAC_GetInterruptFlag())
 242   2                      {
 243   3                              MAC_ProcessInterrupt();
 244   3                      }
 245   2      #else
                              MAC_LinkSpeedChk();
              #endif
 248   2      
 249   2                      timeCount = (U16_T)SWTIMER_Tick();
 250   2                      if ((timeCount- preTimeCount)>= TIME_OUT_COUNTER)
 251   2                      {
 252   3                              preTimeCount = timeCount;
 253   3                              TCPIP_PeriodicCheck();
 254   3                      }
 255   2              //      vTaskDelay(xDelayPeriod);
 256   2                      
 257   2             timeCount = (U16_T)SWTIMER_Tick();
 258   2                 #if 0    // dont understand it 
                     if(Para[43]==2)
                         {
                                SNTPC_GetState();Para[43]=1;
                     }
                      #endif
 264   2            //  SNTPC_Debug();
 265   2      
 266   2      #if (INCLUDE_DNS_CLIENT)
                              if (cmdDnsFlag == 1)
                              {
                                      U8_T state = DNSCTAB_GetState();/* include DNS table */
              
                                      if (state == DNSC_STATE_FREE)
                                      {
                                              cmdDnsFlag = 0;
                                              //printf ("Can not find DNS server.\n\r");
                                      }
                                      else if (state == DNSC_STATE_RESPONSED)
                                      {
                                              U32_T   ip;
              
                                              cmdDnsFlag = 0;
              
                                              if ((ip = DNSCTAB_GetIP()) == 0)
                                              {
                                              //      printf ("Can not find remote station via DNS server.\n\r");
                                              }
                                              else
                                              {
                                              //      printf ("Get IP address from DNS server : %lx\n\r", ip);
                                              }
                                      }
                              }
              #endif
 293   2      
 294   2              }
C51 COMPILER V9.00   TCPIP                                                                 05/18/2012 10:38:00 PAGE 6   

 295   1      } /* End of main() */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1448    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    111      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
