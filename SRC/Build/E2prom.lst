C51 COMPILER V9.00   E2PROM                                                                05/08/2013 16:47:35 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE E2PROM
OBJECT MODULE PLACED IN .\Build\E2prom.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE I2C\E2prom.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\Fr
                    -eeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\SRC\UAR
                    -T\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;..\SRC
                    -\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management\;..\S
                    -RC\dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule;..\SRC\program;..\SRC\Scan) DE
                    -FINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\E2prom.lst) OBJECT(.\Build\E2prom.obj)

line level    source

   1          #include "e2prom.h"
   2          #include "ax11000.h"
   3          //  -------------
   4          //  note:       
   5          //      1. every time use new chip, should initial e2prom using WINDOWS ISP 
   6          //      2. make sure the I2C interrupt vector is turned on.
   7          //  -------------
   8          
   9          
  10          #if 1
  11          
  12          I2C_BUF  Read_Data;
  13          static U16_T    ADDROFDEV = 0x50;
  14          static U16_T    delay_count = 1500;
  15          /*
  16          the following array is for AX11015 configure, about the detail please refer to the datatsheet (user_guide)
             -.
  17          different product must change them according to its requiremnt.
  18          
  19          
  20          I2C Configuration EEPROM Memory Map
  21          
  22          EEPROM Offset Descriptor
  23          0x00            Length
  24          0x01            Flag
  25          0x03~0x02       Multi-function Pin Setting 1 Multi-function Pin Setting 0
  26          0x04            Programmable Output Driving Strength
  27          0x05 Reserved = 0x00
  28          0x0B~0x06       Node ID 5 Node ID 4 Node ID 3 Node ID 2 Node ID 1 Node ID 0 (0x06)
  29          0x0D~0x0C       Maximum Packet Size 1 Maximum Packet Size 0 (0x0C)
  30          0x0F~0x0E       Secondary PHY Type and PHY ID Primary PHY Type and PHY ID (0x0E)
  31          0x11~0x10       Pause Frame Low Water Mark Pause Frame High Water Mark (0x10)
  32          0x13~0x12       Local Bus Setting 1 Local Bus Setting 0 (0x12)
  33          0x15~0x14       TOE TX VLAN Tag 1 TOE TX VLAN Tag 0 (0x14)
  34          0x17~0x16       TOE RX VLAN Tag 1 TOE RX VLAN Tag 0 (0x16)
  35          0x18            TOE ARP Cache Timeout
  36          0x1C~0x19       TOE Source IP Address ( 0x03 0x00 0xa8 0xc0)
  37          0x20~0x1D   TOE Subnet Mask 3 TOE Subnet Mask 2 TOE Subnet Mask 1 TOE Subnet Mask 0     (0x1D)
  38          0x21            TOE L4 DMA Transfer Gap
  39          0x2F~0x22       Reserved for HW future use
  40          0x7F~0x30       Reserved for Software and Driver Settings
  41          */
  42          const U8_T CPU_Config[40] = 
  43          {
  44                  0x21,0x3c,0x00,0x30,0x30,0x00,0x01,0x00,
  45                  0x00,0x00,0x00,0x00,0xf2,0x05,0x10,0xe0,
  46                  0x1d,0x19,0x87,0x00,0xff,0xff,0xff,0xff,
  47                  0x10,0x03,0x00,0xa8,0xc0,0x00,0xff,0xff,
  48                  0xff,0x04,0xff,0xff,0xff,0xff,0xff,0xff
  49          };
C51 COMPILER V9.00   E2PROM                                                                05/08/2013 16:47:35 PAGE 2   

  50          
  51          
  52          void E2prom_Initial(void)
  53          {
  54   1              U16_T   i2cpreclk = 0;
  55   1              U8_T    sysclk = 0;
  56   1              U32_T   Sysclk;
  57   1              sysclk = AX11000_GetSysClk();
  58   1              switch (sysclk)
  59   1              {
  60   2                      case SYS_CLK_100M :
  61   2                              Sysclk = 100000000;
  62   2                              i2cpreclk = I2C_STD_100M;
  63   2                              break;
  64   2                      case SYS_CLK_50M :
  65   2                              Sysclk = 50000000;
  66   2                              i2cpreclk = I2C_STD_50M;
  67   2                              break;
  68   2                      case SYS_CLK_25M :
  69   2                              Sysclk = 25000000;
  70   2                              i2cpreclk = I2C_STD_25M;
  71   2                              break;
  72   2              }
  73   1              I2C_Setup(I2C_ENB|I2C_STANDARD|I2C_MST_IE|I2C_7BIT|I2C_MASTER_MODE, i2cpreclk, 0x005A);
  74   1      //      E2prom_Erase();
  75   1      }
  76          
  77          
  78          
  79          U8_T E2prom_Read_Byte(U8_T addr,U8_T *value)
  80          {
  81   1              I2C_RdmRead(ADDROFDEV, addr, &Read_Data, 1, I2C_STOP_COND);
  82   1              *value = Read_Data.I2cData[0];
  83   1              return 1;
  84   1      }
  85          
  86          
  87          U8_T E2prom_Read_Int(U8_T addr,U16_T *value)
  88          {
  89   1      //      U8_T temp,temp1;
  90   1      //      E2prom_Read_Byte(addr,&temp);
  91   1      //      E2prom_Read_Byte(addr + 1,&temp1);
  92   1      //      *value = temp + temp1 * 256;
  93   1              I2C_RdmRead(ADDROFDEV, addr, &Read_Data, 2, I2C_STOP_COND);
  94   1              *value = Read_Data.I2cData[0];
  95   1                                 
  96   1              return 1;
  97   1      }
  98          
  99          
 100          U8_T E2prom_Write_Byte(U8_T addr,U8_T dat)
 101          {
 102   1              U8_T result;
 103   1              U16_T   i;
 104   1              result = I2C_ByteWrite(ADDROFDEV, addr, dat, I2C_STOP_COND);
 105   1              for(i = 0; i < delay_count; i++)                        _nop_ ();
 106   1              return result;
 107   1      }
 108          
 109          
 110          U8_T E2prom_Write_Int(U8_T addr,U16_T dat)
 111          {       
C51 COMPILER V9.00   E2PROM                                                                05/08/2013 16:47:35 PAGE 3   

 112   1              U16_T   i;
 113   1              U8_T temp;
 114   1              temp = (U8_T)dat;   // first low byte
 115   1              I2C_ByteWrite(ADDROFDEV, addr, temp, I2C_STOP_COND);    
 116   1              for(i = 0; i < delay_count; i++)                        _nop_ ();
 117   1              temp = dat >> 8;
 118   1              I2C_ByteWrite(ADDROFDEV, addr + 1, temp, I2C_STOP_COND);        
 119   1              for(i = 0; i < delay_count; i++)                        _nop_ ();
 120   1              return 1;
 121   1      }
 122          
 123          // erase e2prom
 124          U8_T E2prom_Erase(void)
 125          {
 126   1              U8_T result;
 127   1              U16_T j,i;
 128   1              for(j = 0; j < 208; j++) 
 129   1              {
 130   2                      result = I2C_ByteWrite(ADDROFDEV, USER_BASE_ADDR + j, 0xFF, I2C_STOP_COND);
 131   2                      if(!result)     return result;
 132   2                      for(i = 0; i < delay_count; i++)        _nop_ ();
 133   2              }
 134   1      
 135   1      
 136   1              return result;
 137   1      }
 138          
 139          
 140          /* 
 141          implement it when programming it or change it by hand
 142          */
 143          void Eeprom_Write_Cpu_Config(void)
 144          {
 145   1              U8_T loop;
 146   1              E2prom_Erase();
 147   1              for(loop = 0;loop < 40;loop++)
 148   1              {
 149   2                      I2C_ByteWrite(ADDROFDEV, loop, CPU_Config[loop], I2C_STOP_COND);
 150   2              }
 151   1      }
 152          #endif
 153          
 154          
 155          
 156          
 157          
 158          
 159          
 160          
 161          
 162          
 163          
 164          
 165          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    648    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    114      20
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.00   E2PROM                                                                05/08/2013 16:47:35 PAGE 4   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
