C51 COMPILER V9.00   RANGE                                                                 02/28/2013 15:46:45 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE RANGE
OBJECT MODULE PLACED IN .\Build\range.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Modbus\range.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\
                    -FreeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\SRC\U
                    -ART\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;..\S
                    -RC\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management\;..
                    -\SRC\dhcp\;..\SRC\pppoe\;..\SRC\MINI_262\;..\SRC\flash;..\SRC\SNTP) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\
                    -range.lst) OBJECT(.\Build\range.obj)

line level    source

   1          #include "define.h"
*** WARNING C318 IN LINE 6 OF MODBUS\DEFINE.H: can't open file 'schedule.h'
   2           
   3          #if 1
   4          bit pic_exists = 0;
   5          
   6          
   7          unsigned char const code def_tab2[11] =
   8                                  {                                        // 10k termistor GREYSTONE -40 to 120 Deg.C or -40 to 248 Deg.F 
   9                                   192, 209, 206, 187, 161, 131, 103, 79, 61, 45, 155
  10                                  };
  11          //MHF:12-30-05,Added 4 values to make the tstat can measure minus degree
  12          unsigned char const code def_tab_pic[15] =
  13                                  {                                        // 10k termistor GREYSTONE -40 to 120 Deg.C or -40 to 248 Deg.F 
  14                                   25, 41, 61, 83, 102, 113, 112, 101, 85, 67, 51, 38, 28, 21, 65 //MHF 20010_07 REVISE TEMP LOOKUP TABLE
             - PER NATHANEAL
  15                                  };
  16          signed int   look_up_table1(unsigned int count)
  17          {
  18   1              int   xdata val;
  19   1          char  index=14;
  20   1              int   xdata work_var;
  21   1       
  22   1              if (pic_exists)
  23   1                      work_var= def_tab_pic[index];
  24   1              else
  25   1                      work_var= def_tab2[index];
  26   1                        
  27   1              if (work_var > count )
  28   1                      {
  29   2                              val =  index  * 100 ;
  30   2                              return ( val );
  31   2                      
  32   2                      }
  33   1      
  34   1              do 
  35   1                      {
  36   2                              index--;
  37   2      
  38   2                              if (pic_exists)
  39   2                                      work_var += def_tab_pic[index];
  40   2                              else
  41   2                                      work_var += def_tab2[index];
  42   2      
  43   2                              if( work_var > count)
  44   2                                      {
  45   3                                      val = ( work_var - count )*100;
  46   3      
  47   3                                      if (pic_exists)
  48   3                                              val /= def_tab_pic[index];
C51 COMPILER V9.00   RANGE                                                                 02/28/2013 15:46:45 PAGE 2   

  49   3                                      else
  50   3                                              val /= def_tab2[index];
  51   3                                      if(index >= 4)
  52   3                                      {
  53   4                                              val +=  (index - 4) * 100;
  54   4                                              val = val & 0x7fff;
  55   4                                      }
  56   3                                      else
  57   3                                      {
  58   4                                              val += index*100;
  59   4                                              val = 400 - val;
  60   4                                              val = val | 0x8000;
  61   4                                      }                        
  62   3                                      return (val);
  63   3                                      }
  64   2                      } while (index) ;
  65   1      
  66   1                              val =  33768;
  67   1      
  68   1                              return ( val );
  69   1      }
  70          
  71          
  72          
  73          /******************************************RangeConverter******************************************/
  74          /*
  75          Description: Convert the  raw data from adc to correspond engineer units.
  76          parameter:      finction,       The engineer units want to get,
  77                                  para,           Raw data from ADC
  78                                  i,                      Be used for function = 4,customer sensor,because there are only two 
  79                                                          customer tables,so should check this parameter not bigger than 2 on fun4.
  80                                  cal,            calibration data for the correspond input channel
  81          Return:         Changed input to the expected engineer units.   
  82                                  
  83          */
  84          /*********************************RangeConverter funtion start**************************************/
  85          signed int RangeConverter(unsigned char function, signed int para,unsigned int cal)
  86          {
  87   1              signed int xdata siAdcResult;
  88   1              unsigned char xdata ucFunction;
  89   1       
  90   1              signed   int  xdata siInput;
  91   1              unsigned int  xdata uiCal;
  92   1              signed   int  xdata siResult;
  93   1              bit bAnalogInputStatus;
  94   1              ucFunction = function;
  95   1              siInput = para;
  96   1       
  97   1              uiCal = cal;
  98   1      
  99   1              if(ucFunction == 0)
 100   1              {
 101   2                      siResult = siInput + uiCal - CALIBRATION_OFFSET;        
 102   2              }        
 103   1              //-----------10K Thermistor---------------
 104   1              else if (ucFunction == 1 || ucFunction == 2)
 105   1              {
 106   2       
 107   2                      siAdcResult = look_up_table1(siInput);
 108   2       
 109   2                      //MHF:01-02-06,Added minus temperature display
 110   2                      if(siAdcResult & 0x8000)
C51 COMPILER V9.00   RANGE                                                                 02/28/2013 15:46:45 PAGE 3   

 111   2                      siResult = -(signed int)(siAdcResult & 0x7fff);
 112   2                      else
 113   2                      siResult = siAdcResult;
 114   2                      //analog_input[i] = adc_result;
 115   2                      
 116   2                      if(ucFunction == 2)  
 117   2                              siResult = (siResult * 9)/5 +320; 
 118   2      
 119   2                      // Add the calibration term to the input.
 120   2                      siResult = siResult + uiCal - CALIBRATION_OFFSET;
 121   2      
 122   2                              
 123   2              }
 124   1              //-----------0-100%---------------
 125   1              else if(ucFunction == 3)  //MHF: Feb 24th 2005 new range setting for analog inputs
 126   1              {
 127   2                      siResult = (float)(siInput)/1023*100;
 128   2              }
 129   1              //-----------ON/OFF---------------
 130   1              else if(ucFunction == 4 || ucFunction == 5)
 131   1              {
 132   2                      siAdcResult = (float)(siInput)/1023*50;
 133   2                      if(siAdcResult <= 24)
 134   2                      {
 135   3                              if(ucFunction == 5)
 136   3                                      bAnalogInputStatus = 1; 
 137   3                              else if(ucFunction == 4)
 138   3                                      bAnalogInputStatus = 0; 
 139   3                      }
 140   2                      else if(siAdcResult >= 26)
 141   2                      {
 142   3                              if(ucFunction == 5)
 143   3                                      bAnalogInputStatus = 0; 
 144   3                              else if(ucFunction == 4)
 145   3                                      bAnalogInputStatus = 1; 
 146   3                      }
 147   2                      siResult = (unsigned int)(bAnalogInputStatus);
 148   2                      
 149   2              }
 150   1       
 151   1              
 152   1              return siResult;
 153   1      }
 154          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    825    ----
   CONSTANT SIZE    =     26    ----
   XDATA SIZE       =   ----      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
