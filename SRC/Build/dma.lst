C51 COMPILER V9.00   DMA                                                                   05/08/2013 16:47:33 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE DMA
OBJECT MODULE PLACED IN .\Build\dma.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\SRC\SW_DMA\dma.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..
                    -\SRC\FreeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\
                    -SRC\UART\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\
                    -;..\SRC\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\managemen
                    -t\;..\SRC\dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule;..\SRC\program;..\SRC\S
                    -can) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\dma.lst) OBJECT(.\Build\dma.obj)

line level    source

   1          /*
   2           ******************************************************************************
   3           *     Copyright (c) 2006       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           ******************************************************************************
  10           */
  11          /*=============================================================================
  12           * Module Name: dma.c
  13           * Purpose:
  14           * Author:
  15           * Date:
  16           * Notes:
  17           * $Log: dma.c,v $
  18           * Revision 1.1.1.1  2006/02/23 00:55:10  borbin
  19           * no message
  20           *
  21           *=============================================================================
  22           */
  23          
  24          /* INCLUDE FILE DECLARATIONS */
  25          #include "reg80390.h"
  26          #include "dma.h"
  27          #if (DMA_INCLUDE_ETHERNET_MODULE ==     DMA_YES)
  28          #include "stoe.h"
  29          #endif
  30          
  31          
  32          /*
  33           * ----------------------------------------------------------------------------
  34           * Function Name: DMA_ReadReg
  35           * Purpose: Read software-dma register.
  36           * Params:
  37           * Returns:
  38           * Note:
  39           * ----------------------------------------------------------------------------
  40           */
  41          void DMA_ReadReg(U8_T regaddr, U8_T XDATA* pbuf, U8_T length)
  42          {
  43   1              U8_T    isr;
  44   1      
  45   1              isr = EA;
  46   1              EA = 0;
  47   1              DCIR = regaddr;
  48   1              while (length--)
  49   1                      pbuf[length] = DDR;
  50   1              EA = isr;
C51 COMPILER V9.00   DMA                                                                   05/08/2013 16:47:33 PAGE 2   

  51   1      
  52   1      } /* End of DMA_ReadReg */
  53          
  54          /*
  55           * ----------------------------------------------------------------------------
  56           * Function Name: DMA_WriteReg
  57           * Purpose: Set software-dma register.
  58           * Params:
  59           * Returns:
  60           * Note:
  61           * ----------------------------------------------------------------------------
  62           */
  63          void DMA_WriteReg(U8_T regaddr, U8_T XDATA* pbuf, U8_T length)
  64          {
  65   1              U8_T    isr;
  66   1      
  67   1              isr = EA;
  68   1              EA = 0;
  69   1              while (length--)
  70   1                      DDR = pbuf[length];
  71   1              DCIR = regaddr;
  72   1              EA = isr;
  73   1      
  74   1      } /* End of STOE_DMA_WriteReg */
  75          
  76          /*
  77           * ----------------------------------------------------------------------------
  78           * Function Name: DMA_Init
  79           * Purpose: Initial software-dma module.
  80           * Params:
  81           * Returns:
  82           * Note:
  83           * ----------------------------------------------------------------------------
  84           */
  85          void DMA_Init(void)
  86          {
  87   1              /*set DMA gap*/
  88   1              TDR = DMA_GAP;
  89   1              TCIR = 0x24;
  90   1      
  91   1      } /* End of DMA_Init */
  92          
  93          /*
  94           * ----------------------------------------------------------------------------
  95           * Function Name: DMA_Start
  96           * Purpose: Start software-dma module.
  97           * Params:
  98           * Returns:
  99           * Note:
 100           * ----------------------------------------------------------------------------
 101           */
 102          void DMA_Start(void)
 103          {
 104   1              EINT2 = 1;      /* Enable INT2 interrupt for DMA request. */
 105   1      
 106   1      } /* End of DMA_Start */
 107          
 108          /*
 109           * ----------------------------------------------------------------------------
 110           * Function Name: dma_CheckStatus
 111           * Purpose: Wait software-dma to complete, and check if dma error happened or not?
 112           * Params: 
C51 COMPILER V9.00   DMA                                                                   05/08/2013 16:47:33 PAGE 3   

 113           * Returns: 0 : dma error had happened, so set DMA_FORCE_STOP bit for
 114           *                              dma can work next time.
 115           *                      1 :     dma had completed.
 116           * Note:
 117           * ----------------------------------------------------------------------------
 118           */
 119          
 120          #if 1
 121          U8_T dma_CheckStatus(void)
 122          {
 123   1              U8_T XDATA      temp;
 124   1      
 125   1              while (1)
 126   1              {
 127   2                      DMA_ReadReg(SW_DMA_CMD_REG, &temp, 1);
 128   2                      if (temp & 0x37)
 129   2                      {
 130   3                              if (temp & DMA_ERROR_BIT)
 131   3                              {
 132   4                                      temp &= ~0x7f;
 133   4                                      temp |= DMA_FORCE_STOP;
 134   4                                      DMA_WriteReg(SW_DMA_CMD_REG, &temp, 1);
 135   4      
 136   4                                      return 0;
 137   4                              }
 138   3                      }
 139   2                      else
 140   2                              return 1;
 141   2              }
 142   1      
 143   1      } /* End of dma_CheckStatus */
 144          
 145          #if (DMA_INCLUDE_ETHERNET_MODULE == DMA_YES)
 146          /*
 147          * -----------------------------------------------------------------------------
 148           * Function Name: DMA_GrantXdata
 149           * Purpose: Use sw-dma doing memory copy. The scope of source and destination
 150           *                              target must     be smaller than 64k sram memory.
 151           *                      If the scope of either source or destination target is large than
 152           *                              64k memory,     the programmers can call DMA_Grant() instead of
 153           *                              this function.
 154           *                      DMA_GrantXdata() can run faster than DMA_Grant() function.
 155           * Params: 
 156           * Returns: A address of XDATA memory that point to the next address of
 157           *                              the end address of the scope of destination target.
 158           * Note:
 159           * ----------------------------------------------------------------------------
 160           */
 161          U8_T XDATA* DMA_GrantXdata(U8_T XDATA* pdest, U8_T XDATA* psour, U16_T length)
 162          {
 163   1              U8_T XDATA              temp[3];
 164   1              U16_T XDATA*    ptempshort = (U16_T XDATA*)&temp[1];
 165   1              U8_T                    dmatype = 0;
 166   1      
 167   1              temp[0] = 0;
 168   1              *ptempshort = psour;
 169   1              DMA_WriteReg(SW_DMA_SOUR_ADDR_REG, temp, 3);
 170   1              *ptempshort = pdest;
 171   1              DMA_WriteReg(SW_DMA_TARGET_ADDR_REG, temp, 3);
 172   1              *ptempshort = length;
 173   1              DMA_WriteReg(SW_DMA_BYTE_COUNT_REG, temp + 1, 2);
 174   1      
C51 COMPILER V9.00   DMA                                                                   05/08/2013 16:47:33 PAGE 4   

 175   1              if ((psour >= PBDP->RcvStartAddr) && (psour <= PBDP->RcvEndAddr))
 176   1                      dmatype = DMA_FROM_RPBR;
 177   1              if ((pdest >= PBDP->XmtStartAddr) && (pdest <= PBDP->XmtEndAddr))
 178   1                      dmatype |= DMA_TO_TPBR;
 179   1      
 180   1              temp[0] = (DMA_CMD_GO | dmatype);
 181   1              DMA_WriteReg(SW_DMA_CMD_REG, temp, 1);
 182   1      
 183   1              if (dmatype | DMA_TO_TPBR)
 184   1              {
 185   2                      pdest += length;
 186   2                      if (pdest > PBDP->XmtEndAddr)
 187   2                              pdest -= STOE_XMIT_BUF_SIZE;
 188   2              }
 189   1      
 190   1              /* check software dma had completed. */
 191   1              if (dma_CheckStatus())
 192   1                      return pdest;
 193   1              else
 194   1                      return 0;
 195   1      
 196   1      } /* DMA_GrantXdata */
 197          
 198          #if (DMA_SRAM_RANGE == DMA_COPY_LARGE_THAN_64K)
 199          /*
 200          * -----------------------------------------------------------------------------
 201           * Function Name: DMA_Grant
 202           * Purpose: Use sw-dma doing memory copy. 
 203           * Params: 
 204           * Returns: A address of sram memory that point to the next address of
 205           *                              the end address of the scope of destination target.
 206           * Note:
 207           * ----------------------------------------------------------------------------
 208           */
 209          U8_T* DMA_Grant(U8_T* pdest, U8_T* psour, U16_T length)
 210          {
 211   1              U8_T XDATA              sourtemp[4];
 212   1              U8_T XDATA              desttemp[4];
 213   1              U32_T XDATA*    psourtemplong = (U32_T XDATA*)&sourtemp[0];
 214   1              U32_T XDATA*    pdesttemplong = (U32_T XDATA*)&desttemp[0];
 215   1              U16_T XDATA*    ptempshort;
 216   1              U8_T                    dmatype = 0;
 217   1              U8_T*                   ptemp;
 218   1      
 219   1              *psourtemplong = (U32_T)psour;
 220   1              *pdesttemplong = (U32_T)pdest;
 221   1      
 222   1              sourtemp[1]--;  /* for Keil C memory type */
 223   1              DMA_WriteReg(SW_DMA_SOUR_ADDR_REG, &sourtemp[1], 3);
 224   1      
 225   1              if (sourtemp[1] == 0)
 226   1              {
 227   2                      ptempshort = (U16_T XDATA*)&sourtemp[2];
 228   2                      if ((*ptempshort >= (U16_T)PBDP->RcvStartAddr) && (*ptempshort <= (U16_T)PBDP->RcvEndAddr))
 229   2                              dmatype = DMA_FROM_RPBR;
 230   2              }
 231   1      
 232   1              desttemp[1]--;  /* for Keil C memory type */
 233   1              DMA_WriteReg(SW_DMA_TARGET_ADDR_REG, &desttemp[1], 3);
 234   1      
 235   1              if (desttemp[1] == 0)
 236   1              {
C51 COMPILER V9.00   DMA                                                                   05/08/2013 16:47:33 PAGE 5   

 237   2                      ptempshort = (U16_T XDATA*)&desttemp[2];
 238   2                      if ((*ptempshort >= (U16_T)PBDP->XmtStartAddr) && (*ptempshort <= (U16_T)PBDP->XmtEndAddr))
 239   2                              dmatype |= DMA_TO_TPBR;
 240   2              }
 241   1      
 242   1              ptempshort = (U16_T XDATA*)&sourtemp[0];
 243   1              *ptempshort = length;
 244   1              DMA_WriteReg(SW_DMA_BYTE_COUNT_REG, sourtemp, 2);
 245   1      
 246   1              sourtemp[0] = (DMA_CMD_GO | dmatype);
 247   1              DMA_WriteReg(SW_DMA_CMD_REG, sourtemp, 1);
 248   1      
 249   1              if (dmatype | DMA_TO_TPBR)
 250   1              {
 251   2                      ptemp = pdest;
 252   2                      pdest += length;
 253   2      /* for KEIL */
 254   2                      if (ptemp > pdest)
 255   2                              pdest += 0x10000;
 256   2      /* end */
 257   2                      ptempshort = (U16_T XDATA*)&desttemp[2];
 258   2                      (*ptempshort) += length;
 259   2                      if (*ptempshort > (U16_T)PBDP->XmtEndAddr)
 260   2                              pdest -= STOE_XMIT_BUF_SIZE;
 261   2              }
 262   1      
 263   1              /* check software dma had completed. */
 264   1              if (dma_CheckStatus())
 265   1                      return pdest;
 266   1              else
 267   1                      return 0;
 268   1      
 269   1      } /* DMA_Grant */
 270          #endif /* End of #if (DMA_SRAM_RANGE == DMA_COPY_LARGE_THAN_64K)*/
 271          #else
              /*
              * -----------------------------------------------------------------------------
               * Function Name: DMA_GrantXdata
               * Purpose: Use sw-dma doing memory copy. The scope of source and destination
               *                              target must     be smaller than 64k sram memory.
               *                      If the scope of either source or destination target is large than
               *                              64k memory,     the programmers can call DMA_Grant() instead of
               *                              this function.
               *                      DMA_GrantXdata() can run faster than DMA_Grant() function.
               * Params: 
               * Returns:  A address of XDATA memory that point to the next address of
               *                              the end address of the scope of destination target.
               * Note:
               * ----------------------------------------------------------------------------
               */
              U8_T XDATA* DMA_GrantXdata(U8_T XDATA* pdest, U8_T XDATA* psour, U16_T length)
              {
                      U8_T XDATA              temp[3];
                      U16_T XDATA*    ptempshort = (U16_T XDATA*)&temp[1];
                              
                      temp[0] = 0;
                      *ptempshort = psour;
                      DMA_WriteReg(SW_DMA_SOUR_ADDR_REG, temp, 3);
                      *ptempshort = pdest;
                      DMA_WriteReg(SW_DMA_TARGET_ADDR_REG, temp, 3);
                      *ptempshort = length;
                      DMA_WriteReg(SW_DMA_BYTE_COUNT_REG, temp + 1, 2);
C51 COMPILER V9.00   DMA                                                                   05/08/2013 16:47:33 PAGE 6   

              
                      temp[0] = DMA_CMD_GO;
                      DMA_WriteReg(SW_DMA_CMD_REG, temp, 1);
              
                      pdest += length;
              
                      /* check software dma had completed. */
                      if (dma_CheckStatus())
                              return pdest;
                      else
                              return 0;
              
              } /* DMA_GrantXdata */
              
              #if (DMA_SRAM_RANGE == DMA_COPY_LARGE_THAN_64K)
              /*
              * -----------------------------------------------------------------------------
               * Function Name: DMA_Grant
               * Purpose: Use dma doing memory copy. 
               * Params:
               * Returns:  A address of sram memory that point to the next address of
               *                              the end address of the scope of destination target.
               * Note:
               * ----------------------------------------------------------------------------
               */
              U8_T* DMA_Grant(U8_T* pdest, U8_T* psour, U16_T length)
              {
                      U8_T XDATA              temp[4];
                      U32_T XDATA*    ptemplong = (U32_T XDATA*)&temp[0];
                      U16_T XDATA*    ptempshort;
                      U8_T*                   ptemp;
              
                      *ptemplong = (U32_T)psour;
                      temp[1]--;      /* for Keil C memory type */
                      DMA_WriteReg(SW_DMA_SOUR_ADDR_REG, &temp[1], 3);
              
                      *ptemplong = (U32_T)pdest;
                      temp[1]--;      /* for Keil C memory type */
                      DMA_WriteReg(SW_DMA_TARGET_ADDR_REG, &temp[1], 3);
              
                      ptempshort = (U16_T XDATA*)&temp[0];
                      *ptempshort = length;
                      DMA_WriteReg(SW_DMA_BYTE_COUNT_REG, temp, 2);
              
                      temp[0] = DMA_CMD_GO;
                      DMA_WriteReg(SW_DMA_CMD_REG, temp, 1);
              
                      ptemp = pdest;
                      pdest += length;
              /* for KEIL */
                      if (ptemp > pdest)
                              pdest += 0x10000;
              /* end */
                      /* check software dma had completed. */
                      if (dma_CheckStatus())
                              return pdest;
                      else
                              return 0;
              
              } /* DMA_Grant */
              #endif /* End of #if (DMA_SRAM_RANGE == DMA_COPY_LARGE_THAN_64K) */
              
C51 COMPILER V9.00   DMA                                                                   05/08/2013 16:47:33 PAGE 7   

              
              #endif /* End of #if (DMA_INCLUDE_ETHERNET_MODULE == DMA_YES)*/
 363          
 364          
 365          /* End of dma.c */
 366          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1242    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      38
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
