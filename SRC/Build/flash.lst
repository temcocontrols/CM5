C51 COMPILER V9.00   FLASH                                                                 05/08/2013 16:47:36 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE FLASH
OBJECT MODULE PLACED IN .\Build\flash.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Flash\flash.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\F
                    -reeRTOSSource\include\;..\SRC\FreeRTOSSource\portable\Keil\AX11000;..\SRC\CPU\;..\SRC\MS_TIMER\;..\SRC\SW_DMA\;..\SRC\UA
                    -RT\;..\SRC\ETHERNET\;..\SRC\APPLICATION\;..\SRC\ETHERNET\;..\SRC\tcpip\;..\SRC\ADAPTER;..\SRC\main;..\SRC\SD_Card\;..\SR
                    -C\GSM\;..\SRC\Web\;..\SRC\SPI\;..\SRC\I2C\;..\SRC\PCA\;..\SRC\Modbus\;..\SRC\buffer\;..\SRC\hsur\;..\SRC\management\;..\
                    -SRC\dhcp\;..\SRC\pppoe\;..\SRC\flash;..\SRC\SNTP;..\SRC\display;..\SRC\key;..\SRC\schedule;..\SRC\program;..\SRC\Scan) D
                    -EFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\Build\flash.lst) OBJECT(.\Build\flash.obj)

line level    source

   1          /*
   2           *********************************************************************************
   3           *     Copyright (c) 2006       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           *********************************************************************************
  10           */
  11          /*================================================================================
  12           * Module Name : flash.c
  13           * Purpose     : 
  14           * Author      : 
  15           * Date        : 
  16           * Notes       : 
  17           *
  18           *================================================================================
  19           */
  20          
  21          
  22          
  23          #include        <absacc.h>
  24          #include        "reg80390.h"
  25          #include        "types.h"
  26          #include        "ax11000.h"
  27          #include        "flash.h"
  28          #include        "mstimer.h"
  29          #include        <absacc.h>
  30          #include        "reg80390.h"
  31          #include        "ax11000_cfg.h"
  32          #include        "flash.h"
  33          
  34          /* GLOBAL VARIABLE DECLARATIONS */
  35          //U8_T IDATA fwAutoUpdated[4] _at_ 0x31;
  36          
  37          
  38          /* GLOBAL VARIABLE DECLARATIONS */
  39          U8_T CODE* PFlash = 0x6000;
  40          
  41          
  42          #if (RUNTIME_CODE_START_ADDRESS == RUNTIME_CODE_START_AT_24kH)
  43          
  44          typedef S16_T (*pFlashWrite)(U32_T ProgAddr, U8_T * ptWrData/*, U32_T ProgLen, U8_T BootldrSel*/);
  45          typedef S16_T (*pFlashErase)(U32_T EraAddr);
  46          
  47          /*
  48           *--------------------------------------------------------------------------------
  49           * S16_T IntFlashWrite(U32_T ProgAddr, U8_T *ptWrData,
  50           *                     U32_T ProgLen, U8_T BootldrSel)
C51 COMPILER V9.00   FLASH                                                                 05/08/2013 16:47:36 PAGE 2   

  51           * Purpose : save prWrtData in Praddr with ProgLen bytes
  52           * Params  :    ProgAddr - start address
  53           *                              ptWrData - source data array
  54           *                              ProgLen  - no use
  55           *                              BootldrSel  - no use
  56           * Returns : TRUE or FALSE, whether the routine is done successfully 
  57           * Note    :
  58           *-------------------------------------------------------------------------------
  59           */
  60          
  61          S16_T IntFlashWrite(U32_T ProgAddr, U8_T *ptWrData, U32_T ProgLen, U8_T BootldrSel)
  62          {
  63   1              U8_T    ret = FALSE;
  64   1              pFlashWrite     ptrFlashWrite = (void code*)0x003100;
  65   1      
  66   1              ProgLen = ProgLen;
  67   1              BootldrSel = BootldrSel;
  68   1      
  69   1              EA = 0;
  70   1              ret = (*ptrFlashWrite)(ProgAddr, ptWrData);     
  71   1              EA = 1;
  72   1              if (ret == FALSE)               return FALSE;   
  73   1              return TRUE;
  74   1         
  75   1      }
  76          
  77          /*
  78           *--------------------------------------------------------------------------------
  79           * S16_T S16_T IntFlashErase(U8_T EraseSel,U32_T EraAddr) 
  80           * Purpose : Erase a flash block
  81           * Params  : EraseSel - no use
  82           *                       EraAddr  - start flash block address you want to erase
  83           * Returns : TRUE or FALSE, whether the routine is done successfully 
  84           * Note    :
  85           *-------------------------------------------------------------------------------
  86           */
  87          S16_T IntFlashErase(U8_T EraseSel,U32_T EraAddr) //large reentrant
  88          {
  89   1              U8_T    ret = FALSE;    
  90   1              pFlashErase  ptrFlashErase = (void code*)0x003B00;
  91   1      
  92   1              EraseSel = EraseSel;
  93   1      
  94   1              EA = 0;
  95   1              ret = (*ptrFlashErase)(EraAddr);
  96   1              EA = 1; 
  97   1              if (ret == FALSE)               return FALSE;
  98   1              return TRUE;
  99   1      }
 100          
 101          #else
              /*
               *--------------------------------------------------------------------------------
               * S16_T IntFlashWrite(U32_T ProgAddr, U8_T *ptWrData,
               *                     U32_T ProgLen, U8_T BootldrSel)
               * Purpose : save prWrtData in Praddr with ProgLen bytes
               * Params  :    ProgAddr - start address
               *                              ptWrData - source data array
               *                              ProgLen  - the length of source datas
               *                              BootldrSel  - select the boot load way or application way, for my application ,select ERA_RUN
               * Returns : TRUE or FALSE, whether the routine is done successfully 
               * Note    :
C51 COMPILER V9.00   FLASH                                                                 05/08/2013 16:47:36 PAGE 3   

               *--------------------------------------------------------------------------------
               */
              S16_T IntFlashWrite(U32_T ProgAddr, U8_T *ptWrData, U32_T ProgLen, U8_T BootldrSel) 
              {
                      U8_T    LastWtst;
              //      U32_T   idata i;
              //      U8_T    idata PollData;
                      U32_T   i;
                      U8_T    PollData;
              
                      LastWtst = WTST;
                      WTST = 0x07;
                      EA = 0;
              
                      if (CSREPR & PMS) // SRAM shadow
                      {
                              if (BootldrSel & ERA_BLD)
                              {
                                      CSREPR |= FAES | FARM;
                                      for (i = 0 ; i < 0x4000 ; i++)
                                      {
                                              FLASH_WR_ENB;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xAA;
                                              FVAR(U8_T, 0x4000 + 0x0002AA) = 0x55;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xA0;
                                              FVAR(U8_T, 0x4000 + i) = *(ptWrData + i);
                                              FLASH_WR_DISB;
                                              do
                                              {
                                                      PollData = FCVAR(U8_T, 0x4000 + i);
                                              } while (PollData != *(ptWrData + i)) ;
                                      }
                                      CSREPR &= ~FARM;
              
                                      for (i = 0x4000 ; i < ProgLen ; i++)
                                      {
                                              FLASH_WR_ENB;
                                              CSREPR |= FARM;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xAA;
                                              FVAR(U8_T, 0x4000 + 0x0002AA) = 0x55;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xA0;
                                              CSREPR &= ~FARM;
                                              FVAR(U8_T, i) = *(ptWrData + i);
                                              FLASH_WR_DISB;
                                              do
                                              {
                                                      PollData = FCVAR(U8_T, i);
                                              } while (PollData != *(ptWrData + i)) ;
                                      }
                                      CSREPR &= ~FAES;
                              }
                              else
                              {
                                      CSREPR |= FAES;
                                      for (i = 0 ; i < ProgLen ; i++)
                                      {
                                              FLASH_WR_ENB;
                                              CSREPR |= FARM;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xAA;
                                              FVAR(U8_T, 0x4000 + 0x0002AA) = 0x55;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xA0;
                                              CSREPR &= ~FARM;
C51 COMPILER V9.00   FLASH                                                                 05/08/2013 16:47:36 PAGE 4   

                                              FVAR(U8_T, ProgAddr + i) = *(ptWrData + i);
                                              FLASH_WR_DISB;
                                              do
                                              {
                                                      PollData = FCVAR(U8_T, ProgAddr + i);
                                              } while (PollData != *(ptWrData + i)) ;
                                      }
                                      CSREPR &= ~FAES;
                              }
                      }
                      else // Flash, No shadow
                      {
                              CSREPR &= ~FAES;
              
                              if (BootldrSel & ERA_BLD)
                              {
                                      CSREPR |= FARM;
                                      for (i = 0 ; i < 0x4000 ; i++)
                                      {
                                              FLASH_WR_ENB;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xAA;
                                              FVAR(U8_T, 0x4000 + 0x0002AA) = 0x55;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xA0;
                                              FVAR(U8_T, 0x4000 + i) = *(ptWrData + i);
                                              FLASH_WR_DISB;
                                              do
                                              {
                                                      PollData = FCVAR(U8_T, 0x4000 + i);
                                              } while (PollData != *(ptWrData + i)) ;
                                      }
                                      CSREPR &= ~FARM;
                                      for (i = 0x4000 ; i < ProgLen ; i++)
                                      {
                                              FLASH_WR_ENB;
                                              CSREPR |= FARM;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xAA;
                                              FVAR(U8_T, 0x4000 + 0x0002AA) = 0x55;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xA0;
                                              CSREPR &= ~FARM;
                                              FVAR(U8_T, i) = *(ptWrData + i);
                                              FLASH_WR_DISB;
                                              do
                                              {
                                                      PollData = FCVAR(U8_T, i);
                                              } while (PollData != *(ptWrData + i)) ;
                                      }
                              }
                              else
                              {
                                      for (i = 0 ; i < ProgLen ; i++)
                                      {
                                              FLASH_WR_ENB;
                                              CSREPR |= FARM;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xAA;
                                              FVAR(U8_T, 0x4000 + 0x0002AA) = 0x55;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xA0;
                                              CSREPR &= ~FARM;
                                              FVAR(U8_T, ProgAddr + i) = *(ptWrData + i);
                                              FLASH_WR_DISB;
                                              do
                                              {
                                                      PollData = FCVAR(U8_T, ProgAddr + i);
C51 COMPILER V9.00   FLASH                                                                 05/08/2013 16:47:36 PAGE 5   

                                              } while (PollData != *(ptWrData + i)) ;
                                      }
                              }
                      }
              
                      WTST = LastWtst;
                      EA = 1;
              
                      return TRUE;
              }
              
              /*
               *--------------------------------------------------------------------------------
               * S16_T S16_T IntFlashErase(U8_T EraseSel,U32_T EraAddr) 
               * Purpose : Erase a flash block
               * Params  : EraseSel - select erase block. for my application, EraseSel = ERA_RUN
               *                       EraAddr  - start flash block address you want to erase
               * Returns : TRUE or FALSE, whether the routine is done successfully 
               * Note    : changed by chelsea 13th,Nov
               *--------------------------------------------------------------------------------
               */
              S16_T IntFlashErase(U8_T EraseSel,U32_T EraAddr) 
              {
              //      U8_T    idata PollData, LastWtst;
              //      U32_T   idata BaseAddr;
                      U8_T    PollData, LastWtst;
                      U32_T   BaseAddr;
                      U32_T   temp;
                      temp = EraAddr;
                      LastWtst = WTST;
                      WTST = 0x07;
                      EA = 0;
                      BaseAddr = 0x4000;
                      
                      FLASH_WR_ENB;
              
                      if (CSREPR & PMS) // SRAM shadow
                              CSREPR |= FAES;
                      else
                              CSREPR &= ~FAES;
                      
                      if (EraseSel & ERA_BLD) // Erase  BootLoader
                      {
                              CSREPR |= FARM;
                              
                              FVAR(U8_T, BaseAddr + 0x000555) = 0xAA;
                              FVAR(U8_T, BaseAddr + 0x0002AA) = 0x55;
                              FVAR(U8_T, BaseAddr + 0x000555) = 0x80;
                              FVAR(U8_T, BaseAddr + 0x000555) = 0xAA;
                              FVAR(U8_T, BaseAddr + 0x0002AA) = 0x55;
              
                              FVAR(U8_T, BaseAddr + 0x000000) = 0x30;
                              
                              CSREPR &= ~FARM;
                      }
                      else 
                      {
                              CSREPR |= FARM;
              
                              FVAR(U8_T, BaseAddr + 0x000555) = 0xAA;
                              FVAR(U8_T, BaseAddr + 0x0002AA) = 0x55;
                              FVAR(U8_T, BaseAddr + 0x000555) = 0x80;
C51 COMPILER V9.00   FLASH                                                                 05/08/2013 16:47:36 PAGE 6   

                              FVAR(U8_T, BaseAddr + 0x000555) = 0xAA;
                              FVAR(U8_T, BaseAddr + 0x0002AA) = 0x55;
              
                              CSREPR &= ~FARM;
                      if(EraseSel & ERA_CFG) // Erase configuration data
                      {
              
                                      FVAR(U8_T, 0x004000) = 0x30;
                      }
                              else                               // Erase runtime code
                              {
                                      /*FVAR(U8_T, 0x006000) = 0x30;
                                      FVAR(U8_T, 0x008000) = 0x30;
                                      FVAR(U8_T, 0x010000) = 0x30;
                                      FVAR(U8_T, 0x020000) = 0x30;
                                      FVAR(U8_T, 0x030000) = 0x30;
                                      FVAR(U8_T, 0x040000) = 0x30;
                                      FVAR(U8_T, 0x050000) = 0x30;
                                      FVAR(U8_T, 0x060000) = 0x30;
                                      FVAR(U8_T, 0x070000) = 0x30;*/
                                      FVAR(U8_T, temp) = 0x30;
                              }
                      }
                      FLASH_WR_DISB;
                  // check for completition
                      if (EraseSel & ERA_BLD)
                      {
                              CSREPR |= FARM;
                              while (1)
                              {   
                                      PollData = FCVAR(U8_T, BaseAddr + 0x000000);
                                      if (PollData == 0xFF)
                                      {
                                              break;
                                      }
                              }
                              CSREPR &= ~FARM;
                      }
                      else
                      {
                              while (1)
                              {
                          if(EraseSel & ERA_CFG)
                                              PollData = FCVAR(U8_T, BaseAddr + 0x000000);
                                      else
                                              PollData = FCVAR(U8_T, temp/*BaseAddr + 0x002000*/);
              
                                      if (PollData == 0xFF)
                                      {
                                              break;
                                      }
                              }
                      }
              
                      CSREPR &= ~FAES;
              
                      WTST = LastWtst;
                      EA = 1;
              
                      return TRUE;
              }
              #endif
C51 COMPILER V9.00   FLASH                                                                 05/08/2013 16:47:36 PAGE 7   

 361          
 362          
 363          
 364          U8_T IntFlashReadByte(U32_T location, U8_T *value)
 365          {
 366   1      
 367   1          *value = FCVAR(U8_T,location);
 368   1              
 369   1              return TRUE;
 370   1      
 371   1      }
 372          
 373          /*
 374           *--------------------------------------------------------------------------------
 375           * U8_T IntFlashWriteInt(U32_T location, U16_T value)
 376           * Purpose : write a word
 377           * Params  : location - flash address what you want to write 
 378           *                       value  - data what you want to write
 379           * Returns : TRUE or FALSE, whether the routine is done successfully 
 380           * Note    : 
 381           *--------------------------------------------------------------------------------
 382           */
 383          U8_T IntFlashReadInt(U32_T location, U16_T *value)
 384          {
 385   1              U8_T temp1,temp2;
 386   1              IntFlashReadByte(location + 1,&temp1);
 387   1              IntFlashReadByte(location,&temp2);
 388   1              *value = temp1 * 256 + temp2;   
 389   1              
 390   1              return TRUE;
 391   1      
 392   1      }
 393          
 394          
 395          
 396          
 397          U8_T IntFlashWriteByte(U32_T location,U8_T value)
 398          {
 399   1              IntFlashWrite(location,&value,1,0);
 400   1              return TRUE;
 401   1      }
 402          
 403          U8_T IntFlashWriteInt(U32_T location,U16_T value)
 404          {
 405   1              U8_T temp;
 406   1              temp = (U8_T)value;
 407   1              IntFlashWriteByte(location,temp);
 408   1              temp = value >> 8;
 409   1              IntFlashWriteByte(location+1,temp);
 410   1              return TRUE;
 411   1      }
 412          
 413          #if 1
 414          void MassFlashWrite(U32_T location,U8_T *value,U32_T lenght)
 415          {
 416   1              U16_T i;
 417   1              /*for(i = 0;i < lenght;i++)
 418   1              IntFlashWrite((U32_T)(location + FLASH_BLOCK + i),(value + i),1,0);*/
 419   1              /* after add watchdog , must short flash time*/
 420   1              for(i = 0;i < lenght;i++)
 421   1              IntFlashWrite((U32_T)(location + FLASH_BLOCK + i),(value + i),1,0);
 422   1              //IntFlashWrite((U32_T)(location + FLASH_BLOCK),value,lenght,0);
C51 COMPILER V9.00   FLASH                                                                 05/08/2013 16:47:36 PAGE 8   

 423   1      }
 424          
 425          
 426          void ISPMassFlashWrite(U32_T location,U8_T *value,U32_T lenght)
 427          {
 428   1              U16_T i;
 429   1              for(i = 0;i < lenght;i++)
 430   1              IntFlashWrite((U32_T)(location + FLASH_BLOCK + i),(value + i),1,0);
 431   1              /* after add watchdog , must short flash time*/
 432   1              //IntFlashWrite((U32_T)(location +0x60000),value,lenght,0);
 433   1      }
 434          
 435          #endif
 436          
 437          
 438          /* LOCAL SUBPROGRAM BODIES */
 439          
 440          
 441          /* EXPORTED SUBPROGRAM BODIES */
 442          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    859    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2      69
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
